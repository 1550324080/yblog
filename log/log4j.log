[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} connected
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} created. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} executed. 10.9394 millis. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Header: [count(0)]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [12]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} Parameters : [5]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} executed. 1.7647 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 108, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} executed. 0.8544 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 108, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [12, Spring Boot 2 权威发布,   如果这两天登录 [https://start.spring.io/ ](https://start.spring.io/ )就会发现，Spring Boot 默认版本已经升到了 2.1.0。这是因为 Spring Boot 刚刚发布了 2.1.0 版本，我们来看下 Spring Boot 2 发布以来第一个子版本都发布了哪些内容？  

**2.1 中的新特性**     
  ●将spring-boot-starter-oauth2-oidc-client重命名为spring-boot-starter-oauth2-client命名更简洁  
  ●添加 OAuth2 资源服务 starter，OAuth2 一个用于认证的组件  
  ●支持 ConditionalOnBean 和 ConditionalOnMissingBean 下的参数化容器  
  ●自动配置 applicationTaskExecutor bean 的延迟加载来避免不必要的日志记录  
  ●将 DatabaseDriver＃SAP 重命名为 DatabaseDriver  
  ●跳过重启器不仅适用于 JUnit4，也适用于 JUnit5  
  ●在 Jest HealthIndicator 中使用集群端点  
  ●当 DevTools 禁用重启时添加日志输出  
  ●添加注解：@ConditionalOnMissingServletFilter提高 Servlet Filters 的自动装配。
  
**2.1 中的组件升级**  
  ●升级 Hibernate 5.3，Hibernate 的支持升级到了 5.3  
  ●升级 Tomcat 9 ，支持最新的 tomcat 9  
  ●支持 Java 11，Java 现在更新越来越快，Spring 快赶不上了    
  ●升级 Thymeleaf Extras Springsecurity 到 3.0.4.RELEASE ，thymeleaf-extras-springsecurity 是 Thymeleaf 提供集成 Spring Security 的组件  
  ●升级 Joda Time 2.10.1，Joda-Time， 面向 Java 应用程序的日期/时间库的替代选择，Joda-Time 令时间和日期值变得易于管理、操作和理解。  
  ●升级 Lettuce 5.1.2.RELEASE ，Lettuce 前面说过，传说中 Redis 最快的客户端。  
  ●升级 Reactor Californium-SR2 ，Californium 是物联网云服务的 Java COAP 实现。因此，它更专注的是可扩展性和可用性而不是像嵌入式设备那样关注资源效率。不过，Californium 也适合嵌入式的 JVM。  
  ●升级 Maven Failsafe Plugin 2.22.1 ，Maven 中的测试插件。  
  ●升级 Flyway 5.2.1 ， Flyway是一款开源的数据库版本管理工具  
  ●升级 Aspectj 1.9.2 ，AspectJ 是 Java 中流行的 AOP（Aspect-oriented Programming）编程扩展框架，是 Eclipse 托管给 Apache 基金会的一个开源项目。  
  ●升级 Mysql 8.0.13 ，Mysql 支持到 8。  
  ●...  
  更多的详细内容可以参考这里：[Spring Boot 2.1 Release Notes](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.1-Release-Notes)
, 2018-12-12, 2021-05-21, 默认分类, Spring Boot 2, true, null, 62, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [8, JDK 8——聚合操作, &emsp;&emsp;在Java8版本中，JDK包含许多聚合操作（如平均值，总和，最小，最大，和计数），返回一个计算流stream的聚合结果。这些聚合操作被称为聚合操作。JDK除返回单个值的聚合操作外，还有很多聚合操作返回一个collection集合实例。很多的reduce操作执行特定的任务，如求平均值或按类别分组元素。  

**1. 聚合操作简介**

  在开发中，多数情况下会涉及到对集合、数组中元素的操作，在JDK 8之前都是通过普通的循环遍历出每一个元素，然后还会穿插一些if条件语句选择性的对元素进行查找、过滤、修改等操作，这种原始的操作方法虽然可行，但是代码量较大并且执行效率较低。  
  为此，JDK 8中新增了一个Stream接口，该接口可以将集合、数组的中的元素转换为Stream流的形式，并结合Lambda表达式的优势来进一步简化集合、数组中元素的查找、过滤、转换等操作，这一新功能就是JDK 8中的聚合操作。  
  在程序中，使用聚合操作没有绝对的语法规范，根据实际操作流程，主要可以分为以下3个步骤：  
  （1）将原始集合或者数组对象转换为Stream流对象；  
  （2）对Stream流对象中的元素进行一系列的过滤、查找等中间操作（Intermediate Operations），然后仍然返回一个Stream流对象；  
  （3）对Stream流进行遍历、统计、收集等终结操作（Terminal Operation），获取想要的结果。  
  接下来，就根据上面聚合操作的3个步骤，通过一个案例来演示聚合操作的基本用法，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example31 {
 4		public static void main(String[] args) {
 5	          // 创建一个List集合对象
 6			List<String> list = new ArrayList<>(); 
 7			list.add("张三");
 8			list.add("李四");
 9			list.add("张小明");
 10			list.add("张阳");
 11			// 1、创建一个Stream流对象
 12			Stream<String> stream = list.stream();
 13			// 2、对Stream流中的元素分别进行过滤、截取操作
 14		       Stream<String> stream2 = stream.filter(i -> i.startsWith("张"));
 15			Stream<String> stream3 = stream2.limit(2);
 16			// 3、对Stream流中的元素进行终结操作，进行遍历输出
 17			stream3.forEach(j -> System.out.println(j));
 18			System.out.println("=======");
 19	         // 通过链式表达式的形式完成聚合操作
 20			list.stream().filter(i -> i.startsWith("张"))
 21						 .limit(2)
 22						 .forEach(j -> System.out.println(j));
 23		}
 24	}
``` 
   运行结果如下图所示。
![alt](/article_img/lambda/3.jpg)
  上述示例代码中，先创建了一个List集合，然后根据聚合操作的3个步骤实现了集合对象的聚合操作，对集合中的元素使用Stream流的形式进行过滤（filter）、截取（limit），并进行遍历输出。其中第12~17行代码分步骤详细展示了聚合操作，而第20~22行代码是使用了链式表达式（调用有返回值的方法时不获取返回值而是直接再调用另一个方法）实现了聚合操作，该表达式的语法格式更简洁、高效，这种链式调用也被称为操作管道流。

**2. 创建Stream流对象**  
  在上一小节中，介绍了聚合操作的主要使用步骤，其中首要解决的问题就是创建Stream流对象。聚合操作针对的就是可迭代数据进行的操作，如集合、数组等，所以创建Stream流对象其实就是将集合、数组等通过一些方法转换为Stream流对象。  
  在Java中，集合对象有对应的集合类，可以通过集合类提供的静态方法创建Stream流对象，而数组数据却没有对应的数组类，所以必须通过其他方法创建Stream流对象。针对不同的源数据，Java提供了多种创建Stream流对象的方式，分别如下：  
  （1）所有的Collections集合都可以使用stream()静态方法获取Stream流对象；  
  （2）Stream接口的of()静态方法可以获取基本类型包装类数组、引用类型数组和单个元素的Stream流对象；  
  （3）Arrays数组工具类的stream()静态方法也可以获取数组元素的Stream流对象。  
  接下来，通过一个案例来学习聚合操作中如何创建Stream流对象，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example32 {
 4		public static void main(String[] args) {
 5	          // 创建一个数组
 6			Integer[] array = { 9, 8, 3, 5, 2 };       
 7	          // 将数组转换为List集合
 8			List<Integer> list = Arrays.asList(array); 
 9			// 1、使用集合对象的stream()静态方法创建Stream流对象
 10			Stream<Integer> stream = list.stream();
 11			stream.forEach(i -> System.out.print(i+" "));
 12			System.out.println();
 13			// 2、使用Stream接口的of()静态方法创建Stream流对象
 14			Stream<Integer> stream2 = Stream.of(array);
 15			stream2.forEach(i -> System.out.print(i+" "));
 16			System.out.println();
 17			// 3、使用Arrays数组工具类的stream()静态方法创建Stream流对象
 18			Stream<Integer> stream3 = Arrays.stream(array);
 19			stream3.forEach(i -> System.out.print(i+" "));
 20		}
 21	}
```  
  运行结果如下图所示。
![alt](/article_img/lambda/4.jpg)
  上述示例代码中，先创建了一个数组和一个集合，然后通过三种方式实现了Stream流对象的创建，并通过Stream流对象的forEach()方法结合Lambda表达式完成了集合和数组中元素的遍历。  

**小提示：**  
  在JDK 8中，只针对单列集合Collections接口对象提供了stream()静态方法获取Stream流对象，并未对Map集合提供相关方法获取Stream流对象，所以想要用Map集合创建Stream流对象必须先通过Map集合的keySet()、values()、entrySet()等方法将Map集合转换为单列Set集合，然后再使用单列集合的stream()静态方法获取对应键、值集合的Stream流对象。

, 2018-12-02, null, 默认分类, JDK 8,聚合操作, true, null, 34, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [9, 虚拟化容器技术——Docker运行机制介绍,   Docker是一个开源的应用容器引擎，它基于go语言开发，并遵从Apache2.0开源协议。使用Docker可以让开发者封装他们的应用以及依赖包到一个可移植的容器中，然后发布到任意的Linux机器上，也可以实现虚拟化。Docker容器完全使用沙箱机制，相互之间不会有任何接口，这保证了容器之间的安全性。  

**1. Docker的引擎介绍**

  Docker Engine（Docker引擎）是Docker的核心部分，使用的是客户端-服务器（C/S）架构模式，其主要组成部分如下图所示。
![alt](/article_img/docker/1.png)
  从上图可以看出，Docker Engine中包含了三个核心组件（docker CLI、REST API和docker daemon），这三个组件的具体说明如下：  
  ①docker CLI（command line interface）：表示Docker命令行接口，开发者可以在命令行中使用Docker相关指令与Docker守护进程进行交互，从而管理诸如image（镜像）、container（容器）、network（网络）和data volumes（数据卷）等实体。  
  ②REST API：表示应用程序API接口，开发者通过该API接口可以与Docker的守护进程进行交互，从而指示后台进行相关操作。  
  ③docker daemon：表示Docker的服务端组件，他是Docker架构中运行在后台的一个守护进程，可以接收并处理来自命令行接口及API接口的指令，然后进行相应的后台操作。  
  对于开发者而言，既可以使用编写好的脚本文件通过REST API来实现与Docker进程交互，又可以直接使用Docker相关指令通过命令行接口来与Docker进程交互，而其他一些Docker应用则是通过底层的API和CLI进行交互的。

**2. Docker的架构介绍**

  了解了Docker内部引擎及作用后，我们还需要通过Docker的具体架构，来了解Docker的整个运行流程。接下来借助Docker官网的架构图来对Docker架构进行详细说明，如下图所示。
![alt](/article_img/docker/2.jpg)
  从图中可以看出，Docker架构主要包括Client、DOCKER_HOST和Register三部分，关于这三部分的具体说明如下。  
&emsp;&emsp;**（1）Client（客户端）**  
  Client即Docker客户端，也就是上一小节Docker Engine中介绍的docker CLI。开发者通过这个客户端使用Docker的相关指令与Docker守护进程进行交互，从而进行Docker镜像的创建、拉取和运行等操作。  
&emsp;&emsp;**（2）DOCKER_HOST（Docker主机）**  
  DOCKER_HOST即Docker内部引擎运行的主机，主要指Docker daemon（Docker守护进程）。可以通过Docker守护进程与客户端还有Docker的镜像仓库Registry进行交互，从而管理Images（镜像）和Containers（容器）等。  
&emsp;&emsp;**（3）Registry（注册中心）**  
  Registry即Docker注册中心，实质就是Docker镜像仓库，默认使用的是Docker官方远程注册中心Docker Hub，也可以使用开发者搭建的本地仓库。Registry中包含了大量的镜像，这些镜像可以是官网基础镜像，也可以是其他开发者上传的镜像。  
  我们在实际使用Docker时，除了会涉及到图中的三个主要部分外，还会涉及到很多Docker Objects（Docker对象），例如Images（镜像）、Containers（容器）、Networks（网络）、Volumes（数据卷）、Plugins（插件）等。其中常用的两个对象Image和Containers的说明如下。  
  ①Images（镜像）  
  Docker 镜像就是一个只读的模板，包含了一些创建Docker容器的操作指令。通常情况下，一个Docker镜像是基于另一个基础镜像创建的，并且新创建的镜像会额外包含一些功能配置。例如：开发者可以依赖于一个Ubuntu的基础镜像创建一个新镜像，并可以在新镜像中安装Apache等软件或其它应用程序。  
  ②Containers（容器）  
  Docker容器属于镜像的一个可运行实例（镜像与容器的关系其实与Java中的类与对象相似），开发者可以通过API接口或者CLI命令行接口来创建、运行、停止、移动、删除一个容器，也可以将一个容器连接到一个或多个网络中，将数据存储与容器进行关联。



, 2018-12-03, null, 默认分类, 虚拟化容器,Docker,运行机制, true, null, 26, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [10, Docker常用客户端指令介绍,   在使用Docker之前，首先会为对应的项目编写Dockerfile镜像构建文件，然后通过Docker的相关指令进行镜像构建，完成镜像的构建后，就可以使用这些项目镜像进行启动测试了。所以要想知道如何使用Docker来执行这些Dockerfile镜像构建文件，还需要学习Docker客户端的常用指令，本篇文章将对Docker客户端的常用指令进行详细讲解。  

**1.列出镜像**  
  通过docker images指令可以查看本地镜像列表中已有的镜像，具体使用方式如下。
```js
$ docker images
```  
  执行上述指令后，系统会将所有本地镜像都展示出来，如下图所示。
![alt](/article_img/docker/3.png)
  从图中可以看出，系统终端将本地镜像列表中的3个镜像分5列进行了展示，每一列的具体含义如下。  
  ●REPOSITORY：镜像名称。  
  ●TAG：镜像的参数，类似于版本号，默认是latest。  
  ●IMAGE ID：镜像ID，是唯一值。此处看到的是一个长度为12的字符串，实际上它是64位完整镜像ID的缩写形式。  
  ●CREATED：距今创建镜像的时间。  
  ●SIZE：镜像大小。    

**2.搜索镜像**  
  想知道在Docker Hub中包含了哪些镜像，除了可以登录Docker Hub，在官网中心进行查看外，还可以直接在Docker客户端进行查询。例如想要查询Ubuntu镜像，可以使用如下指令。
```js
$ docker search ubuntu
```  
  执行上述指令后，系统终端就会将搜索到的有关Ubuntu的镜像展示出来，如下图所示。
![alt](/article_img/docker/4.png)
  从图所示的结果可以看出，系统终端分5列将搜索到的Ubuntu相关镜像都列举出来了，这5列的具体含义如下。  
  ●NAME：表示镜像的名称，这里有两种格式的名称，其中不带有“/”的表示官方镜像，而带有“/”的表示其他用户的公开镜像。公开镜像“/”前面是用户在Docker Hub上的用户名（唯一），后面是对应的镜像名；官方镜像与用户镜像，除了从镜像名称上可以区分外，还可以通过第4列的OFFICIAL声明中看出（该列下内容为OK表示官方镜像）。  
  ●DESCRIPTION：表示镜像的描述，这里只显示了一小部分。  
  ●STARS：表示该镜像的收藏数，用户可以在Docker Hub上对镜像进行收藏，一般可以通过该数字反应出该镜像的受欢迎程度。  
  ●OFFICIAL：表示是否为官方镜像。  
  ●AUTOMATED：表示是否自动构建镜像。例如，用户可以将自己的Docker Hub绑定到如Github上，当代码提交更新后，可以自动构建镜像。   
 
**3.拉取镜像**  
  通过docker pull指令可以拉取仓库镜像到本地（默认都是拉取Docker Hub仓库镜像，也可以指定“IP+端口”拉取某个Docker机器上的私有仓库镜像），具体使用方式如下。
```js
$ docker pull ubuntu
```  
  执行上述指令后，Docker会自动从Docker Hub上下载最新版本的Ubuntu到本地，当然也可以使用以下指令拉取指定版本的镜像到本地，具体指令如下。
```js
$ docker pull ubuntu:14.04
```  
**4.构建镜像**  
  除了可以通过docker pull指令从仓库拉取镜像外，还可以通过docker build指令构建Docker镜像，通常情况下都是通过Dockerfile文件来构建镜像的。  
  这里假设linux系统home目录下/shitou/workspace/dockerspace文件夹中编写有对应的Dockerfile文件，则构建镜像直立示例如下所示。 
```js
$ docker build -t hellodocker3 /home/shitou/workspace/dockerspace/.
```
**5.删除镜像**  
  当本地存放过多不需要的镜像时，可以通过docker rmi指令将其删除。在删除镜像时，需要指定镜像名称或镜像ID。删除镜像的使用方式如下。
```js
$ docker rmi -f hellodocker2 hellodocker3
```  
  上述指令中，docker rmi表示删除镜像，-f表示进行强制删除，而hellodocker2和hellodocker3分别表示需要删除的镜像名称，这里同时删除两个镜像。除了根据名称删除镜像外，还也可以根据镜像ID来删除镜像，只是这里如果指定了删除ID为23c617a866d4的镜像后，会同时删除hellodocker、hellodocker2和hellodocker3三个镜像。  
  需要特别强调的是，在进行镜像删除操作时，如果是通过镜像ID进行镜像删除，那么由该镜像创建的容器必须提前删除或停止。另外，在通过镜像名称操作镜像时，如果出现镜像重名的情况，必须在镜像名称后面指定镜像标签tag参数来确保唯一性。

**6.创建并启动容器**  
  Docker镜像主要用于创建容器，可以使用docker run指令创建并启动容器，具体使用方式如下。
```js
$ docker run -d -p 5000:80 --name test hellodocker
```  
  上述创建并启动容器的指令略微复杂，具体分析如下。  
  ●docker run：表示创建并启动一个容器，而后面的hellodocker就表示要启动运行的镜像名称；  
  ●-d：表示容器启动时在后台运行；  
  ●-p 5000:80：表示将容器内暴露的80端口映射到宿主机指定的5000端口，也可以将-p 5000:80更改为-P来映射主机的随机端口（注意p字母的大小写）；  
  ●--name test：表示为创建后的容器指定名称为test，如果没有该参数配置，则生成的容器会设置一个随机名称。  
  docker run命令是Docker操作中较为复杂的一个，它可以携带多个参数和参数，我们可以通过docker run --help指令进行查看，其中有些参数如-e、-v和-w等都可以在Dockerfile文件中预先声明。 
 
**7.列出容器**  
  生成容器后，可以通过docker ps指令查看当前运行的所有容器，具体使用方式如下。
```js
$ docker ps
```  
  执行上述命令后，会将所有当前运行的容器都展示出来，具体如下图所示。
![alt](/article_img/docker/5.png)
  从图中可以看出，系统终端通过7列对当前的正在运行的一个容器进行了展示，图中每一列的具体含义如下。  
  ●CONTAINER ID：表示生成的容器ID；  
  ●IMAGE：表示生成该容器的镜像名称；  
  ●COMMAND：表示启动容器时运行的命令，Docker要求在启动容器时必须运行一个命令；  
  ●CREATED：表示容器创建的时间；  
  ●STATUS：表示容器运行状态，例如Up表示运行中，Exited表示已停止；  
  ●PORTS：表示容器内部暴露的端口映射到主机的端口；  
  ●NAMES：表示生成容器的名称，由Docker引擎自动生成，可以像上述示例中使用--name参数指定生成容器的名称。  
  另外，docker ps指令运行过程中可以指定多个参数，还可以通过docker ps --help指令对ps指令的其他信息进行查看。

**8.删除容器**  
  当不需要使用容器时，则可以使用docker rm指令删除已停止的容器，具体使用方式如下。
```js
$ docker rm f0c9a8b6e8c5
```  
  需要注意的是，上述指令只能删除已经停止运行的容器，而不能删除正在运行的容器。如果想要删除正在运行的容器，则需要添加-f参数强制删除，具体使用方式如下。
```js
$ docker rm -f f0c9a8b6e8c5
```  
  当需要删除的容器过多时，如果还一个个的删除就略显麻烦了，此时可以通过如下指令将全部容器删除。
```js
$ docker rm -f $(docker ps -aq)
```  
  上述指令中，首先会通过$(docker ps -aq)获取所有容器的ID，然后通过docker rm -f指令进行强制删除。如果开发者有自己特殊的删除需求，可以根据前面docker ps指令进行组装来获取需要删除的容器ID。  
  Docker提供的操作指令远不止这些，这里就不一一列举了，想要了解更多Docker的操作指令，可以通过docker --help指令进行查看。


, 2018-12-05, null, 默认分类, Docker,客户端指令, true, null, 21, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [11, Docker数据管理介绍,   当我们对容器进行相关操作时，产生的一系列数据都会存储在容器中，而Docker内部又是如果管理这些数据的呢？本篇文章将针对Docker数据管理的一些知识进行介绍。
  
**1. Docker数据存储机制**  
  使用Docker时，我们操作的都是镜像和由镜像生成的容器，所以想要更好的了解Docker内部的数据存储机制，就必须从镜像、容器与数据存储的关系出发。  
  Docker镜像是通过读取Dockerfile文件中的指令构建的，Dockerfile中的每条指令都会创建一个镜像层，并且每层都是只读的，这一系列的镜像层就构成了Docker镜像。接下来以一个Dockerfile文件为例进行说明，具体如下列代码示例所示。
```js
 1	FROM ubuntu:16.04
 2	COPY . /app
 3	RUN make /app
 4	CMD python /app/app.py
```  
   上述文件示例中的Dockerfile包含了4条指令，每条指令都会创建一个镜像层，其中每一层与前一层都有所不同，并且是层层叠加的。通过镜像构建容器时，会在镜像层上增加一个容器层（即可写层），所有对容器的更改都会写入容器层，这也是Docker默认的数据存储方式。  
  下面通过一个效果图进行说明，具体如下图所示。
![alt](/article_img/docker/6.png)
  从图中可以看出，Docker容器和镜像之间的主要区别是顶部的容器层，而所有对容器中数据的添加、修改等操作都会被存储在容器层中。当容器被删除时，容器层也会被删除，其中存储的数据会被一同删除，而下面的镜像层却保持不变。  
  由于所有的容器都是通过镜像构建的，所以每个容器都有各自的容器层，对于容器数据的更改就会保存在各自的容器层中。也就是说，由同一个镜像构建的多个容器，它们会拥有相同的底部镜像层，而拥有不同的容器层，多个容器可以访问相同的镜像层，并且有自己的独立数据状态。具体说明如下图所示。 
![alt](/article_img/docker/7.png)
  从图中可以看出，基于同一个镜像构建的多个容器可以共享该镜像层，但是多个容器想要共享相同的数据，就需要将这些数据存储到容器之外的地方，而这种方式就是下一节要提到的Docker volume数据外部挂载机制。  

**2. Docker数据存储方式**    
  在默认情况下，Docker中的数据都是存放在容器层的，但是这样存储数据却有较多的缺陷，具体表现如下。    
  ●当容器不再运行时，容器中的数据无法持久化保存，如果另一个进程需要这些数据，那么将很难从容器中获取数据；  
  ●容器层与正在运行的主机紧密耦合，不能轻易地移动数据；  
  ●容器层需要一个存储驱动程序来管理文件系统，存储驱动程序提供了一个使用Linux内核的联合文件系统，这种额外的抽象化降低了性能。  
  基于上述种种原因，多数情况下Docker数据管理都不会直接将数据写入容器层，而是使用另一种叫做Docker volume数据外部挂载的机制进行数据管理。  
  针对Docker volume数据外部挂载机制，Docker提供了三种不同的方式将数据从容器映射到Docker宿主机，他们分别为：volumes（数据卷）、bind mounts（绑定挂载）和tmpfs mounts（tmpfs挂载）。这三种数据管理方式的具体选择，需要结合实际情况进行考虑，其中的volumes数据卷是最常用也是官方推荐的数据管理方式。无论选择使用哪种数据管理方式，数据在容器内看起来都一样的，而在容器外则会被被挂载到文件系统中的某个目录或文件中。    
  下面通过一张图来展示数据卷、绑定挂载和tmpfs挂载之间的差异，如下图所示。  
![alt](/article_img/docker/8.png)
  从图中可以看出，Docker提供的三种数据管理方式略有不同，具体分析如下。  
  ●volumes：存储在主机文件系统中（在Linux系统下是存在于/var/lib/Docker/volumes/目录），并由Docker管理，非Docker进程无法修改文件系统的这个部分。  
  ●bind mounts：可以存储在主机系统的任意位置，甚至可能是重要的系统文件或目录，在Docker主机或容器上的非Docker进程可以对他们进行任意修改。  
  ●tmpfs mounts：只存储在主机系统的内存中，并没有写入到主机的文件系统中。


, 2018-12-07, 2021-05-19, 默认分类, Docker,数据管理, true, null, 19, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [6, JDK 8——Lambda表达式介绍,   Lambda表达式是JDK 8中一个重要的新特性，它使用一个清晰简洁的表达式来表达一个接口，同时Lambda表达式也简化了对集合以及数组数据的遍历、过滤和提取等操作。下面，本篇文章就对Lambda表达式进行简要介绍，并进行演示说明。

**1. Lambda表达式入门**  

  匿名内部类存在的一个问题是，如果匿名内部类的实现非常简单，例如只包含一个抽象方法的接口，那么匿名内部类的语法仍然显得比较冗余。为此，JDK 8中新增了一个特性Lambda表达式，这种表达式只针对有一个抽象方法的接口实现，以简洁的表达式形式实现接口功能来作为方法参数。  
  一个Lambda表达式由三个部分组成，分别为参数列表、“->”和表达式主体，其语法格式如下：
```js
 ([数据类型 参数名,数据类型 参数名,...]) -> {表达式主体}
```  
  从上述语法格式上看，Lambda表达式的书写非常简单，下面针对Lambda表达式的组成部分进行简单介绍，具体如下：  
  （1）([数据类型 参数名,数据类型 参数名,...])：用来向表达式主体传递接口方法需要的参数，多个参数名中间必须用英文逗号“,”进行分隔；在编写Lambda表达式时，可以省略参数的数据类型，后面的表达式主体会自动进行校对和匹配；同时，如果只有一个参数，则可以省略括号“()”。  
  （2）->：表示Lambda表达式箭牌，用来指定参数数据指向，不能省略，且必须用英文横线和大于号书写。  
  （3）{表达式主体}：由单个表达式或语句块组成的主体，本质就是接口中抽象方法的具体实现，如果表达式主体只有一条语句，那么可以省略包含主体的大括号；另外，在Lambda表达式主体中允许有返回值，当只有一条return语句时，也可以省略return关键字。  
  了解了Lambda表达式的语法后，接下来编写一个示例文件对Lambda表达式的基本使用进行介绍，具体代码如下所示。
```js
 1	// 定义动物类接口
 2	interface Animal { 
 3		void shout(); // 定义方法shout()
 4	}
 5	public class Example22 {
 6		public static void main(String[] args) {
 7	       String name = "小花"; 
 8	       // 1、匿名内部类作为参数传递给animalShout()方法
 9		  animalShout(new Animal() { 
 10				 public void shout() { 
 11				    System.out.println("匿名内部类输出："+name+"喵喵...");
 12				}
 13		  });
 14		  // 2、使用Lambda表达式作为参数传递给animalShout()方法
 15	       animalShout(()-> System.out.println("Lambda表达式输出："
 16	                                                   +name+"喵喵..."));
 17		}
 18	    // 创建一个animalShout()静态方法，接收接口类型的参数
 19		public static void animalShout(Animal an) {
 20			an.shout();  
 21		}
 22	}
```  
  运行结果下图所示。
![alt](/article_img/lambda/1.jpg)
  上述代码示例中，先定义了只有一个抽象方法的接口Animal，然后分别使用匿名内部类和Lambda表达式的方式实现了接口方法。从图中可以看出，使用匿名内部类和Lambda表达式都能实现接口中方法，但很显然使用Lambda表达式更加简洁和清晰。, 2018-11-27, null, 默认分类, 2018,Lambda表达式, true, null, 17, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [7, 函数式接口, &emsp;&emsp;虽然Lambda表达式可以实现匿名内部类的功能，但在使用时却有一个局限，即接口中有且只有一个抽象方法时才能使用Lamdba表达式代替匿名内部类。这是因为Lamdba表达式是基于函数式接口实现的，所谓函数式接口是指有且仅有一个抽象方法的接口，Lambda表达式就是Java中函数式编程的体现，只有确保接口中有且仅有一个抽象方法，Lambda表达式才能顺利地推导出所实现的这个接口中的方法。  
&emsp;&emsp;在JDK 8中，专门为函数式接口引入了一个@FunctionalInterface注解，该注解只是显示的标注了接口是一个函数式接口，并强制编辑器进行更严格的检查，确保该接口是函数式接口，如果不是函数式接口，那么编译器就会报错，而对程序运行并没有实质上的影响。  
&emsp;&emsp;接下来通过一个案例来演示函数式接口的定义与使用，示例代码如下所示。
```js
 1	// 定义无参、无返回值的函数式接口
 2	@FunctionalInterface
 3	interface Animal {
 4		void shout();
 5	}
 6	// 定义有参、有返回值的函数式接口
 7	interface Calculate {
 8		int sum(int a, int b);
 9	}
 10	public class Example23 {
 11		public static void main(String[] args) {
 12		   // 分别两个函数式接口进行测试
 13		   animalShout(() -> System.out.println("无参、无返回值的函数式接口调用"));
 14		   showSum(10, 20, (x, y) -> x + y);
 15		}
 16		// 创建一个动物叫的方法，并传入接口对象Animal作为参数
 17		private static void animalShout(Animal animal) {
 18			animal.shout();
 19		}
 20		// 创建一个求和的方法，并传入两个int类型以及接口Calculate类型的参数
 21		private static void showSum(int x, int y, Calculate calculate) {
 22		   System.out.println(x + "+" + y + "的和为：" + calculate.sum(x, y));
 23		}
 24	}
```  
&emsp;&emsp;运行结果如下图所示。

![alt](/article_img/lambda/2.jpg)
&emsp;&emsp;上述代码示例中，先定义了两个函数式接口Animal和Calculate，然后在测试类中分别编写了两个静态方法，并将这两个函数式接口以参数的形式传入，最后在main()方法中分别调用这两个静态方法，并将所需要的函数式接口参数以Lambda表达式的形式传入。从图中可以看出，程序中函数式接口的定义和使用完全正确。
, 2018-12-01, null, 默认分类, 接口,函数式接口, true, null, 12, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20003} created. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20003} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20003} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20003} executed. 0.6401 millis. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20003, rs-50003} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20003, rs-50003} Header: [count(0)]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20003, rs-50003} Result: [12]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20003, rs-50003} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20003} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20004} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20004} Parameters : [5]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20004} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20004} executed. 0.5981 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 108, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20004} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20005} created. update t_statistic set hits = hits+1 where article_id=?;
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20005} Parameters : [4]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20005} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20005} executed. 5.6649 millis. update t_statistic set hits = hits+1 where article_id=?;
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20005} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20006} created. select * from t_comment where article_id=?
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20006} Parameters : [4]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20006} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20006} executed. 2.9412 millis. select * from t_comment where article_id=?
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20006, rs-50005} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20006, rs-50005} Header: [id, article_id, created, ip, c_content, status, author]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20006, rs-50005} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20006} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20007} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail
    FROM
    t_article
    WHERE
	t_article.id = ?
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20007} Parameters : [4]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20007} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20007} executed. 1.0439 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail
    FROM
    t_article
    WHERE
	t_article.id = ?
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20007, rs-50006} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20007, rs-50006} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20007, rs-50006} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20007, rs-50006} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20007} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20008} created. update t_statistic set hits = hits+1 where article_id=?;
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20008} Parameters : [6]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20008} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20008} executed. 3.4014 millis. update t_statistic set hits = hits+1 where article_id=?;
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20008} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20009} created. select * from t_comment where article_id=?
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20009} Parameters : [6]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20009} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20009} executed. 0.6416 millis. select * from t_comment where article_id=?
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20009, rs-50007} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20009, rs-50007} Header: [id, article_id, created, ip, c_content, status, author]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20009, rs-50007} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20009} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20010} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail
    FROM
    t_article
    WHERE
	t_article.id = ?
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20010} Parameters : [6]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20010} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20010} executed. 0.4979 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail
    FROM
    t_article
    WHERE
	t_article.id = ?
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20010, rs-50008} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20010, rs-50008} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20010, rs-50008} Result: [6, JDK 8——Lambda表达式介绍,   Lambda表达式是JDK 8中一个重要的新特性，它使用一个清晰简洁的表达式来表达一个接口，同时Lambda表达式也简化了对集合以及数组数据的遍历、过滤和提取等操作。下面，本篇文章就对Lambda表达式进行简要介绍，并进行演示说明。

**1. Lambda表达式入门**  

  匿名内部类存在的一个问题是，如果匿名内部类的实现非常简单，例如只包含一个抽象方法的接口，那么匿名内部类的语法仍然显得比较冗余。为此，JDK 8中新增了一个特性Lambda表达式，这种表达式只针对有一个抽象方法的接口实现，以简洁的表达式形式实现接口功能来作为方法参数。  
  一个Lambda表达式由三个部分组成，分别为参数列表、“->”和表达式主体，其语法格式如下：
```js
 ([数据类型 参数名,数据类型 参数名,...]) -> {表达式主体}
```  
  从上述语法格式上看，Lambda表达式的书写非常简单，下面针对Lambda表达式的组成部分进行简单介绍，具体如下：  
  （1）([数据类型 参数名,数据类型 参数名,...])：用来向表达式主体传递接口方法需要的参数，多个参数名中间必须用英文逗号“,”进行分隔；在编写Lambda表达式时，可以省略参数的数据类型，后面的表达式主体会自动进行校对和匹配；同时，如果只有一个参数，则可以省略括号“()”。  
  （2）->：表示Lambda表达式箭牌，用来指定参数数据指向，不能省略，且必须用英文横线和大于号书写。  
  （3）{表达式主体}：由单个表达式或语句块组成的主体，本质就是接口中抽象方法的具体实现，如果表达式主体只有一条语句，那么可以省略包含主体的大括号；另外，在Lambda表达式主体中允许有返回值，当只有一条return语句时，也可以省略return关键字。  
  了解了Lambda表达式的语法后，接下来编写一个示例文件对Lambda表达式的基本使用进行介绍，具体代码如下所示。
```js
 1	// 定义动物类接口
 2	interface Animal { 
 3		void shout(); // 定义方法shout()
 4	}
 5	public class Example22 {
 6		public static void main(String[] args) {
 7	       String name = "小花"; 
 8	       // 1、匿名内部类作为参数传递给animalShout()方法
 9		  animalShout(new Animal() { 
 10				 public void shout() { 
 11				    System.out.println("匿名内部类输出："+name+"喵喵...");
 12				}
 13		  });
 14		  // 2、使用Lambda表达式作为参数传递给animalShout()方法
 15	       animalShout(()-> System.out.println("Lambda表达式输出："
 16	                                                   +name+"喵喵..."));
 17		}
 18	    // 创建一个animalShout()静态方法，接收接口类型的参数
 19		public static void animalShout(Animal an) {
 20			an.shout();  
 21		}
 22	}
```  
  运行结果下图所示。
![alt](/article_img/lambda/1.jpg)
  上述代码示例中，先定义了只有一个抽象方法的接口Animal，然后分别使用匿名内部类和Lambda表达式的方式实现了接口方法。从图中可以看出，使用匿名内部类和Lambda表达式都能实现接口中方法，但很显然使用Lambda表达式更加简洁和清晰。, 2018-11-27, null, 默认分类, 2018,Lambda表达式, true, null]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20010, rs-50008} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20010} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} connected
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} executed. 10.8451 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 108, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [12, Spring Boot 2 权威发布,   如果这两天登录 [https://start.spring.io/ ](https://start.spring.io/ )就会发现，Spring Boot 默认版本已经升到了 2.1.0。这是因为 Spring Boot 刚刚发布了 2.1.0 版本，我们来看下 Spring Boot 2 发布以来第一个子版本都发布了哪些内容？  

**2.1 中的新特性**     
  ●将spring-boot-starter-oauth2-oidc-client重命名为spring-boot-starter-oauth2-client命名更简洁  
  ●添加 OAuth2 资源服务 starter，OAuth2 一个用于认证的组件  
  ●支持 ConditionalOnBean 和 ConditionalOnMissingBean 下的参数化容器  
  ●自动配置 applicationTaskExecutor bean 的延迟加载来避免不必要的日志记录  
  ●将 DatabaseDriver＃SAP 重命名为 DatabaseDriver  
  ●跳过重启器不仅适用于 JUnit4，也适用于 JUnit5  
  ●在 Jest HealthIndicator 中使用集群端点  
  ●当 DevTools 禁用重启时添加日志输出  
  ●添加注解：@ConditionalOnMissingServletFilter提高 Servlet Filters 的自动装配。
  
**2.1 中的组件升级**  
  ●升级 Hibernate 5.3，Hibernate 的支持升级到了 5.3  
  ●升级 Tomcat 9 ，支持最新的 tomcat 9  
  ●支持 Java 11，Java 现在更新越来越快，Spring 快赶不上了    
  ●升级 Thymeleaf Extras Springsecurity 到 3.0.4.RELEASE ，thymeleaf-extras-springsecurity 是 Thymeleaf 提供集成 Spring Security 的组件  
  ●升级 Joda Time 2.10.1，Joda-Time， 面向 Java 应用程序的日期/时间库的替代选择，Joda-Time 令时间和日期值变得易于管理、操作和理解。  
  ●升级 Lettuce 5.1.2.RELEASE ，Lettuce 前面说过，传说中 Redis 最快的客户端。  
  ●升级 Reactor Californium-SR2 ，Californium 是物联网云服务的 Java COAP 实现。因此，它更专注的是可扩展性和可用性而不是像嵌入式设备那样关注资源效率。不过，Californium 也适合嵌入式的 JVM。  
  ●升级 Maven Failsafe Plugin 2.22.1 ，Maven 中的测试插件。  
  ●升级 Flyway 5.2.1 ， Flyway是一款开源的数据库版本管理工具  
  ●升级 Aspectj 1.9.2 ，AspectJ 是 Java 中流行的 AOP（Aspect-oriented Programming）编程扩展框架，是 Eclipse 托管给 Apache 基金会的一个开源项目。  
  ●升级 Mysql 8.0.13 ，Mysql 支持到 8。  
  ●...  
  更多的详细内容可以参考这里：[Spring Boot 2.1 Release Notes](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.1-Release-Notes)
, 2018-12-12, 2021-05-21, 默认分类, Spring Boot 2, true, null, 62, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [8, JDK 8——聚合操作, &emsp;&emsp;在Java8版本中，JDK包含许多聚合操作（如平均值，总和，最小，最大，和计数），返回一个计算流stream的聚合结果。这些聚合操作被称为聚合操作。JDK除返回单个值的聚合操作外，还有很多聚合操作返回一个collection集合实例。很多的reduce操作执行特定的任务，如求平均值或按类别分组元素。  

**1. 聚合操作简介**

  在开发中，多数情况下会涉及到对集合、数组中元素的操作，在JDK 8之前都是通过普通的循环遍历出每一个元素，然后还会穿插一些if条件语句选择性的对元素进行查找、过滤、修改等操作，这种原始的操作方法虽然可行，但是代码量较大并且执行效率较低。  
  为此，JDK 8中新增了一个Stream接口，该接口可以将集合、数组的中的元素转换为Stream流的形式，并结合Lambda表达式的优势来进一步简化集合、数组中元素的查找、过滤、转换等操作，这一新功能就是JDK 8中的聚合操作。  
  在程序中，使用聚合操作没有绝对的语法规范，根据实际操作流程，主要可以分为以下3个步骤：  
  （1）将原始集合或者数组对象转换为Stream流对象；  
  （2）对Stream流对象中的元素进行一系列的过滤、查找等中间操作（Intermediate Operations），然后仍然返回一个Stream流对象；  
  （3）对Stream流进行遍历、统计、收集等终结操作（Terminal Operation），获取想要的结果。  
  接下来，就根据上面聚合操作的3个步骤，通过一个案例来演示聚合操作的基本用法，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example31 {
 4		public static void main(String[] args) {
 5	          // 创建一个List集合对象
 6			List<String> list = new ArrayList<>(); 
 7			list.add("张三");
 8			list.add("李四");
 9			list.add("张小明");
 10			list.add("张阳");
 11			// 1、创建一个Stream流对象
 12			Stream<String> stream = list.stream();
 13			// 2、对Stream流中的元素分别进行过滤、截取操作
 14		       Stream<String> stream2 = stream.filter(i -> i.startsWith("张"));
 15			Stream<String> stream3 = stream2.limit(2);
 16			// 3、对Stream流中的元素进行终结操作，进行遍历输出
 17			stream3.forEach(j -> System.out.println(j));
 18			System.out.println("=======");
 19	         // 通过链式表达式的形式完成聚合操作
 20			list.stream().filter(i -> i.startsWith("张"))
 21						 .limit(2)
 22						 .forEach(j -> System.out.println(j));
 23		}
 24	}
``` 
   运行结果如下图所示。
![alt](/article_img/lambda/3.jpg)
  上述示例代码中，先创建了一个List集合，然后根据聚合操作的3个步骤实现了集合对象的聚合操作，对集合中的元素使用Stream流的形式进行过滤（filter）、截取（limit），并进行遍历输出。其中第12~17行代码分步骤详细展示了聚合操作，而第20~22行代码是使用了链式表达式（调用有返回值的方法时不获取返回值而是直接再调用另一个方法）实现了聚合操作，该表达式的语法格式更简洁、高效，这种链式调用也被称为操作管道流。

**2. 创建Stream流对象**  
  在上一小节中，介绍了聚合操作的主要使用步骤，其中首要解决的问题就是创建Stream流对象。聚合操作针对的就是可迭代数据进行的操作，如集合、数组等，所以创建Stream流对象其实就是将集合、数组等通过一些方法转换为Stream流对象。  
  在Java中，集合对象有对应的集合类，可以通过集合类提供的静态方法创建Stream流对象，而数组数据却没有对应的数组类，所以必须通过其他方法创建Stream流对象。针对不同的源数据，Java提供了多种创建Stream流对象的方式，分别如下：  
  （1）所有的Collections集合都可以使用stream()静态方法获取Stream流对象；  
  （2）Stream接口的of()静态方法可以获取基本类型包装类数组、引用类型数组和单个元素的Stream流对象；  
  （3）Arrays数组工具类的stream()静态方法也可以获取数组元素的Stream流对象。  
  接下来，通过一个案例来学习聚合操作中如何创建Stream流对象，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example32 {
 4		public static void main(String[] args) {
 5	          // 创建一个数组
 6			Integer[] array = { 9, 8, 3, 5, 2 };       
 7	          // 将数组转换为List集合
 8			List<Integer> list = Arrays.asList(array); 
 9			// 1、使用集合对象的stream()静态方法创建Stream流对象
 10			Stream<Integer> stream = list.stream();
 11			stream.forEach(i -> System.out.print(i+" "));
 12			System.out.println();
 13			// 2、使用Stream接口的of()静态方法创建Stream流对象
 14			Stream<Integer> stream2 = Stream.of(array);
 15			stream2.forEach(i -> System.out.print(i+" "));
 16			System.out.println();
 17			// 3、使用Arrays数组工具类的stream()静态方法创建Stream流对象
 18			Stream<Integer> stream3 = Arrays.stream(array);
 19			stream3.forEach(i -> System.out.print(i+" "));
 20		}
 21	}
```  
  运行结果如下图所示。
![alt](/article_img/lambda/4.jpg)
  上述示例代码中，先创建了一个数组和一个集合，然后通过三种方式实现了Stream流对象的创建，并通过Stream流对象的forEach()方法结合Lambda表达式完成了集合和数组中元素的遍历。  

**小提示：**  
  在JDK 8中，只针对单列集合Collections接口对象提供了stream()静态方法获取Stream流对象，并未对Map集合提供相关方法获取Stream流对象，所以想要用Map集合创建Stream流对象必须先通过Map集合的keySet()、values()、entrySet()等方法将Map集合转换为单列Set集合，然后再使用单列集合的stream()静态方法获取对应键、值集合的Stream流对象。

, 2018-12-02, null, 默认分类, JDK 8,聚合操作, true, null, 34, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [9, 虚拟化容器技术——Docker运行机制介绍,   Docker是一个开源的应用容器引擎，它基于go语言开发，并遵从Apache2.0开源协议。使用Docker可以让开发者封装他们的应用以及依赖包到一个可移植的容器中，然后发布到任意的Linux机器上，也可以实现虚拟化。Docker容器完全使用沙箱机制，相互之间不会有任何接口，这保证了容器之间的安全性。  

**1. Docker的引擎介绍**

  Docker Engine（Docker引擎）是Docker的核心部分，使用的是客户端-服务器（C/S）架构模式，其主要组成部分如下图所示。
![alt](/article_img/docker/1.png)
  从上图可以看出，Docker Engine中包含了三个核心组件（docker CLI、REST API和docker daemon），这三个组件的具体说明如下：  
  ①docker CLI（command line interface）：表示Docker命令行接口，开发者可以在命令行中使用Docker相关指令与Docker守护进程进行交互，从而管理诸如image（镜像）、container（容器）、network（网络）和data volumes（数据卷）等实体。  
  ②REST API：表示应用程序API接口，开发者通过该API接口可以与Docker的守护进程进行交互，从而指示后台进行相关操作。  
  ③docker daemon：表示Docker的服务端组件，他是Docker架构中运行在后台的一个守护进程，可以接收并处理来自命令行接口及API接口的指令，然后进行相应的后台操作。  
  对于开发者而言，既可以使用编写好的脚本文件通过REST API来实现与Docker进程交互，又可以直接使用Docker相关指令通过命令行接口来与Docker进程交互，而其他一些Docker应用则是通过底层的API和CLI进行交互的。

**2. Docker的架构介绍**

  了解了Docker内部引擎及作用后，我们还需要通过Docker的具体架构，来了解Docker的整个运行流程。接下来借助Docker官网的架构图来对Docker架构进行详细说明，如下图所示。
![alt](/article_img/docker/2.jpg)
  从图中可以看出，Docker架构主要包括Client、DOCKER_HOST和Register三部分，关于这三部分的具体说明如下。  
&emsp;&emsp;**（1）Client（客户端）**  
  Client即Docker客户端，也就是上一小节Docker Engine中介绍的docker CLI。开发者通过这个客户端使用Docker的相关指令与Docker守护进程进行交互，从而进行Docker镜像的创建、拉取和运行等操作。  
&emsp;&emsp;**（2）DOCKER_HOST（Docker主机）**  
  DOCKER_HOST即Docker内部引擎运行的主机，主要指Docker daemon（Docker守护进程）。可以通过Docker守护进程与客户端还有Docker的镜像仓库Registry进行交互，从而管理Images（镜像）和Containers（容器）等。  
&emsp;&emsp;**（3）Registry（注册中心）**  
  Registry即Docker注册中心，实质就是Docker镜像仓库，默认使用的是Docker官方远程注册中心Docker Hub，也可以使用开发者搭建的本地仓库。Registry中包含了大量的镜像，这些镜像可以是官网基础镜像，也可以是其他开发者上传的镜像。  
  我们在实际使用Docker时，除了会涉及到图中的三个主要部分外，还会涉及到很多Docker Objects（Docker对象），例如Images（镜像）、Containers（容器）、Networks（网络）、Volumes（数据卷）、Plugins（插件）等。其中常用的两个对象Image和Containers的说明如下。  
  ①Images（镜像）  
  Docker 镜像就是一个只读的模板，包含了一些创建Docker容器的操作指令。通常情况下，一个Docker镜像是基于另一个基础镜像创建的，并且新创建的镜像会额外包含一些功能配置。例如：开发者可以依赖于一个Ubuntu的基础镜像创建一个新镜像，并可以在新镜像中安装Apache等软件或其它应用程序。  
  ②Containers（容器）  
  Docker容器属于镜像的一个可运行实例（镜像与容器的关系其实与Java中的类与对象相似），开发者可以通过API接口或者CLI命令行接口来创建、运行、停止、移动、删除一个容器，也可以将一个容器连接到一个或多个网络中，将数据存储与容器进行关联。



, 2018-12-03, null, 默认分类, 虚拟化容器,Docker,运行机制, true, null, 26, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [10, Docker常用客户端指令介绍,   在使用Docker之前，首先会为对应的项目编写Dockerfile镜像构建文件，然后通过Docker的相关指令进行镜像构建，完成镜像的构建后，就可以使用这些项目镜像进行启动测试了。所以要想知道如何使用Docker来执行这些Dockerfile镜像构建文件，还需要学习Docker客户端的常用指令，本篇文章将对Docker客户端的常用指令进行详细讲解。  

**1.列出镜像**  
  通过docker images指令可以查看本地镜像列表中已有的镜像，具体使用方式如下。
```js
$ docker images
```  
  执行上述指令后，系统会将所有本地镜像都展示出来，如下图所示。
![alt](/article_img/docker/3.png)
  从图中可以看出，系统终端将本地镜像列表中的3个镜像分5列进行了展示，每一列的具体含义如下。  
  ●REPOSITORY：镜像名称。  
  ●TAG：镜像的参数，类似于版本号，默认是latest。  
  ●IMAGE ID：镜像ID，是唯一值。此处看到的是一个长度为12的字符串，实际上它是64位完整镜像ID的缩写形式。  
  ●CREATED：距今创建镜像的时间。  
  ●SIZE：镜像大小。    

**2.搜索镜像**  
  想知道在Docker Hub中包含了哪些镜像，除了可以登录Docker Hub，在官网中心进行查看外，还可以直接在Docker客户端进行查询。例如想要查询Ubuntu镜像，可以使用如下指令。
```js
$ docker search ubuntu
```  
  执行上述指令后，系统终端就会将搜索到的有关Ubuntu的镜像展示出来，如下图所示。
![alt](/article_img/docker/4.png)
  从图所示的结果可以看出，系统终端分5列将搜索到的Ubuntu相关镜像都列举出来了，这5列的具体含义如下。  
  ●NAME：表示镜像的名称，这里有两种格式的名称，其中不带有“/”的表示官方镜像，而带有“/”的表示其他用户的公开镜像。公开镜像“/”前面是用户在Docker Hub上的用户名（唯一），后面是对应的镜像名；官方镜像与用户镜像，除了从镜像名称上可以区分外，还可以通过第4列的OFFICIAL声明中看出（该列下内容为OK表示官方镜像）。  
  ●DESCRIPTION：表示镜像的描述，这里只显示了一小部分。  
  ●STARS：表示该镜像的收藏数，用户可以在Docker Hub上对镜像进行收藏，一般可以通过该数字反应出该镜像的受欢迎程度。  
  ●OFFICIAL：表示是否为官方镜像。  
  ●AUTOMATED：表示是否自动构建镜像。例如，用户可以将自己的Docker Hub绑定到如Github上，当代码提交更新后，可以自动构建镜像。   
 
**3.拉取镜像**  
  通过docker pull指令可以拉取仓库镜像到本地（默认都是拉取Docker Hub仓库镜像，也可以指定“IP+端口”拉取某个Docker机器上的私有仓库镜像），具体使用方式如下。
```js
$ docker pull ubuntu
```  
  执行上述指令后，Docker会自动从Docker Hub上下载最新版本的Ubuntu到本地，当然也可以使用以下指令拉取指定版本的镜像到本地，具体指令如下。
```js
$ docker pull ubuntu:14.04
```  
**4.构建镜像**  
  除了可以通过docker pull指令从仓库拉取镜像外，还可以通过docker build指令构建Docker镜像，通常情况下都是通过Dockerfile文件来构建镜像的。  
  这里假设linux系统home目录下/shitou/workspace/dockerspace文件夹中编写有对应的Dockerfile文件，则构建镜像直立示例如下所示。 
```js
$ docker build -t hellodocker3 /home/shitou/workspace/dockerspace/.
```
**5.删除镜像**  
  当本地存放过多不需要的镜像时，可以通过docker rmi指令将其删除。在删除镜像时，需要指定镜像名称或镜像ID。删除镜像的使用方式如下。
```js
$ docker rmi -f hellodocker2 hellodocker3
```  
  上述指令中，docker rmi表示删除镜像，-f表示进行强制删除，而hellodocker2和hellodocker3分别表示需要删除的镜像名称，这里同时删除两个镜像。除了根据名称删除镜像外，还也可以根据镜像ID来删除镜像，只是这里如果指定了删除ID为23c617a866d4的镜像后，会同时删除hellodocker、hellodocker2和hellodocker3三个镜像。  
  需要特别强调的是，在进行镜像删除操作时，如果是通过镜像ID进行镜像删除，那么由该镜像创建的容器必须提前删除或停止。另外，在通过镜像名称操作镜像时，如果出现镜像重名的情况，必须在镜像名称后面指定镜像标签tag参数来确保唯一性。

**6.创建并启动容器**  
  Docker镜像主要用于创建容器，可以使用docker run指令创建并启动容器，具体使用方式如下。
```js
$ docker run -d -p 5000:80 --name test hellodocker
```  
  上述创建并启动容器的指令略微复杂，具体分析如下。  
  ●docker run：表示创建并启动一个容器，而后面的hellodocker就表示要启动运行的镜像名称；  
  ●-d：表示容器启动时在后台运行；  
  ●-p 5000:80：表示将容器内暴露的80端口映射到宿主机指定的5000端口，也可以将-p 5000:80更改为-P来映射主机的随机端口（注意p字母的大小写）；  
  ●--name test：表示为创建后的容器指定名称为test，如果没有该参数配置，则生成的容器会设置一个随机名称。  
  docker run命令是Docker操作中较为复杂的一个，它可以携带多个参数和参数，我们可以通过docker run --help指令进行查看，其中有些参数如-e、-v和-w等都可以在Dockerfile文件中预先声明。 
 
**7.列出容器**  
  生成容器后，可以通过docker ps指令查看当前运行的所有容器，具体使用方式如下。
```js
$ docker ps
```  
  执行上述命令后，会将所有当前运行的容器都展示出来，具体如下图所示。
![alt](/article_img/docker/5.png)
  从图中可以看出，系统终端通过7列对当前的正在运行的一个容器进行了展示，图中每一列的具体含义如下。  
  ●CONTAINER ID：表示生成的容器ID；  
  ●IMAGE：表示生成该容器的镜像名称；  
  ●COMMAND：表示启动容器时运行的命令，Docker要求在启动容器时必须运行一个命令；  
  ●CREATED：表示容器创建的时间；  
  ●STATUS：表示容器运行状态，例如Up表示运行中，Exited表示已停止；  
  ●PORTS：表示容器内部暴露的端口映射到主机的端口；  
  ●NAMES：表示生成容器的名称，由Docker引擎自动生成，可以像上述示例中使用--name参数指定生成容器的名称。  
  另外，docker ps指令运行过程中可以指定多个参数，还可以通过docker ps --help指令对ps指令的其他信息进行查看。

**8.删除容器**  
  当不需要使用容器时，则可以使用docker rm指令删除已停止的容器，具体使用方式如下。
```js
$ docker rm f0c9a8b6e8c5
```  
  需要注意的是，上述指令只能删除已经停止运行的容器，而不能删除正在运行的容器。如果想要删除正在运行的容器，则需要添加-f参数强制删除，具体使用方式如下。
```js
$ docker rm -f f0c9a8b6e8c5
```  
  当需要删除的容器过多时，如果还一个个的删除就略显麻烦了，此时可以通过如下指令将全部容器删除。
```js
$ docker rm -f $(docker ps -aq)
```  
  上述指令中，首先会通过$(docker ps -aq)获取所有容器的ID，然后通过docker rm -f指令进行强制删除。如果开发者有自己特殊的删除需求，可以根据前面docker ps指令进行组装来获取需要删除的容器ID。  
  Docker提供的操作指令远不止这些，这里就不一一列举了，想要了解更多Docker的操作指令，可以通过docker --help指令进行查看。


, 2018-12-05, null, 默认分类, Docker,客户端指令, true, null, 21, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [11, Docker数据管理介绍,   当我们对容器进行相关操作时，产生的一系列数据都会存储在容器中，而Docker内部又是如果管理这些数据的呢？本篇文章将针对Docker数据管理的一些知识进行介绍。
  
**1. Docker数据存储机制**  
  使用Docker时，我们操作的都是镜像和由镜像生成的容器，所以想要更好的了解Docker内部的数据存储机制，就必须从镜像、容器与数据存储的关系出发。  
  Docker镜像是通过读取Dockerfile文件中的指令构建的，Dockerfile中的每条指令都会创建一个镜像层，并且每层都是只读的，这一系列的镜像层就构成了Docker镜像。接下来以一个Dockerfile文件为例进行说明，具体如下列代码示例所示。
```js
 1	FROM ubuntu:16.04
 2	COPY . /app
 3	RUN make /app
 4	CMD python /app/app.py
```  
   上述文件示例中的Dockerfile包含了4条指令，每条指令都会创建一个镜像层，其中每一层与前一层都有所不同，并且是层层叠加的。通过镜像构建容器时，会在镜像层上增加一个容器层（即可写层），所有对容器的更改都会写入容器层，这也是Docker默认的数据存储方式。  
  下面通过一个效果图进行说明，具体如下图所示。
![alt](/article_img/docker/6.png)
  从图中可以看出，Docker容器和镜像之间的主要区别是顶部的容器层，而所有对容器中数据的添加、修改等操作都会被存储在容器层中。当容器被删除时，容器层也会被删除，其中存储的数据会被一同删除，而下面的镜像层却保持不变。  
  由于所有的容器都是通过镜像构建的，所以每个容器都有各自的容器层，对于容器数据的更改就会保存在各自的容器层中。也就是说，由同一个镜像构建的多个容器，它们会拥有相同的底部镜像层，而拥有不同的容器层，多个容器可以访问相同的镜像层，并且有自己的独立数据状态。具体说明如下图所示。 
![alt](/article_img/docker/7.png)
  从图中可以看出，基于同一个镜像构建的多个容器可以共享该镜像层，但是多个容器想要共享相同的数据，就需要将这些数据存储到容器之外的地方，而这种方式就是下一节要提到的Docker volume数据外部挂载机制。  

**2. Docker数据存储方式**    
  在默认情况下，Docker中的数据都是存放在容器层的，但是这样存储数据却有较多的缺陷，具体表现如下。    
  ●当容器不再运行时，容器中的数据无法持久化保存，如果另一个进程需要这些数据，那么将很难从容器中获取数据；  
  ●容器层与正在运行的主机紧密耦合，不能轻易地移动数据；  
  ●容器层需要一个存储驱动程序来管理文件系统，存储驱动程序提供了一个使用Linux内核的联合文件系统，这种额外的抽象化降低了性能。  
  基于上述种种原因，多数情况下Docker数据管理都不会直接将数据写入容器层，而是使用另一种叫做Docker volume数据外部挂载的机制进行数据管理。  
  针对Docker volume数据外部挂载机制，Docker提供了三种不同的方式将数据从容器映射到Docker宿主机，他们分别为：volumes（数据卷）、bind mounts（绑定挂载）和tmpfs mounts（tmpfs挂载）。这三种数据管理方式的具体选择，需要结合实际情况进行考虑，其中的volumes数据卷是最常用也是官方推荐的数据管理方式。无论选择使用哪种数据管理方式，数据在容器内看起来都一样的，而在容器外则会被被挂载到文件系统中的某个目录或文件中。    
  下面通过一张图来展示数据卷、绑定挂载和tmpfs挂载之间的差异，如下图所示。  
![alt](/article_img/docker/8.png)
  从图中可以看出，Docker提供的三种数据管理方式略有不同，具体分析如下。  
  ●volumes：存储在主机文件系统中（在Linux系统下是存在于/var/lib/Docker/volumes/目录），并由Docker管理，非Docker进程无法修改文件系统的这个部分。  
  ●bind mounts：可以存储在主机系统的任意位置，甚至可能是重要的系统文件或目录，在Docker主机或容器上的非Docker进程可以对他们进行任意修改。  
  ●tmpfs mounts：只存储在主机系统的内存中，并没有写入到主机的文件系统中。


, 2018-12-07, 2021-05-19, 默认分类, Docker,数据管理, true, null, 19, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [6, JDK 8——Lambda表达式介绍,   Lambda表达式是JDK 8中一个重要的新特性，它使用一个清晰简洁的表达式来表达一个接口，同时Lambda表达式也简化了对集合以及数组数据的遍历、过滤和提取等操作。下面，本篇文章就对Lambda表达式进行简要介绍，并进行演示说明。

**1. Lambda表达式入门**  

  匿名内部类存在的一个问题是，如果匿名内部类的实现非常简单，例如只包含一个抽象方法的接口，那么匿名内部类的语法仍然显得比较冗余。为此，JDK 8中新增了一个特性Lambda表达式，这种表达式只针对有一个抽象方法的接口实现，以简洁的表达式形式实现接口功能来作为方法参数。  
  一个Lambda表达式由三个部分组成，分别为参数列表、“->”和表达式主体，其语法格式如下：
```js
 ([数据类型 参数名,数据类型 参数名,...]) -> {表达式主体}
```  
  从上述语法格式上看，Lambda表达式的书写非常简单，下面针对Lambda表达式的组成部分进行简单介绍，具体如下：  
  （1）([数据类型 参数名,数据类型 参数名,...])：用来向表达式主体传递接口方法需要的参数，多个参数名中间必须用英文逗号“,”进行分隔；在编写Lambda表达式时，可以省略参数的数据类型，后面的表达式主体会自动进行校对和匹配；同时，如果只有一个参数，则可以省略括号“()”。  
  （2）->：表示Lambda表达式箭牌，用来指定参数数据指向，不能省略，且必须用英文横线和大于号书写。  
  （3）{表达式主体}：由单个表达式或语句块组成的主体，本质就是接口中抽象方法的具体实现，如果表达式主体只有一条语句，那么可以省略包含主体的大括号；另外，在Lambda表达式主体中允许有返回值，当只有一条return语句时，也可以省略return关键字。  
  了解了Lambda表达式的语法后，接下来编写一个示例文件对Lambda表达式的基本使用进行介绍，具体代码如下所示。
```js
 1	// 定义动物类接口
 2	interface Animal { 
 3		void shout(); // 定义方法shout()
 4	}
 5	public class Example22 {
 6		public static void main(String[] args) {
 7	       String name = "小花"; 
 8	       // 1、匿名内部类作为参数传递给animalShout()方法
 9		  animalShout(new Animal() { 
 10				 public void shout() { 
 11				    System.out.println("匿名内部类输出："+name+"喵喵...");
 12				}
 13		  });
 14		  // 2、使用Lambda表达式作为参数传递给animalShout()方法
 15	       animalShout(()-> System.out.println("Lambda表达式输出："
 16	                                                   +name+"喵喵..."));
 17		}
 18	    // 创建一个animalShout()静态方法，接收接口类型的参数
 19		public static void animalShout(Animal an) {
 20			an.shout();  
 21		}
 22	}
```  
  运行结果下图所示。
![alt](/article_img/lambda/1.jpg)
  上述代码示例中，先定义了只有一个抽象方法的接口Animal，然后分别使用匿名内部类和Lambda表达式的方式实现了接口方法。从图中可以看出，使用匿名内部类和Lambda表达式都能实现接口中方法，但很显然使用Lambda表达式更加简洁和清晰。, 2018-11-27, null, 默认分类, 2018,Lambda表达式, true, null, 18, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [7, 函数式接口, &emsp;&emsp;虽然Lambda表达式可以实现匿名内部类的功能，但在使用时却有一个局限，即接口中有且只有一个抽象方法时才能使用Lamdba表达式代替匿名内部类。这是因为Lamdba表达式是基于函数式接口实现的，所谓函数式接口是指有且仅有一个抽象方法的接口，Lambda表达式就是Java中函数式编程的体现，只有确保接口中有且仅有一个抽象方法，Lambda表达式才能顺利地推导出所实现的这个接口中的方法。  
&emsp;&emsp;在JDK 8中，专门为函数式接口引入了一个@FunctionalInterface注解，该注解只是显示的标注了接口是一个函数式接口，并强制编辑器进行更严格的检查，确保该接口是函数式接口，如果不是函数式接口，那么编译器就会报错，而对程序运行并没有实质上的影响。  
&emsp;&emsp;接下来通过一个案例来演示函数式接口的定义与使用，示例代码如下所示。
```js
 1	// 定义无参、无返回值的函数式接口
 2	@FunctionalInterface
 3	interface Animal {
 4		void shout();
 5	}
 6	// 定义有参、有返回值的函数式接口
 7	interface Calculate {
 8		int sum(int a, int b);
 9	}
 10	public class Example23 {
 11		public static void main(String[] args) {
 12		   // 分别两个函数式接口进行测试
 13		   animalShout(() -> System.out.println("无参、无返回值的函数式接口调用"));
 14		   showSum(10, 20, (x, y) -> x + y);
 15		}
 16		// 创建一个动物叫的方法，并传入接口对象Animal作为参数
 17		private static void animalShout(Animal animal) {
 18			animal.shout();
 19		}
 20		// 创建一个求和的方法，并传入两个int类型以及接口Calculate类型的参数
 21		private static void showSum(int x, int y, Calculate calculate) {
 22		   System.out.println(x + "+" + y + "的和为：" + calculate.sum(x, y));
 23		}
 24	}
```  
&emsp;&emsp;运行结果如下图所示。

![alt](/article_img/lambda/2.jpg)
&emsp;&emsp;上述代码示例中，先定义了两个函数式接口Animal和Calculate，然后在测试类中分别编写了两个静态方法，并将这两个函数式接口以参数的形式传入，最后在main()方法中分别调用这两个静态方法，并将所需要的函数式接口参数以Lambda表达式的形式传入。从图中可以看出，程序中函数式接口的定义和使用完全正确。
, 2018-12-01, null, 默认分类, 接口,函数式接口, true, null, 12, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} created. update t_statistic set hits = hits+1 where article_id=?;
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} Parameters : [4]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} executed. 3.6513 millis. update t_statistic set hits = hits+1 where article_id=?;
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} created. select * from t_comment where article_id=?
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} Parameters : [4]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} executed. 3.1019 millis. select * from t_comment where article_id=?
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50001} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50001} Header: [id, article_id, created, ip, c_content, status, author]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50001} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} connected
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} executed. 10.7284 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 108, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [12, Spring Boot 2 权威发布,   如果这两天登录 [https://start.spring.io/ ](https://start.spring.io/ )就会发现，Spring Boot 默认版本已经升到了 2.1.0。这是因为 Spring Boot 刚刚发布了 2.1.0 版本，我们来看下 Spring Boot 2 发布以来第一个子版本都发布了哪些内容？  

**2.1 中的新特性**     
  ●将spring-boot-starter-oauth2-oidc-client重命名为spring-boot-starter-oauth2-client命名更简洁  
  ●添加 OAuth2 资源服务 starter，OAuth2 一个用于认证的组件  
  ●支持 ConditionalOnBean 和 ConditionalOnMissingBean 下的参数化容器  
  ●自动配置 applicationTaskExecutor bean 的延迟加载来避免不必要的日志记录  
  ●将 DatabaseDriver＃SAP 重命名为 DatabaseDriver  
  ●跳过重启器不仅适用于 JUnit4，也适用于 JUnit5  
  ●在 Jest HealthIndicator 中使用集群端点  
  ●当 DevTools 禁用重启时添加日志输出  
  ●添加注解：@ConditionalOnMissingServletFilter提高 Servlet Filters 的自动装配。
  
**2.1 中的组件升级**  
  ●升级 Hibernate 5.3，Hibernate 的支持升级到了 5.3  
  ●升级 Tomcat 9 ，支持最新的 tomcat 9  
  ●支持 Java 11，Java 现在更新越来越快，Spring 快赶不上了    
  ●升级 Thymeleaf Extras Springsecurity 到 3.0.4.RELEASE ，thymeleaf-extras-springsecurity 是 Thymeleaf 提供集成 Spring Security 的组件  
  ●升级 Joda Time 2.10.1，Joda-Time， 面向 Java 应用程序的日期/时间库的替代选择，Joda-Time 令时间和日期值变得易于管理、操作和理解。  
  ●升级 Lettuce 5.1.2.RELEASE ，Lettuce 前面说过，传说中 Redis 最快的客户端。  
  ●升级 Reactor Californium-SR2 ，Californium 是物联网云服务的 Java COAP 实现。因此，它更专注的是可扩展性和可用性而不是像嵌入式设备那样关注资源效率。不过，Californium 也适合嵌入式的 JVM。  
  ●升级 Maven Failsafe Plugin 2.22.1 ，Maven 中的测试插件。  
  ●升级 Flyway 5.2.1 ， Flyway是一款开源的数据库版本管理工具  
  ●升级 Aspectj 1.9.2 ，AspectJ 是 Java 中流行的 AOP（Aspect-oriented Programming）编程扩展框架，是 Eclipse 托管给 Apache 基金会的一个开源项目。  
  ●升级 Mysql 8.0.13 ，Mysql 支持到 8。  
  ●...  
  更多的详细内容可以参考这里：[Spring Boot 2.1 Release Notes](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.1-Release-Notes)
, 2018-12-12, 2021-05-21, 默认分类, Spring Boot 2, true, null, 62, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [8, JDK 8——聚合操作, &emsp;&emsp;在Java8版本中，JDK包含许多聚合操作（如平均值，总和，最小，最大，和计数），返回一个计算流stream的聚合结果。这些聚合操作被称为聚合操作。JDK除返回单个值的聚合操作外，还有很多聚合操作返回一个collection集合实例。很多的reduce操作执行特定的任务，如求平均值或按类别分组元素。  

**1. 聚合操作简介**

  在开发中，多数情况下会涉及到对集合、数组中元素的操作，在JDK 8之前都是通过普通的循环遍历出每一个元素，然后还会穿插一些if条件语句选择性的对元素进行查找、过滤、修改等操作，这种原始的操作方法虽然可行，但是代码量较大并且执行效率较低。  
  为此，JDK 8中新增了一个Stream接口，该接口可以将集合、数组的中的元素转换为Stream流的形式，并结合Lambda表达式的优势来进一步简化集合、数组中元素的查找、过滤、转换等操作，这一新功能就是JDK 8中的聚合操作。  
  在程序中，使用聚合操作没有绝对的语法规范，根据实际操作流程，主要可以分为以下3个步骤：  
  （1）将原始集合或者数组对象转换为Stream流对象；  
  （2）对Stream流对象中的元素进行一系列的过滤、查找等中间操作（Intermediate Operations），然后仍然返回一个Stream流对象；  
  （3）对Stream流进行遍历、统计、收集等终结操作（Terminal Operation），获取想要的结果。  
  接下来，就根据上面聚合操作的3个步骤，通过一个案例来演示聚合操作的基本用法，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example31 {
 4		public static void main(String[] args) {
 5	          // 创建一个List集合对象
 6			List<String> list = new ArrayList<>(); 
 7			list.add("张三");
 8			list.add("李四");
 9			list.add("张小明");
 10			list.add("张阳");
 11			// 1、创建一个Stream流对象
 12			Stream<String> stream = list.stream();
 13			// 2、对Stream流中的元素分别进行过滤、截取操作
 14		       Stream<String> stream2 = stream.filter(i -> i.startsWith("张"));
 15			Stream<String> stream3 = stream2.limit(2);
 16			// 3、对Stream流中的元素进行终结操作，进行遍历输出
 17			stream3.forEach(j -> System.out.println(j));
 18			System.out.println("=======");
 19	         // 通过链式表达式的形式完成聚合操作
 20			list.stream().filter(i -> i.startsWith("张"))
 21						 .limit(2)
 22						 .forEach(j -> System.out.println(j));
 23		}
 24	}
``` 
   运行结果如下图所示。
![alt](/article_img/lambda/3.jpg)
  上述示例代码中，先创建了一个List集合，然后根据聚合操作的3个步骤实现了集合对象的聚合操作，对集合中的元素使用Stream流的形式进行过滤（filter）、截取（limit），并进行遍历输出。其中第12~17行代码分步骤详细展示了聚合操作，而第20~22行代码是使用了链式表达式（调用有返回值的方法时不获取返回值而是直接再调用另一个方法）实现了聚合操作，该表达式的语法格式更简洁、高效，这种链式调用也被称为操作管道流。

**2. 创建Stream流对象**  
  在上一小节中，介绍了聚合操作的主要使用步骤，其中首要解决的问题就是创建Stream流对象。聚合操作针对的就是可迭代数据进行的操作，如集合、数组等，所以创建Stream流对象其实就是将集合、数组等通过一些方法转换为Stream流对象。  
  在Java中，集合对象有对应的集合类，可以通过集合类提供的静态方法创建Stream流对象，而数组数据却没有对应的数组类，所以必须通过其他方法创建Stream流对象。针对不同的源数据，Java提供了多种创建Stream流对象的方式，分别如下：  
  （1）所有的Collections集合都可以使用stream()静态方法获取Stream流对象；  
  （2）Stream接口的of()静态方法可以获取基本类型包装类数组、引用类型数组和单个元素的Stream流对象；  
  （3）Arrays数组工具类的stream()静态方法也可以获取数组元素的Stream流对象。  
  接下来，通过一个案例来学习聚合操作中如何创建Stream流对象，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example32 {
 4		public static void main(String[] args) {
 5	          // 创建一个数组
 6			Integer[] array = { 9, 8, 3, 5, 2 };       
 7	          // 将数组转换为List集合
 8			List<Integer> list = Arrays.asList(array); 
 9			// 1、使用集合对象的stream()静态方法创建Stream流对象
 10			Stream<Integer> stream = list.stream();
 11			stream.forEach(i -> System.out.print(i+" "));
 12			System.out.println();
 13			// 2、使用Stream接口的of()静态方法创建Stream流对象
 14			Stream<Integer> stream2 = Stream.of(array);
 15			stream2.forEach(i -> System.out.print(i+" "));
 16			System.out.println();
 17			// 3、使用Arrays数组工具类的stream()静态方法创建Stream流对象
 18			Stream<Integer> stream3 = Arrays.stream(array);
 19			stream3.forEach(i -> System.out.print(i+" "));
 20		}
 21	}
```  
  运行结果如下图所示。
![alt](/article_img/lambda/4.jpg)
  上述示例代码中，先创建了一个数组和一个集合，然后通过三种方式实现了Stream流对象的创建，并通过Stream流对象的forEach()方法结合Lambda表达式完成了集合和数组中元素的遍历。  

**小提示：**  
  在JDK 8中，只针对单列集合Collections接口对象提供了stream()静态方法获取Stream流对象，并未对Map集合提供相关方法获取Stream流对象，所以想要用Map集合创建Stream流对象必须先通过Map集合的keySet()、values()、entrySet()等方法将Map集合转换为单列Set集合，然后再使用单列集合的stream()静态方法获取对应键、值集合的Stream流对象。

, 2018-12-02, null, 默认分类, JDK 8,聚合操作, true, null, 34, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [9, 虚拟化容器技术——Docker运行机制介绍,   Docker是一个开源的应用容器引擎，它基于go语言开发，并遵从Apache2.0开源协议。使用Docker可以让开发者封装他们的应用以及依赖包到一个可移植的容器中，然后发布到任意的Linux机器上，也可以实现虚拟化。Docker容器完全使用沙箱机制，相互之间不会有任何接口，这保证了容器之间的安全性。  

**1. Docker的引擎介绍**

  Docker Engine（Docker引擎）是Docker的核心部分，使用的是客户端-服务器（C/S）架构模式，其主要组成部分如下图所示。
![alt](/article_img/docker/1.png)
  从上图可以看出，Docker Engine中包含了三个核心组件（docker CLI、REST API和docker daemon），这三个组件的具体说明如下：  
  ①docker CLI（command line interface）：表示Docker命令行接口，开发者可以在命令行中使用Docker相关指令与Docker守护进程进行交互，从而管理诸如image（镜像）、container（容器）、network（网络）和data volumes（数据卷）等实体。  
  ②REST API：表示应用程序API接口，开发者通过该API接口可以与Docker的守护进程进行交互，从而指示后台进行相关操作。  
  ③docker daemon：表示Docker的服务端组件，他是Docker架构中运行在后台的一个守护进程，可以接收并处理来自命令行接口及API接口的指令，然后进行相应的后台操作。  
  对于开发者而言，既可以使用编写好的脚本文件通过REST API来实现与Docker进程交互，又可以直接使用Docker相关指令通过命令行接口来与Docker进程交互，而其他一些Docker应用则是通过底层的API和CLI进行交互的。

**2. Docker的架构介绍**

  了解了Docker内部引擎及作用后，我们还需要通过Docker的具体架构，来了解Docker的整个运行流程。接下来借助Docker官网的架构图来对Docker架构进行详细说明，如下图所示。
![alt](/article_img/docker/2.jpg)
  从图中可以看出，Docker架构主要包括Client、DOCKER_HOST和Register三部分，关于这三部分的具体说明如下。  
&emsp;&emsp;**（1）Client（客户端）**  
  Client即Docker客户端，也就是上一小节Docker Engine中介绍的docker CLI。开发者通过这个客户端使用Docker的相关指令与Docker守护进程进行交互，从而进行Docker镜像的创建、拉取和运行等操作。  
&emsp;&emsp;**（2）DOCKER_HOST（Docker主机）**  
  DOCKER_HOST即Docker内部引擎运行的主机，主要指Docker daemon（Docker守护进程）。可以通过Docker守护进程与客户端还有Docker的镜像仓库Registry进行交互，从而管理Images（镜像）和Containers（容器）等。  
&emsp;&emsp;**（3）Registry（注册中心）**  
  Registry即Docker注册中心，实质就是Docker镜像仓库，默认使用的是Docker官方远程注册中心Docker Hub，也可以使用开发者搭建的本地仓库。Registry中包含了大量的镜像，这些镜像可以是官网基础镜像，也可以是其他开发者上传的镜像。  
  我们在实际使用Docker时，除了会涉及到图中的三个主要部分外，还会涉及到很多Docker Objects（Docker对象），例如Images（镜像）、Containers（容器）、Networks（网络）、Volumes（数据卷）、Plugins（插件）等。其中常用的两个对象Image和Containers的说明如下。  
  ①Images（镜像）  
  Docker 镜像就是一个只读的模板，包含了一些创建Docker容器的操作指令。通常情况下，一个Docker镜像是基于另一个基础镜像创建的，并且新创建的镜像会额外包含一些功能配置。例如：开发者可以依赖于一个Ubuntu的基础镜像创建一个新镜像，并可以在新镜像中安装Apache等软件或其它应用程序。  
  ②Containers（容器）  
  Docker容器属于镜像的一个可运行实例（镜像与容器的关系其实与Java中的类与对象相似），开发者可以通过API接口或者CLI命令行接口来创建、运行、停止、移动、删除一个容器，也可以将一个容器连接到一个或多个网络中，将数据存储与容器进行关联。



, 2018-12-03, null, 默认分类, 虚拟化容器,Docker,运行机制, true, null, 26, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [10, Docker常用客户端指令介绍,   在使用Docker之前，首先会为对应的项目编写Dockerfile镜像构建文件，然后通过Docker的相关指令进行镜像构建，完成镜像的构建后，就可以使用这些项目镜像进行启动测试了。所以要想知道如何使用Docker来执行这些Dockerfile镜像构建文件，还需要学习Docker客户端的常用指令，本篇文章将对Docker客户端的常用指令进行详细讲解。  

**1.列出镜像**  
  通过docker images指令可以查看本地镜像列表中已有的镜像，具体使用方式如下。
```js
$ docker images
```  
  执行上述指令后，系统会将所有本地镜像都展示出来，如下图所示。
![alt](/article_img/docker/3.png)
  从图中可以看出，系统终端将本地镜像列表中的3个镜像分5列进行了展示，每一列的具体含义如下。  
  ●REPOSITORY：镜像名称。  
  ●TAG：镜像的参数，类似于版本号，默认是latest。  
  ●IMAGE ID：镜像ID，是唯一值。此处看到的是一个长度为12的字符串，实际上它是64位完整镜像ID的缩写形式。  
  ●CREATED：距今创建镜像的时间。  
  ●SIZE：镜像大小。    

**2.搜索镜像**  
  想知道在Docker Hub中包含了哪些镜像，除了可以登录Docker Hub，在官网中心进行查看外，还可以直接在Docker客户端进行查询。例如想要查询Ubuntu镜像，可以使用如下指令。
```js
$ docker search ubuntu
```  
  执行上述指令后，系统终端就会将搜索到的有关Ubuntu的镜像展示出来，如下图所示。
![alt](/article_img/docker/4.png)
  从图所示的结果可以看出，系统终端分5列将搜索到的Ubuntu相关镜像都列举出来了，这5列的具体含义如下。  
  ●NAME：表示镜像的名称，这里有两种格式的名称，其中不带有“/”的表示官方镜像，而带有“/”的表示其他用户的公开镜像。公开镜像“/”前面是用户在Docker Hub上的用户名（唯一），后面是对应的镜像名；官方镜像与用户镜像，除了从镜像名称上可以区分外，还可以通过第4列的OFFICIAL声明中看出（该列下内容为OK表示官方镜像）。  
  ●DESCRIPTION：表示镜像的描述，这里只显示了一小部分。  
  ●STARS：表示该镜像的收藏数，用户可以在Docker Hub上对镜像进行收藏，一般可以通过该数字反应出该镜像的受欢迎程度。  
  ●OFFICIAL：表示是否为官方镜像。  
  ●AUTOMATED：表示是否自动构建镜像。例如，用户可以将自己的Docker Hub绑定到如Github上，当代码提交更新后，可以自动构建镜像。   
 
**3.拉取镜像**  
  通过docker pull指令可以拉取仓库镜像到本地（默认都是拉取Docker Hub仓库镜像，也可以指定“IP+端口”拉取某个Docker机器上的私有仓库镜像），具体使用方式如下。
```js
$ docker pull ubuntu
```  
  执行上述指令后，Docker会自动从Docker Hub上下载最新版本的Ubuntu到本地，当然也可以使用以下指令拉取指定版本的镜像到本地，具体指令如下。
```js
$ docker pull ubuntu:14.04
```  
**4.构建镜像**  
  除了可以通过docker pull指令从仓库拉取镜像外，还可以通过docker build指令构建Docker镜像，通常情况下都是通过Dockerfile文件来构建镜像的。  
  这里假设linux系统home目录下/shitou/workspace/dockerspace文件夹中编写有对应的Dockerfile文件，则构建镜像直立示例如下所示。 
```js
$ docker build -t hellodocker3 /home/shitou/workspace/dockerspace/.
```
**5.删除镜像**  
  当本地存放过多不需要的镜像时，可以通过docker rmi指令将其删除。在删除镜像时，需要指定镜像名称或镜像ID。删除镜像的使用方式如下。
```js
$ docker rmi -f hellodocker2 hellodocker3
```  
  上述指令中，docker rmi表示删除镜像，-f表示进行强制删除，而hellodocker2和hellodocker3分别表示需要删除的镜像名称，这里同时删除两个镜像。除了根据名称删除镜像外，还也可以根据镜像ID来删除镜像，只是这里如果指定了删除ID为23c617a866d4的镜像后，会同时删除hellodocker、hellodocker2和hellodocker3三个镜像。  
  需要特别强调的是，在进行镜像删除操作时，如果是通过镜像ID进行镜像删除，那么由该镜像创建的容器必须提前删除或停止。另外，在通过镜像名称操作镜像时，如果出现镜像重名的情况，必须在镜像名称后面指定镜像标签tag参数来确保唯一性。

**6.创建并启动容器**  
  Docker镜像主要用于创建容器，可以使用docker run指令创建并启动容器，具体使用方式如下。
```js
$ docker run -d -p 5000:80 --name test hellodocker
```  
  上述创建并启动容器的指令略微复杂，具体分析如下。  
  ●docker run：表示创建并启动一个容器，而后面的hellodocker就表示要启动运行的镜像名称；  
  ●-d：表示容器启动时在后台运行；  
  ●-p 5000:80：表示将容器内暴露的80端口映射到宿主机指定的5000端口，也可以将-p 5000:80更改为-P来映射主机的随机端口（注意p字母的大小写）；  
  ●--name test：表示为创建后的容器指定名称为test，如果没有该参数配置，则生成的容器会设置一个随机名称。  
  docker run命令是Docker操作中较为复杂的一个，它可以携带多个参数和参数，我们可以通过docker run --help指令进行查看，其中有些参数如-e、-v和-w等都可以在Dockerfile文件中预先声明。 
 
**7.列出容器**  
  生成容器后，可以通过docker ps指令查看当前运行的所有容器，具体使用方式如下。
```js
$ docker ps
```  
  执行上述命令后，会将所有当前运行的容器都展示出来，具体如下图所示。
![alt](/article_img/docker/5.png)
  从图中可以看出，系统终端通过7列对当前的正在运行的一个容器进行了展示，图中每一列的具体含义如下。  
  ●CONTAINER ID：表示生成的容器ID；  
  ●IMAGE：表示生成该容器的镜像名称；  
  ●COMMAND：表示启动容器时运行的命令，Docker要求在启动容器时必须运行一个命令；  
  ●CREATED：表示容器创建的时间；  
  ●STATUS：表示容器运行状态，例如Up表示运行中，Exited表示已停止；  
  ●PORTS：表示容器内部暴露的端口映射到主机的端口；  
  ●NAMES：表示生成容器的名称，由Docker引擎自动生成，可以像上述示例中使用--name参数指定生成容器的名称。  
  另外，docker ps指令运行过程中可以指定多个参数，还可以通过docker ps --help指令对ps指令的其他信息进行查看。

**8.删除容器**  
  当不需要使用容器时，则可以使用docker rm指令删除已停止的容器，具体使用方式如下。
```js
$ docker rm f0c9a8b6e8c5
```  
  需要注意的是，上述指令只能删除已经停止运行的容器，而不能删除正在运行的容器。如果想要删除正在运行的容器，则需要添加-f参数强制删除，具体使用方式如下。
```js
$ docker rm -f f0c9a8b6e8c5
```  
  当需要删除的容器过多时，如果还一个个的删除就略显麻烦了，此时可以通过如下指令将全部容器删除。
```js
$ docker rm -f $(docker ps -aq)
```  
  上述指令中，首先会通过$(docker ps -aq)获取所有容器的ID，然后通过docker rm -f指令进行强制删除。如果开发者有自己特殊的删除需求，可以根据前面docker ps指令进行组装来获取需要删除的容器ID。  
  Docker提供的操作指令远不止这些，这里就不一一列举了，想要了解更多Docker的操作指令，可以通过docker --help指令进行查看。


, 2018-12-05, null, 默认分类, Docker,客户端指令, true, null, 21, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [11, Docker数据管理介绍,   当我们对容器进行相关操作时，产生的一系列数据都会存储在容器中，而Docker内部又是如果管理这些数据的呢？本篇文章将针对Docker数据管理的一些知识进行介绍。
  
**1. Docker数据存储机制**  
  使用Docker时，我们操作的都是镜像和由镜像生成的容器，所以想要更好的了解Docker内部的数据存储机制，就必须从镜像、容器与数据存储的关系出发。  
  Docker镜像是通过读取Dockerfile文件中的指令构建的，Dockerfile中的每条指令都会创建一个镜像层，并且每层都是只读的，这一系列的镜像层就构成了Docker镜像。接下来以一个Dockerfile文件为例进行说明，具体如下列代码示例所示。
```js
 1	FROM ubuntu:16.04
 2	COPY . /app
 3	RUN make /app
 4	CMD python /app/app.py
```  
   上述文件示例中的Dockerfile包含了4条指令，每条指令都会创建一个镜像层，其中每一层与前一层都有所不同，并且是层层叠加的。通过镜像构建容器时，会在镜像层上增加一个容器层（即可写层），所有对容器的更改都会写入容器层，这也是Docker默认的数据存储方式。  
  下面通过一个效果图进行说明，具体如下图所示。
![alt](/article_img/docker/6.png)
  从图中可以看出，Docker容器和镜像之间的主要区别是顶部的容器层，而所有对容器中数据的添加、修改等操作都会被存储在容器层中。当容器被删除时，容器层也会被删除，其中存储的数据会被一同删除，而下面的镜像层却保持不变。  
  由于所有的容器都是通过镜像构建的，所以每个容器都有各自的容器层，对于容器数据的更改就会保存在各自的容器层中。也就是说，由同一个镜像构建的多个容器，它们会拥有相同的底部镜像层，而拥有不同的容器层，多个容器可以访问相同的镜像层，并且有自己的独立数据状态。具体说明如下图所示。 
![alt](/article_img/docker/7.png)
  从图中可以看出，基于同一个镜像构建的多个容器可以共享该镜像层，但是多个容器想要共享相同的数据，就需要将这些数据存储到容器之外的地方，而这种方式就是下一节要提到的Docker volume数据外部挂载机制。  

**2. Docker数据存储方式**    
  在默认情况下，Docker中的数据都是存放在容器层的，但是这样存储数据却有较多的缺陷，具体表现如下。    
  ●当容器不再运行时，容器中的数据无法持久化保存，如果另一个进程需要这些数据，那么将很难从容器中获取数据；  
  ●容器层与正在运行的主机紧密耦合，不能轻易地移动数据；  
  ●容器层需要一个存储驱动程序来管理文件系统，存储驱动程序提供了一个使用Linux内核的联合文件系统，这种额外的抽象化降低了性能。  
  基于上述种种原因，多数情况下Docker数据管理都不会直接将数据写入容器层，而是使用另一种叫做Docker volume数据外部挂载的机制进行数据管理。  
  针对Docker volume数据外部挂载机制，Docker提供了三种不同的方式将数据从容器映射到Docker宿主机，他们分别为：volumes（数据卷）、bind mounts（绑定挂载）和tmpfs mounts（tmpfs挂载）。这三种数据管理方式的具体选择，需要结合实际情况进行考虑，其中的volumes数据卷是最常用也是官方推荐的数据管理方式。无论选择使用哪种数据管理方式，数据在容器内看起来都一样的，而在容器外则会被被挂载到文件系统中的某个目录或文件中。    
  下面通过一张图来展示数据卷、绑定挂载和tmpfs挂载之间的差异，如下图所示。  
![alt](/article_img/docker/8.png)
  从图中可以看出，Docker提供的三种数据管理方式略有不同，具体分析如下。  
  ●volumes：存储在主机文件系统中（在Linux系统下是存在于/var/lib/Docker/volumes/目录），并由Docker管理，非Docker进程无法修改文件系统的这个部分。  
  ●bind mounts：可以存储在主机系统的任意位置，甚至可能是重要的系统文件或目录，在Docker主机或容器上的非Docker进程可以对他们进行任意修改。  
  ●tmpfs mounts：只存储在主机系统的内存中，并没有写入到主机的文件系统中。


, 2018-12-07, 2021-05-19, 默认分类, Docker,数据管理, true, null, 19, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [6, JDK 8——Lambda表达式介绍,   Lambda表达式是JDK 8中一个重要的新特性，它使用一个清晰简洁的表达式来表达一个接口，同时Lambda表达式也简化了对集合以及数组数据的遍历、过滤和提取等操作。下面，本篇文章就对Lambda表达式进行简要介绍，并进行演示说明。

**1. Lambda表达式入门**  

  匿名内部类存在的一个问题是，如果匿名内部类的实现非常简单，例如只包含一个抽象方法的接口，那么匿名内部类的语法仍然显得比较冗余。为此，JDK 8中新增了一个特性Lambda表达式，这种表达式只针对有一个抽象方法的接口实现，以简洁的表达式形式实现接口功能来作为方法参数。  
  一个Lambda表达式由三个部分组成，分别为参数列表、“->”和表达式主体，其语法格式如下：
```js
 ([数据类型 参数名,数据类型 参数名,...]) -> {表达式主体}
```  
  从上述语法格式上看，Lambda表达式的书写非常简单，下面针对Lambda表达式的组成部分进行简单介绍，具体如下：  
  （1）([数据类型 参数名,数据类型 参数名,...])：用来向表达式主体传递接口方法需要的参数，多个参数名中间必须用英文逗号“,”进行分隔；在编写Lambda表达式时，可以省略参数的数据类型，后面的表达式主体会自动进行校对和匹配；同时，如果只有一个参数，则可以省略括号“()”。  
  （2）->：表示Lambda表达式箭牌，用来指定参数数据指向，不能省略，且必须用英文横线和大于号书写。  
  （3）{表达式主体}：由单个表达式或语句块组成的主体，本质就是接口中抽象方法的具体实现，如果表达式主体只有一条语句，那么可以省略包含主体的大括号；另外，在Lambda表达式主体中允许有返回值，当只有一条return语句时，也可以省略return关键字。  
  了解了Lambda表达式的语法后，接下来编写一个示例文件对Lambda表达式的基本使用进行介绍，具体代码如下所示。
```js
 1	// 定义动物类接口
 2	interface Animal { 
 3		void shout(); // 定义方法shout()
 4	}
 5	public class Example22 {
 6		public static void main(String[] args) {
 7	       String name = "小花"; 
 8	       // 1、匿名内部类作为参数传递给animalShout()方法
 9		  animalShout(new Animal() { 
 10				 public void shout() { 
 11				    System.out.println("匿名内部类输出："+name+"喵喵...");
 12				}
 13		  });
 14		  // 2、使用Lambda表达式作为参数传递给animalShout()方法
 15	       animalShout(()-> System.out.println("Lambda表达式输出："
 16	                                                   +name+"喵喵..."));
 17		}
 18	    // 创建一个animalShout()静态方法，接收接口类型的参数
 19		public static void animalShout(Animal an) {
 20			an.shout();  
 21		}
 22	}
```  
  运行结果下图所示。
![alt](/article_img/lambda/1.jpg)
  上述代码示例中，先定义了只有一个抽象方法的接口Animal，然后分别使用匿名内部类和Lambda表达式的方式实现了接口方法。从图中可以看出，使用匿名内部类和Lambda表达式都能实现接口中方法，但很显然使用Lambda表达式更加简洁和清晰。, 2018-11-27, null, 默认分类, 2018,Lambda表达式, true, null, 18, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [7, 函数式接口, &emsp;&emsp;虽然Lambda表达式可以实现匿名内部类的功能，但在使用时却有一个局限，即接口中有且只有一个抽象方法时才能使用Lamdba表达式代替匿名内部类。这是因为Lamdba表达式是基于函数式接口实现的，所谓函数式接口是指有且仅有一个抽象方法的接口，Lambda表达式就是Java中函数式编程的体现，只有确保接口中有且仅有一个抽象方法，Lambda表达式才能顺利地推导出所实现的这个接口中的方法。  
&emsp;&emsp;在JDK 8中，专门为函数式接口引入了一个@FunctionalInterface注解，该注解只是显示的标注了接口是一个函数式接口，并强制编辑器进行更严格的检查，确保该接口是函数式接口，如果不是函数式接口，那么编译器就会报错，而对程序运行并没有实质上的影响。  
&emsp;&emsp;接下来通过一个案例来演示函数式接口的定义与使用，示例代码如下所示。
```js
 1	// 定义无参、无返回值的函数式接口
 2	@FunctionalInterface
 3	interface Animal {
 4		void shout();
 5	}
 6	// 定义有参、有返回值的函数式接口
 7	interface Calculate {
 8		int sum(int a, int b);
 9	}
 10	public class Example23 {
 11		public static void main(String[] args) {
 12		   // 分别两个函数式接口进行测试
 13		   animalShout(() -> System.out.println("无参、无返回值的函数式接口调用"));
 14		   showSum(10, 20, (x, y) -> x + y);
 15		}
 16		// 创建一个动物叫的方法，并传入接口对象Animal作为参数
 17		private static void animalShout(Animal animal) {
 18			animal.shout();
 19		}
 20		// 创建一个求和的方法，并传入两个int类型以及接口Calculate类型的参数
 21		private static void showSum(int x, int y, Calculate calculate) {
 22		   System.out.println(x + "+" + y + "的和为：" + calculate.sum(x, y));
 23		}
 24	}
```  
&emsp;&emsp;运行结果如下图所示。

![alt](/article_img/lambda/2.jpg)
&emsp;&emsp;上述代码示例中，先定义了两个函数式接口Animal和Calculate，然后在测试类中分别编写了两个静态方法，并将这两个函数式接口以参数的形式传入，最后在main()方法中分别调用这两个静态方法，并将所需要的函数式接口参数以Lambda表达式的形式传入。从图中可以看出，程序中函数式接口的定义和使用完全正确。
, 2018-12-01, null, 默认分类, 接口,函数式接口, true, null, 12, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} connected
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} executed. 10.0562 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 108, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [12, Spring Boot 2 权威发布,   如果这两天登录 [https://start.spring.io/ ](https://start.spring.io/ )就会发现，Spring Boot 默认版本已经升到了 2.1.0。这是因为 Spring Boot 刚刚发布了 2.1.0 版本，我们来看下 Spring Boot 2 发布以来第一个子版本都发布了哪些内容？  

**2.1 中的新特性**     
  ●将spring-boot-starter-oauth2-oidc-client重命名为spring-boot-starter-oauth2-client命名更简洁  
  ●添加 OAuth2 资源服务 starter，OAuth2 一个用于认证的组件  
  ●支持 ConditionalOnBean 和 ConditionalOnMissingBean 下的参数化容器  
  ●自动配置 applicationTaskExecutor bean 的延迟加载来避免不必要的日志记录  
  ●将 DatabaseDriver＃SAP 重命名为 DatabaseDriver  
  ●跳过重启器不仅适用于 JUnit4，也适用于 JUnit5  
  ●在 Jest HealthIndicator 中使用集群端点  
  ●当 DevTools 禁用重启时添加日志输出  
  ●添加注解：@ConditionalOnMissingServletFilter提高 Servlet Filters 的自动装配。
  
**2.1 中的组件升级**  
  ●升级 Hibernate 5.3，Hibernate 的支持升级到了 5.3  
  ●升级 Tomcat 9 ，支持最新的 tomcat 9  
  ●支持 Java 11，Java 现在更新越来越快，Spring 快赶不上了    
  ●升级 Thymeleaf Extras Springsecurity 到 3.0.4.RELEASE ，thymeleaf-extras-springsecurity 是 Thymeleaf 提供集成 Spring Security 的组件  
  ●升级 Joda Time 2.10.1，Joda-Time， 面向 Java 应用程序的日期/时间库的替代选择，Joda-Time 令时间和日期值变得易于管理、操作和理解。  
  ●升级 Lettuce 5.1.2.RELEASE ，Lettuce 前面说过，传说中 Redis 最快的客户端。  
  ●升级 Reactor Californium-SR2 ，Californium 是物联网云服务的 Java COAP 实现。因此，它更专注的是可扩展性和可用性而不是像嵌入式设备那样关注资源效率。不过，Californium 也适合嵌入式的 JVM。  
  ●升级 Maven Failsafe Plugin 2.22.1 ，Maven 中的测试插件。  
  ●升级 Flyway 5.2.1 ， Flyway是一款开源的数据库版本管理工具  
  ●升级 Aspectj 1.9.2 ，AspectJ 是 Java 中流行的 AOP（Aspect-oriented Programming）编程扩展框架，是 Eclipse 托管给 Apache 基金会的一个开源项目。  
  ●升级 Mysql 8.0.13 ，Mysql 支持到 8。  
  ●...  
  更多的详细内容可以参考这里：[Spring Boot 2.1 Release Notes](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.1-Release-Notes)
, 2018-12-12, 2021-05-21, 默认分类, Spring Boot 2, true, null, 62, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [8, JDK 8——聚合操作, &emsp;&emsp;在Java8版本中，JDK包含许多聚合操作（如平均值，总和，最小，最大，和计数），返回一个计算流stream的聚合结果。这些聚合操作被称为聚合操作。JDK除返回单个值的聚合操作外，还有很多聚合操作返回一个collection集合实例。很多的reduce操作执行特定的任务，如求平均值或按类别分组元素。  

**1. 聚合操作简介**

  在开发中，多数情况下会涉及到对集合、数组中元素的操作，在JDK 8之前都是通过普通的循环遍历出每一个元素，然后还会穿插一些if条件语句选择性的对元素进行查找、过滤、修改等操作，这种原始的操作方法虽然可行，但是代码量较大并且执行效率较低。  
  为此，JDK 8中新增了一个Stream接口，该接口可以将集合、数组的中的元素转换为Stream流的形式，并结合Lambda表达式的优势来进一步简化集合、数组中元素的查找、过滤、转换等操作，这一新功能就是JDK 8中的聚合操作。  
  在程序中，使用聚合操作没有绝对的语法规范，根据实际操作流程，主要可以分为以下3个步骤：  
  （1）将原始集合或者数组对象转换为Stream流对象；  
  （2）对Stream流对象中的元素进行一系列的过滤、查找等中间操作（Intermediate Operations），然后仍然返回一个Stream流对象；  
  （3）对Stream流进行遍历、统计、收集等终结操作（Terminal Operation），获取想要的结果。  
  接下来，就根据上面聚合操作的3个步骤，通过一个案例来演示聚合操作的基本用法，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example31 {
 4		public static void main(String[] args) {
 5	          // 创建一个List集合对象
 6			List<String> list = new ArrayList<>(); 
 7			list.add("张三");
 8			list.add("李四");
 9			list.add("张小明");
 10			list.add("张阳");
 11			// 1、创建一个Stream流对象
 12			Stream<String> stream = list.stream();
 13			// 2、对Stream流中的元素分别进行过滤、截取操作
 14		       Stream<String> stream2 = stream.filter(i -> i.startsWith("张"));
 15			Stream<String> stream3 = stream2.limit(2);
 16			// 3、对Stream流中的元素进行终结操作，进行遍历输出
 17			stream3.forEach(j -> System.out.println(j));
 18			System.out.println("=======");
 19	         // 通过链式表达式的形式完成聚合操作
 20			list.stream().filter(i -> i.startsWith("张"))
 21						 .limit(2)
 22						 .forEach(j -> System.out.println(j));
 23		}
 24	}
``` 
   运行结果如下图所示。
![alt](/article_img/lambda/3.jpg)
  上述示例代码中，先创建了一个List集合，然后根据聚合操作的3个步骤实现了集合对象的聚合操作，对集合中的元素使用Stream流的形式进行过滤（filter）、截取（limit），并进行遍历输出。其中第12~17行代码分步骤详细展示了聚合操作，而第20~22行代码是使用了链式表达式（调用有返回值的方法时不获取返回值而是直接再调用另一个方法）实现了聚合操作，该表达式的语法格式更简洁、高效，这种链式调用也被称为操作管道流。

**2. 创建Stream流对象**  
  在上一小节中，介绍了聚合操作的主要使用步骤，其中首要解决的问题就是创建Stream流对象。聚合操作针对的就是可迭代数据进行的操作，如集合、数组等，所以创建Stream流对象其实就是将集合、数组等通过一些方法转换为Stream流对象。  
  在Java中，集合对象有对应的集合类，可以通过集合类提供的静态方法创建Stream流对象，而数组数据却没有对应的数组类，所以必须通过其他方法创建Stream流对象。针对不同的源数据，Java提供了多种创建Stream流对象的方式，分别如下：  
  （1）所有的Collections集合都可以使用stream()静态方法获取Stream流对象；  
  （2）Stream接口的of()静态方法可以获取基本类型包装类数组、引用类型数组和单个元素的Stream流对象；  
  （3）Arrays数组工具类的stream()静态方法也可以获取数组元素的Stream流对象。  
  接下来，通过一个案例来学习聚合操作中如何创建Stream流对象，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example32 {
 4		public static void main(String[] args) {
 5	          // 创建一个数组
 6			Integer[] array = { 9, 8, 3, 5, 2 };       
 7	          // 将数组转换为List集合
 8			List<Integer> list = Arrays.asList(array); 
 9			// 1、使用集合对象的stream()静态方法创建Stream流对象
 10			Stream<Integer> stream = list.stream();
 11			stream.forEach(i -> System.out.print(i+" "));
 12			System.out.println();
 13			// 2、使用Stream接口的of()静态方法创建Stream流对象
 14			Stream<Integer> stream2 = Stream.of(array);
 15			stream2.forEach(i -> System.out.print(i+" "));
 16			System.out.println();
 17			// 3、使用Arrays数组工具类的stream()静态方法创建Stream流对象
 18			Stream<Integer> stream3 = Arrays.stream(array);
 19			stream3.forEach(i -> System.out.print(i+" "));
 20		}
 21	}
```  
  运行结果如下图所示。
![alt](/article_img/lambda/4.jpg)
  上述示例代码中，先创建了一个数组和一个集合，然后通过三种方式实现了Stream流对象的创建，并通过Stream流对象的forEach()方法结合Lambda表达式完成了集合和数组中元素的遍历。  

**小提示：**  
  在JDK 8中，只针对单列集合Collections接口对象提供了stream()静态方法获取Stream流对象，并未对Map集合提供相关方法获取Stream流对象，所以想要用Map集合创建Stream流对象必须先通过Map集合的keySet()、values()、entrySet()等方法将Map集合转换为单列Set集合，然后再使用单列集合的stream()静态方法获取对应键、值集合的Stream流对象。

, 2018-12-02, null, 默认分类, JDK 8,聚合操作, true, null, 34, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [9, 虚拟化容器技术——Docker运行机制介绍,   Docker是一个开源的应用容器引擎，它基于go语言开发，并遵从Apache2.0开源协议。使用Docker可以让开发者封装他们的应用以及依赖包到一个可移植的容器中，然后发布到任意的Linux机器上，也可以实现虚拟化。Docker容器完全使用沙箱机制，相互之间不会有任何接口，这保证了容器之间的安全性。  

**1. Docker的引擎介绍**

  Docker Engine（Docker引擎）是Docker的核心部分，使用的是客户端-服务器（C/S）架构模式，其主要组成部分如下图所示。
![alt](/article_img/docker/1.png)
  从上图可以看出，Docker Engine中包含了三个核心组件（docker CLI、REST API和docker daemon），这三个组件的具体说明如下：  
  ①docker CLI（command line interface）：表示Docker命令行接口，开发者可以在命令行中使用Docker相关指令与Docker守护进程进行交互，从而管理诸如image（镜像）、container（容器）、network（网络）和data volumes（数据卷）等实体。  
  ②REST API：表示应用程序API接口，开发者通过该API接口可以与Docker的守护进程进行交互，从而指示后台进行相关操作。  
  ③docker daemon：表示Docker的服务端组件，他是Docker架构中运行在后台的一个守护进程，可以接收并处理来自命令行接口及API接口的指令，然后进行相应的后台操作。  
  对于开发者而言，既可以使用编写好的脚本文件通过REST API来实现与Docker进程交互，又可以直接使用Docker相关指令通过命令行接口来与Docker进程交互，而其他一些Docker应用则是通过底层的API和CLI进行交互的。

**2. Docker的架构介绍**

  了解了Docker内部引擎及作用后，我们还需要通过Docker的具体架构，来了解Docker的整个运行流程。接下来借助Docker官网的架构图来对Docker架构进行详细说明，如下图所示。
![alt](/article_img/docker/2.jpg)
  从图中可以看出，Docker架构主要包括Client、DOCKER_HOST和Register三部分，关于这三部分的具体说明如下。  
&emsp;&emsp;**（1）Client（客户端）**  
  Client即Docker客户端，也就是上一小节Docker Engine中介绍的docker CLI。开发者通过这个客户端使用Docker的相关指令与Docker守护进程进行交互，从而进行Docker镜像的创建、拉取和运行等操作。  
&emsp;&emsp;**（2）DOCKER_HOST（Docker主机）**  
  DOCKER_HOST即Docker内部引擎运行的主机，主要指Docker daemon（Docker守护进程）。可以通过Docker守护进程与客户端还有Docker的镜像仓库Registry进行交互，从而管理Images（镜像）和Containers（容器）等。  
&emsp;&emsp;**（3）Registry（注册中心）**  
  Registry即Docker注册中心，实质就是Docker镜像仓库，默认使用的是Docker官方远程注册中心Docker Hub，也可以使用开发者搭建的本地仓库。Registry中包含了大量的镜像，这些镜像可以是官网基础镜像，也可以是其他开发者上传的镜像。  
  我们在实际使用Docker时，除了会涉及到图中的三个主要部分外，还会涉及到很多Docker Objects（Docker对象），例如Images（镜像）、Containers（容器）、Networks（网络）、Volumes（数据卷）、Plugins（插件）等。其中常用的两个对象Image和Containers的说明如下。  
  ①Images（镜像）  
  Docker 镜像就是一个只读的模板，包含了一些创建Docker容器的操作指令。通常情况下，一个Docker镜像是基于另一个基础镜像创建的，并且新创建的镜像会额外包含一些功能配置。例如：开发者可以依赖于一个Ubuntu的基础镜像创建一个新镜像，并可以在新镜像中安装Apache等软件或其它应用程序。  
  ②Containers（容器）  
  Docker容器属于镜像的一个可运行实例（镜像与容器的关系其实与Java中的类与对象相似），开发者可以通过API接口或者CLI命令行接口来创建、运行、停止、移动、删除一个容器，也可以将一个容器连接到一个或多个网络中，将数据存储与容器进行关联。



, 2018-12-03, null, 默认分类, 虚拟化容器,Docker,运行机制, true, null, 26, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [10, Docker常用客户端指令介绍,   在使用Docker之前，首先会为对应的项目编写Dockerfile镜像构建文件，然后通过Docker的相关指令进行镜像构建，完成镜像的构建后，就可以使用这些项目镜像进行启动测试了。所以要想知道如何使用Docker来执行这些Dockerfile镜像构建文件，还需要学习Docker客户端的常用指令，本篇文章将对Docker客户端的常用指令进行详细讲解。  

**1.列出镜像**  
  通过docker images指令可以查看本地镜像列表中已有的镜像，具体使用方式如下。
```js
$ docker images
```  
  执行上述指令后，系统会将所有本地镜像都展示出来，如下图所示。
![alt](/article_img/docker/3.png)
  从图中可以看出，系统终端将本地镜像列表中的3个镜像分5列进行了展示，每一列的具体含义如下。  
  ●REPOSITORY：镜像名称。  
  ●TAG：镜像的参数，类似于版本号，默认是latest。  
  ●IMAGE ID：镜像ID，是唯一值。此处看到的是一个长度为12的字符串，实际上它是64位完整镜像ID的缩写形式。  
  ●CREATED：距今创建镜像的时间。  
  ●SIZE：镜像大小。    

**2.搜索镜像**  
  想知道在Docker Hub中包含了哪些镜像，除了可以登录Docker Hub，在官网中心进行查看外，还可以直接在Docker客户端进行查询。例如想要查询Ubuntu镜像，可以使用如下指令。
```js
$ docker search ubuntu
```  
  执行上述指令后，系统终端就会将搜索到的有关Ubuntu的镜像展示出来，如下图所示。
![alt](/article_img/docker/4.png)
  从图所示的结果可以看出，系统终端分5列将搜索到的Ubuntu相关镜像都列举出来了，这5列的具体含义如下。  
  ●NAME：表示镜像的名称，这里有两种格式的名称，其中不带有“/”的表示官方镜像，而带有“/”的表示其他用户的公开镜像。公开镜像“/”前面是用户在Docker Hub上的用户名（唯一），后面是对应的镜像名；官方镜像与用户镜像，除了从镜像名称上可以区分外，还可以通过第4列的OFFICIAL声明中看出（该列下内容为OK表示官方镜像）。  
  ●DESCRIPTION：表示镜像的描述，这里只显示了一小部分。  
  ●STARS：表示该镜像的收藏数，用户可以在Docker Hub上对镜像进行收藏，一般可以通过该数字反应出该镜像的受欢迎程度。  
  ●OFFICIAL：表示是否为官方镜像。  
  ●AUTOMATED：表示是否自动构建镜像。例如，用户可以将自己的Docker Hub绑定到如Github上，当代码提交更新后，可以自动构建镜像。   
 
**3.拉取镜像**  
  通过docker pull指令可以拉取仓库镜像到本地（默认都是拉取Docker Hub仓库镜像，也可以指定“IP+端口”拉取某个Docker机器上的私有仓库镜像），具体使用方式如下。
```js
$ docker pull ubuntu
```  
  执行上述指令后，Docker会自动从Docker Hub上下载最新版本的Ubuntu到本地，当然也可以使用以下指令拉取指定版本的镜像到本地，具体指令如下。
```js
$ docker pull ubuntu:14.04
```  
**4.构建镜像**  
  除了可以通过docker pull指令从仓库拉取镜像外，还可以通过docker build指令构建Docker镜像，通常情况下都是通过Dockerfile文件来构建镜像的。  
  这里假设linux系统home目录下/shitou/workspace/dockerspace文件夹中编写有对应的Dockerfile文件，则构建镜像直立示例如下所示。 
```js
$ docker build -t hellodocker3 /home/shitou/workspace/dockerspace/.
```
**5.删除镜像**  
  当本地存放过多不需要的镜像时，可以通过docker rmi指令将其删除。在删除镜像时，需要指定镜像名称或镜像ID。删除镜像的使用方式如下。
```js
$ docker rmi -f hellodocker2 hellodocker3
```  
  上述指令中，docker rmi表示删除镜像，-f表示进行强制删除，而hellodocker2和hellodocker3分别表示需要删除的镜像名称，这里同时删除两个镜像。除了根据名称删除镜像外，还也可以根据镜像ID来删除镜像，只是这里如果指定了删除ID为23c617a866d4的镜像后，会同时删除hellodocker、hellodocker2和hellodocker3三个镜像。  
  需要特别强调的是，在进行镜像删除操作时，如果是通过镜像ID进行镜像删除，那么由该镜像创建的容器必须提前删除或停止。另外，在通过镜像名称操作镜像时，如果出现镜像重名的情况，必须在镜像名称后面指定镜像标签tag参数来确保唯一性。

**6.创建并启动容器**  
  Docker镜像主要用于创建容器，可以使用docker run指令创建并启动容器，具体使用方式如下。
```js
$ docker run -d -p 5000:80 --name test hellodocker
```  
  上述创建并启动容器的指令略微复杂，具体分析如下。  
  ●docker run：表示创建并启动一个容器，而后面的hellodocker就表示要启动运行的镜像名称；  
  ●-d：表示容器启动时在后台运行；  
  ●-p 5000:80：表示将容器内暴露的80端口映射到宿主机指定的5000端口，也可以将-p 5000:80更改为-P来映射主机的随机端口（注意p字母的大小写）；  
  ●--name test：表示为创建后的容器指定名称为test，如果没有该参数配置，则生成的容器会设置一个随机名称。  
  docker run命令是Docker操作中较为复杂的一个，它可以携带多个参数和参数，我们可以通过docker run --help指令进行查看，其中有些参数如-e、-v和-w等都可以在Dockerfile文件中预先声明。 
 
**7.列出容器**  
  生成容器后，可以通过docker ps指令查看当前运行的所有容器，具体使用方式如下。
```js
$ docker ps
```  
  执行上述命令后，会将所有当前运行的容器都展示出来，具体如下图所示。
![alt](/article_img/docker/5.png)
  从图中可以看出，系统终端通过7列对当前的正在运行的一个容器进行了展示，图中每一列的具体含义如下。  
  ●CONTAINER ID：表示生成的容器ID；  
  ●IMAGE：表示生成该容器的镜像名称；  
  ●COMMAND：表示启动容器时运行的命令，Docker要求在启动容器时必须运行一个命令；  
  ●CREATED：表示容器创建的时间；  
  ●STATUS：表示容器运行状态，例如Up表示运行中，Exited表示已停止；  
  ●PORTS：表示容器内部暴露的端口映射到主机的端口；  
  ●NAMES：表示生成容器的名称，由Docker引擎自动生成，可以像上述示例中使用--name参数指定生成容器的名称。  
  另外，docker ps指令运行过程中可以指定多个参数，还可以通过docker ps --help指令对ps指令的其他信息进行查看。

**8.删除容器**  
  当不需要使用容器时，则可以使用docker rm指令删除已停止的容器，具体使用方式如下。
```js
$ docker rm f0c9a8b6e8c5
```  
  需要注意的是，上述指令只能删除已经停止运行的容器，而不能删除正在运行的容器。如果想要删除正在运行的容器，则需要添加-f参数强制删除，具体使用方式如下。
```js
$ docker rm -f f0c9a8b6e8c5
```  
  当需要删除的容器过多时，如果还一个个的删除就略显麻烦了，此时可以通过如下指令将全部容器删除。
```js
$ docker rm -f $(docker ps -aq)
```  
  上述指令中，首先会通过$(docker ps -aq)获取所有容器的ID，然后通过docker rm -f指令进行强制删除。如果开发者有自己特殊的删除需求，可以根据前面docker ps指令进行组装来获取需要删除的容器ID。  
  Docker提供的操作指令远不止这些，这里就不一一列举了，想要了解更多Docker的操作指令，可以通过docker --help指令进行查看。


, 2018-12-05, null, 默认分类, Docker,客户端指令, true, null, 21, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [11, Docker数据管理介绍,   当我们对容器进行相关操作时，产生的一系列数据都会存储在容器中，而Docker内部又是如果管理这些数据的呢？本篇文章将针对Docker数据管理的一些知识进行介绍。
  
**1. Docker数据存储机制**  
  使用Docker时，我们操作的都是镜像和由镜像生成的容器，所以想要更好的了解Docker内部的数据存储机制，就必须从镜像、容器与数据存储的关系出发。  
  Docker镜像是通过读取Dockerfile文件中的指令构建的，Dockerfile中的每条指令都会创建一个镜像层，并且每层都是只读的，这一系列的镜像层就构成了Docker镜像。接下来以一个Dockerfile文件为例进行说明，具体如下列代码示例所示。
```js
 1	FROM ubuntu:16.04
 2	COPY . /app
 3	RUN make /app
 4	CMD python /app/app.py
```  
   上述文件示例中的Dockerfile包含了4条指令，每条指令都会创建一个镜像层，其中每一层与前一层都有所不同，并且是层层叠加的。通过镜像构建容器时，会在镜像层上增加一个容器层（即可写层），所有对容器的更改都会写入容器层，这也是Docker默认的数据存储方式。  
  下面通过一个效果图进行说明，具体如下图所示。
![alt](/article_img/docker/6.png)
  从图中可以看出，Docker容器和镜像之间的主要区别是顶部的容器层，而所有对容器中数据的添加、修改等操作都会被存储在容器层中。当容器被删除时，容器层也会被删除，其中存储的数据会被一同删除，而下面的镜像层却保持不变。  
  由于所有的容器都是通过镜像构建的，所以每个容器都有各自的容器层，对于容器数据的更改就会保存在各自的容器层中。也就是说，由同一个镜像构建的多个容器，它们会拥有相同的底部镜像层，而拥有不同的容器层，多个容器可以访问相同的镜像层，并且有自己的独立数据状态。具体说明如下图所示。 
![alt](/article_img/docker/7.png)
  从图中可以看出，基于同一个镜像构建的多个容器可以共享该镜像层，但是多个容器想要共享相同的数据，就需要将这些数据存储到容器之外的地方，而这种方式就是下一节要提到的Docker volume数据外部挂载机制。  

**2. Docker数据存储方式**    
  在默认情况下，Docker中的数据都是存放在容器层的，但是这样存储数据却有较多的缺陷，具体表现如下。    
  ●当容器不再运行时，容器中的数据无法持久化保存，如果另一个进程需要这些数据，那么将很难从容器中获取数据；  
  ●容器层与正在运行的主机紧密耦合，不能轻易地移动数据；  
  ●容器层需要一个存储驱动程序来管理文件系统，存储驱动程序提供了一个使用Linux内核的联合文件系统，这种额外的抽象化降低了性能。  
  基于上述种种原因，多数情况下Docker数据管理都不会直接将数据写入容器层，而是使用另一种叫做Docker volume数据外部挂载的机制进行数据管理。  
  针对Docker volume数据外部挂载机制，Docker提供了三种不同的方式将数据从容器映射到Docker宿主机，他们分别为：volumes（数据卷）、bind mounts（绑定挂载）和tmpfs mounts（tmpfs挂载）。这三种数据管理方式的具体选择，需要结合实际情况进行考虑，其中的volumes数据卷是最常用也是官方推荐的数据管理方式。无论选择使用哪种数据管理方式，数据在容器内看起来都一样的，而在容器外则会被被挂载到文件系统中的某个目录或文件中。    
  下面通过一张图来展示数据卷、绑定挂载和tmpfs挂载之间的差异，如下图所示。  
![alt](/article_img/docker/8.png)
  从图中可以看出，Docker提供的三种数据管理方式略有不同，具体分析如下。  
  ●volumes：存储在主机文件系统中（在Linux系统下是存在于/var/lib/Docker/volumes/目录），并由Docker管理，非Docker进程无法修改文件系统的这个部分。  
  ●bind mounts：可以存储在主机系统的任意位置，甚至可能是重要的系统文件或目录，在Docker主机或容器上的非Docker进程可以对他们进行任意修改。  
  ●tmpfs mounts：只存储在主机系统的内存中，并没有写入到主机的文件系统中。


, 2018-12-07, 2021-05-19, 默认分类, Docker,数据管理, true, null, 19, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [6, JDK 8——Lambda表达式介绍,   Lambda表达式是JDK 8中一个重要的新特性，它使用一个清晰简洁的表达式来表达一个接口，同时Lambda表达式也简化了对集合以及数组数据的遍历、过滤和提取等操作。下面，本篇文章就对Lambda表达式进行简要介绍，并进行演示说明。

**1. Lambda表达式入门**  

  匿名内部类存在的一个问题是，如果匿名内部类的实现非常简单，例如只包含一个抽象方法的接口，那么匿名内部类的语法仍然显得比较冗余。为此，JDK 8中新增了一个特性Lambda表达式，这种表达式只针对有一个抽象方法的接口实现，以简洁的表达式形式实现接口功能来作为方法参数。  
  一个Lambda表达式由三个部分组成，分别为参数列表、“->”和表达式主体，其语法格式如下：
```js
 ([数据类型 参数名,数据类型 参数名,...]) -> {表达式主体}
```  
  从上述语法格式上看，Lambda表达式的书写非常简单，下面针对Lambda表达式的组成部分进行简单介绍，具体如下：  
  （1）([数据类型 参数名,数据类型 参数名,...])：用来向表达式主体传递接口方法需要的参数，多个参数名中间必须用英文逗号“,”进行分隔；在编写Lambda表达式时，可以省略参数的数据类型，后面的表达式主体会自动进行校对和匹配；同时，如果只有一个参数，则可以省略括号“()”。  
  （2）->：表示Lambda表达式箭牌，用来指定参数数据指向，不能省略，且必须用英文横线和大于号书写。  
  （3）{表达式主体}：由单个表达式或语句块组成的主体，本质就是接口中抽象方法的具体实现，如果表达式主体只有一条语句，那么可以省略包含主体的大括号；另外，在Lambda表达式主体中允许有返回值，当只有一条return语句时，也可以省略return关键字。  
  了解了Lambda表达式的语法后，接下来编写一个示例文件对Lambda表达式的基本使用进行介绍，具体代码如下所示。
```js
 1	// 定义动物类接口
 2	interface Animal { 
 3		void shout(); // 定义方法shout()
 4	}
 5	public class Example22 {
 6		public static void main(String[] args) {
 7	       String name = "小花"; 
 8	       // 1、匿名内部类作为参数传递给animalShout()方法
 9		  animalShout(new Animal() { 
 10				 public void shout() { 
 11				    System.out.println("匿名内部类输出："+name+"喵喵...");
 12				}
 13		  });
 14		  // 2、使用Lambda表达式作为参数传递给animalShout()方法
 15	       animalShout(()-> System.out.println("Lambda表达式输出："
 16	                                                   +name+"喵喵..."));
 17		}
 18	    // 创建一个animalShout()静态方法，接收接口类型的参数
 19		public static void animalShout(Animal an) {
 20			an.shout();  
 21		}
 22	}
```  
  运行结果下图所示。
![alt](/article_img/lambda/1.jpg)
  上述代码示例中，先定义了只有一个抽象方法的接口Animal，然后分别使用匿名内部类和Lambda表达式的方式实现了接口方法。从图中可以看出，使用匿名内部类和Lambda表达式都能实现接口中方法，但很显然使用Lambda表达式更加简洁和清晰。, 2018-11-27, null, 默认分类, 2018,Lambda表达式, true, null, 18, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [7, 函数式接口, &emsp;&emsp;虽然Lambda表达式可以实现匿名内部类的功能，但在使用时却有一个局限，即接口中有且只有一个抽象方法时才能使用Lamdba表达式代替匿名内部类。这是因为Lamdba表达式是基于函数式接口实现的，所谓函数式接口是指有且仅有一个抽象方法的接口，Lambda表达式就是Java中函数式编程的体现，只有确保接口中有且仅有一个抽象方法，Lambda表达式才能顺利地推导出所实现的这个接口中的方法。  
&emsp;&emsp;在JDK 8中，专门为函数式接口引入了一个@FunctionalInterface注解，该注解只是显示的标注了接口是一个函数式接口，并强制编辑器进行更严格的检查，确保该接口是函数式接口，如果不是函数式接口，那么编译器就会报错，而对程序运行并没有实质上的影响。  
&emsp;&emsp;接下来通过一个案例来演示函数式接口的定义与使用，示例代码如下所示。
```js
 1	// 定义无参、无返回值的函数式接口
 2	@FunctionalInterface
 3	interface Animal {
 4		void shout();
 5	}
 6	// 定义有参、有返回值的函数式接口
 7	interface Calculate {
 8		int sum(int a, int b);
 9	}
 10	public class Example23 {
 11		public static void main(String[] args) {
 12		   // 分别两个函数式接口进行测试
 13		   animalShout(() -> System.out.println("无参、无返回值的函数式接口调用"));
 14		   showSum(10, 20, (x, y) -> x + y);
 15		}
 16		// 创建一个动物叫的方法，并传入接口对象Animal作为参数
 17		private static void animalShout(Animal animal) {
 18			animal.shout();
 19		}
 20		// 创建一个求和的方法，并传入两个int类型以及接口Calculate类型的参数
 21		private static void showSum(int x, int y, Calculate calculate) {
 22		   System.out.println(x + "+" + y + "的和为：" + calculate.sum(x, y));
 23		}
 24	}
```  
&emsp;&emsp;运行结果如下图所示。

![alt](/article_img/lambda/2.jpg)
&emsp;&emsp;上述代码示例中，先定义了两个函数式接口Animal和Calculate，然后在测试类中分别编写了两个静态方法，并将这两个函数式接口以参数的形式传入，最后在main()方法中分别调用这两个静态方法，并将所需要的函数式接口参数以Lambda表达式的形式传入。从图中可以看出，程序中函数式接口的定义和使用完全正确。
, 2018-12-01, null, 默认分类, 接口,函数式接口, true, null, 12, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} connected
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} executed. 9.0014 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 108, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [12, Spring Boot 2 权威发布,   如果这两天登录 [https://start.spring.io/ ](https://start.spring.io/ )就会发现，Spring Boot 默认版本已经升到了 2.1.0。这是因为 Spring Boot 刚刚发布了 2.1.0 版本，我们来看下 Spring Boot 2 发布以来第一个子版本都发布了哪些内容？  

**2.1 中的新特性**     
  ●将spring-boot-starter-oauth2-oidc-client重命名为spring-boot-starter-oauth2-client命名更简洁  
  ●添加 OAuth2 资源服务 starter，OAuth2 一个用于认证的组件  
  ●支持 ConditionalOnBean 和 ConditionalOnMissingBean 下的参数化容器  
  ●自动配置 applicationTaskExecutor bean 的延迟加载来避免不必要的日志记录  
  ●将 DatabaseDriver＃SAP 重命名为 DatabaseDriver  
  ●跳过重启器不仅适用于 JUnit4，也适用于 JUnit5  
  ●在 Jest HealthIndicator 中使用集群端点  
  ●当 DevTools 禁用重启时添加日志输出  
  ●添加注解：@ConditionalOnMissingServletFilter提高 Servlet Filters 的自动装配。
  
**2.1 中的组件升级**  
  ●升级 Hibernate 5.3，Hibernate 的支持升级到了 5.3  
  ●升级 Tomcat 9 ，支持最新的 tomcat 9  
  ●支持 Java 11，Java 现在更新越来越快，Spring 快赶不上了    
  ●升级 Thymeleaf Extras Springsecurity 到 3.0.4.RELEASE ，thymeleaf-extras-springsecurity 是 Thymeleaf 提供集成 Spring Security 的组件  
  ●升级 Joda Time 2.10.1，Joda-Time， 面向 Java 应用程序的日期/时间库的替代选择，Joda-Time 令时间和日期值变得易于管理、操作和理解。  
  ●升级 Lettuce 5.1.2.RELEASE ，Lettuce 前面说过，传说中 Redis 最快的客户端。  
  ●升级 Reactor Californium-SR2 ，Californium 是物联网云服务的 Java COAP 实现。因此，它更专注的是可扩展性和可用性而不是像嵌入式设备那样关注资源效率。不过，Californium 也适合嵌入式的 JVM。  
  ●升级 Maven Failsafe Plugin 2.22.1 ，Maven 中的测试插件。  
  ●升级 Flyway 5.2.1 ， Flyway是一款开源的数据库版本管理工具  
  ●升级 Aspectj 1.9.2 ，AspectJ 是 Java 中流行的 AOP（Aspect-oriented Programming）编程扩展框架，是 Eclipse 托管给 Apache 基金会的一个开源项目。  
  ●升级 Mysql 8.0.13 ，Mysql 支持到 8。  
  ●...  
  更多的详细内容可以参考这里：[Spring Boot 2.1 Release Notes](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.1-Release-Notes)
, 2018-12-12, 2021-05-21, 默认分类, Spring Boot 2, true, null, 62, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [8, JDK 8——聚合操作, &emsp;&emsp;在Java8版本中，JDK包含许多聚合操作（如平均值，总和，最小，最大，和计数），返回一个计算流stream的聚合结果。这些聚合操作被称为聚合操作。JDK除返回单个值的聚合操作外，还有很多聚合操作返回一个collection集合实例。很多的reduce操作执行特定的任务，如求平均值或按类别分组元素。  

**1. 聚合操作简介**

  在开发中，多数情况下会涉及到对集合、数组中元素的操作，在JDK 8之前都是通过普通的循环遍历出每一个元素，然后还会穿插一些if条件语句选择性的对元素进行查找、过滤、修改等操作，这种原始的操作方法虽然可行，但是代码量较大并且执行效率较低。  
  为此，JDK 8中新增了一个Stream接口，该接口可以将集合、数组的中的元素转换为Stream流的形式，并结合Lambda表达式的优势来进一步简化集合、数组中元素的查找、过滤、转换等操作，这一新功能就是JDK 8中的聚合操作。  
  在程序中，使用聚合操作没有绝对的语法规范，根据实际操作流程，主要可以分为以下3个步骤：  
  （1）将原始集合或者数组对象转换为Stream流对象；  
  （2）对Stream流对象中的元素进行一系列的过滤、查找等中间操作（Intermediate Operations），然后仍然返回一个Stream流对象；  
  （3）对Stream流进行遍历、统计、收集等终结操作（Terminal Operation），获取想要的结果。  
  接下来，就根据上面聚合操作的3个步骤，通过一个案例来演示聚合操作的基本用法，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example31 {
 4		public static void main(String[] args) {
 5	          // 创建一个List集合对象
 6			List<String> list = new ArrayList<>(); 
 7			list.add("张三");
 8			list.add("李四");
 9			list.add("张小明");
 10			list.add("张阳");
 11			// 1、创建一个Stream流对象
 12			Stream<String> stream = list.stream();
 13			// 2、对Stream流中的元素分别进行过滤、截取操作
 14		       Stream<String> stream2 = stream.filter(i -> i.startsWith("张"));
 15			Stream<String> stream3 = stream2.limit(2);
 16			// 3、对Stream流中的元素进行终结操作，进行遍历输出
 17			stream3.forEach(j -> System.out.println(j));
 18			System.out.println("=======");
 19	         // 通过链式表达式的形式完成聚合操作
 20			list.stream().filter(i -> i.startsWith("张"))
 21						 .limit(2)
 22						 .forEach(j -> System.out.println(j));
 23		}
 24	}
``` 
   运行结果如下图所示。
![alt](/article_img/lambda/3.jpg)
  上述示例代码中，先创建了一个List集合，然后根据聚合操作的3个步骤实现了集合对象的聚合操作，对集合中的元素使用Stream流的形式进行过滤（filter）、截取（limit），并进行遍历输出。其中第12~17行代码分步骤详细展示了聚合操作，而第20~22行代码是使用了链式表达式（调用有返回值的方法时不获取返回值而是直接再调用另一个方法）实现了聚合操作，该表达式的语法格式更简洁、高效，这种链式调用也被称为操作管道流。

**2. 创建Stream流对象**  
  在上一小节中，介绍了聚合操作的主要使用步骤，其中首要解决的问题就是创建Stream流对象。聚合操作针对的就是可迭代数据进行的操作，如集合、数组等，所以创建Stream流对象其实就是将集合、数组等通过一些方法转换为Stream流对象。  
  在Java中，集合对象有对应的集合类，可以通过集合类提供的静态方法创建Stream流对象，而数组数据却没有对应的数组类，所以必须通过其他方法创建Stream流对象。针对不同的源数据，Java提供了多种创建Stream流对象的方式，分别如下：  
  （1）所有的Collections集合都可以使用stream()静态方法获取Stream流对象；  
  （2）Stream接口的of()静态方法可以获取基本类型包装类数组、引用类型数组和单个元素的Stream流对象；  
  （3）Arrays数组工具类的stream()静态方法也可以获取数组元素的Stream流对象。  
  接下来，通过一个案例来学习聚合操作中如何创建Stream流对象，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example32 {
 4		public static void main(String[] args) {
 5	          // 创建一个数组
 6			Integer[] array = { 9, 8, 3, 5, 2 };       
 7	          // 将数组转换为List集合
 8			List<Integer> list = Arrays.asList(array); 
 9			// 1、使用集合对象的stream()静态方法创建Stream流对象
 10			Stream<Integer> stream = list.stream();
 11			stream.forEach(i -> System.out.print(i+" "));
 12			System.out.println();
 13			// 2、使用Stream接口的of()静态方法创建Stream流对象
 14			Stream<Integer> stream2 = Stream.of(array);
 15			stream2.forEach(i -> System.out.print(i+" "));
 16			System.out.println();
 17			// 3、使用Arrays数组工具类的stream()静态方法创建Stream流对象
 18			Stream<Integer> stream3 = Arrays.stream(array);
 19			stream3.forEach(i -> System.out.print(i+" "));
 20		}
 21	}
```  
  运行结果如下图所示。
![alt](/article_img/lambda/4.jpg)
  上述示例代码中，先创建了一个数组和一个集合，然后通过三种方式实现了Stream流对象的创建，并通过Stream流对象的forEach()方法结合Lambda表达式完成了集合和数组中元素的遍历。  

**小提示：**  
  在JDK 8中，只针对单列集合Collections接口对象提供了stream()静态方法获取Stream流对象，并未对Map集合提供相关方法获取Stream流对象，所以想要用Map集合创建Stream流对象必须先通过Map集合的keySet()、values()、entrySet()等方法将Map集合转换为单列Set集合，然后再使用单列集合的stream()静态方法获取对应键、值集合的Stream流对象。

, 2018-12-02, null, 默认分类, JDK 8,聚合操作, true, null, 34, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [9, 虚拟化容器技术——Docker运行机制介绍,   Docker是一个开源的应用容器引擎，它基于go语言开发，并遵从Apache2.0开源协议。使用Docker可以让开发者封装他们的应用以及依赖包到一个可移植的容器中，然后发布到任意的Linux机器上，也可以实现虚拟化。Docker容器完全使用沙箱机制，相互之间不会有任何接口，这保证了容器之间的安全性。  

**1. Docker的引擎介绍**

  Docker Engine（Docker引擎）是Docker的核心部分，使用的是客户端-服务器（C/S）架构模式，其主要组成部分如下图所示。
![alt](/article_img/docker/1.png)
  从上图可以看出，Docker Engine中包含了三个核心组件（docker CLI、REST API和docker daemon），这三个组件的具体说明如下：  
  ①docker CLI（command line interface）：表示Docker命令行接口，开发者可以在命令行中使用Docker相关指令与Docker守护进程进行交互，从而管理诸如image（镜像）、container（容器）、network（网络）和data volumes（数据卷）等实体。  
  ②REST API：表示应用程序API接口，开发者通过该API接口可以与Docker的守护进程进行交互，从而指示后台进行相关操作。  
  ③docker daemon：表示Docker的服务端组件，他是Docker架构中运行在后台的一个守护进程，可以接收并处理来自命令行接口及API接口的指令，然后进行相应的后台操作。  
  对于开发者而言，既可以使用编写好的脚本文件通过REST API来实现与Docker进程交互，又可以直接使用Docker相关指令通过命令行接口来与Docker进程交互，而其他一些Docker应用则是通过底层的API和CLI进行交互的。

**2. Docker的架构介绍**

  了解了Docker内部引擎及作用后，我们还需要通过Docker的具体架构，来了解Docker的整个运行流程。接下来借助Docker官网的架构图来对Docker架构进行详细说明，如下图所示。
![alt](/article_img/docker/2.jpg)
  从图中可以看出，Docker架构主要包括Client、DOCKER_HOST和Register三部分，关于这三部分的具体说明如下。  
&emsp;&emsp;**（1）Client（客户端）**  
  Client即Docker客户端，也就是上一小节Docker Engine中介绍的docker CLI。开发者通过这个客户端使用Docker的相关指令与Docker守护进程进行交互，从而进行Docker镜像的创建、拉取和运行等操作。  
&emsp;&emsp;**（2）DOCKER_HOST（Docker主机）**  
  DOCKER_HOST即Docker内部引擎运行的主机，主要指Docker daemon（Docker守护进程）。可以通过Docker守护进程与客户端还有Docker的镜像仓库Registry进行交互，从而管理Images（镜像）和Containers（容器）等。  
&emsp;&emsp;**（3）Registry（注册中心）**  
  Registry即Docker注册中心，实质就是Docker镜像仓库，默认使用的是Docker官方远程注册中心Docker Hub，也可以使用开发者搭建的本地仓库。Registry中包含了大量的镜像，这些镜像可以是官网基础镜像，也可以是其他开发者上传的镜像。  
  我们在实际使用Docker时，除了会涉及到图中的三个主要部分外，还会涉及到很多Docker Objects（Docker对象），例如Images（镜像）、Containers（容器）、Networks（网络）、Volumes（数据卷）、Plugins（插件）等。其中常用的两个对象Image和Containers的说明如下。  
  ①Images（镜像）  
  Docker 镜像就是一个只读的模板，包含了一些创建Docker容器的操作指令。通常情况下，一个Docker镜像是基于另一个基础镜像创建的，并且新创建的镜像会额外包含一些功能配置。例如：开发者可以依赖于一个Ubuntu的基础镜像创建一个新镜像，并可以在新镜像中安装Apache等软件或其它应用程序。  
  ②Containers（容器）  
  Docker容器属于镜像的一个可运行实例（镜像与容器的关系其实与Java中的类与对象相似），开发者可以通过API接口或者CLI命令行接口来创建、运行、停止、移动、删除一个容器，也可以将一个容器连接到一个或多个网络中，将数据存储与容器进行关联。



, 2018-12-03, null, 默认分类, 虚拟化容器,Docker,运行机制, true, null, 26, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [10, Docker常用客户端指令介绍,   在使用Docker之前，首先会为对应的项目编写Dockerfile镜像构建文件，然后通过Docker的相关指令进行镜像构建，完成镜像的构建后，就可以使用这些项目镜像进行启动测试了。所以要想知道如何使用Docker来执行这些Dockerfile镜像构建文件，还需要学习Docker客户端的常用指令，本篇文章将对Docker客户端的常用指令进行详细讲解。  

**1.列出镜像**  
  通过docker images指令可以查看本地镜像列表中已有的镜像，具体使用方式如下。
```js
$ docker images
```  
  执行上述指令后，系统会将所有本地镜像都展示出来，如下图所示。
![alt](/article_img/docker/3.png)
  从图中可以看出，系统终端将本地镜像列表中的3个镜像分5列进行了展示，每一列的具体含义如下。  
  ●REPOSITORY：镜像名称。  
  ●TAG：镜像的参数，类似于版本号，默认是latest。  
  ●IMAGE ID：镜像ID，是唯一值。此处看到的是一个长度为12的字符串，实际上它是64位完整镜像ID的缩写形式。  
  ●CREATED：距今创建镜像的时间。  
  ●SIZE：镜像大小。    

**2.搜索镜像**  
  想知道在Docker Hub中包含了哪些镜像，除了可以登录Docker Hub，在官网中心进行查看外，还可以直接在Docker客户端进行查询。例如想要查询Ubuntu镜像，可以使用如下指令。
```js
$ docker search ubuntu
```  
  执行上述指令后，系统终端就会将搜索到的有关Ubuntu的镜像展示出来，如下图所示。
![alt](/article_img/docker/4.png)
  从图所示的结果可以看出，系统终端分5列将搜索到的Ubuntu相关镜像都列举出来了，这5列的具体含义如下。  
  ●NAME：表示镜像的名称，这里有两种格式的名称，其中不带有“/”的表示官方镜像，而带有“/”的表示其他用户的公开镜像。公开镜像“/”前面是用户在Docker Hub上的用户名（唯一），后面是对应的镜像名；官方镜像与用户镜像，除了从镜像名称上可以区分外，还可以通过第4列的OFFICIAL声明中看出（该列下内容为OK表示官方镜像）。  
  ●DESCRIPTION：表示镜像的描述，这里只显示了一小部分。  
  ●STARS：表示该镜像的收藏数，用户可以在Docker Hub上对镜像进行收藏，一般可以通过该数字反应出该镜像的受欢迎程度。  
  ●OFFICIAL：表示是否为官方镜像。  
  ●AUTOMATED：表示是否自动构建镜像。例如，用户可以将自己的Docker Hub绑定到如Github上，当代码提交更新后，可以自动构建镜像。   
 
**3.拉取镜像**  
  通过docker pull指令可以拉取仓库镜像到本地（默认都是拉取Docker Hub仓库镜像，也可以指定“IP+端口”拉取某个Docker机器上的私有仓库镜像），具体使用方式如下。
```js
$ docker pull ubuntu
```  
  执行上述指令后，Docker会自动从Docker Hub上下载最新版本的Ubuntu到本地，当然也可以使用以下指令拉取指定版本的镜像到本地，具体指令如下。
```js
$ docker pull ubuntu:14.04
```  
**4.构建镜像**  
  除了可以通过docker pull指令从仓库拉取镜像外，还可以通过docker build指令构建Docker镜像，通常情况下都是通过Dockerfile文件来构建镜像的。  
  这里假设linux系统home目录下/shitou/workspace/dockerspace文件夹中编写有对应的Dockerfile文件，则构建镜像直立示例如下所示。 
```js
$ docker build -t hellodocker3 /home/shitou/workspace/dockerspace/.
```
**5.删除镜像**  
  当本地存放过多不需要的镜像时，可以通过docker rmi指令将其删除。在删除镜像时，需要指定镜像名称或镜像ID。删除镜像的使用方式如下。
```js
$ docker rmi -f hellodocker2 hellodocker3
```  
  上述指令中，docker rmi表示删除镜像，-f表示进行强制删除，而hellodocker2和hellodocker3分别表示需要删除的镜像名称，这里同时删除两个镜像。除了根据名称删除镜像外，还也可以根据镜像ID来删除镜像，只是这里如果指定了删除ID为23c617a866d4的镜像后，会同时删除hellodocker、hellodocker2和hellodocker3三个镜像。  
  需要特别强调的是，在进行镜像删除操作时，如果是通过镜像ID进行镜像删除，那么由该镜像创建的容器必须提前删除或停止。另外，在通过镜像名称操作镜像时，如果出现镜像重名的情况，必须在镜像名称后面指定镜像标签tag参数来确保唯一性。

**6.创建并启动容器**  
  Docker镜像主要用于创建容器，可以使用docker run指令创建并启动容器，具体使用方式如下。
```js
$ docker run -d -p 5000:80 --name test hellodocker
```  
  上述创建并启动容器的指令略微复杂，具体分析如下。  
  ●docker run：表示创建并启动一个容器，而后面的hellodocker就表示要启动运行的镜像名称；  
  ●-d：表示容器启动时在后台运行；  
  ●-p 5000:80：表示将容器内暴露的80端口映射到宿主机指定的5000端口，也可以将-p 5000:80更改为-P来映射主机的随机端口（注意p字母的大小写）；  
  ●--name test：表示为创建后的容器指定名称为test，如果没有该参数配置，则生成的容器会设置一个随机名称。  
  docker run命令是Docker操作中较为复杂的一个，它可以携带多个参数和参数，我们可以通过docker run --help指令进行查看，其中有些参数如-e、-v和-w等都可以在Dockerfile文件中预先声明。 
 
**7.列出容器**  
  生成容器后，可以通过docker ps指令查看当前运行的所有容器，具体使用方式如下。
```js
$ docker ps
```  
  执行上述命令后，会将所有当前运行的容器都展示出来，具体如下图所示。
![alt](/article_img/docker/5.png)
  从图中可以看出，系统终端通过7列对当前的正在运行的一个容器进行了展示，图中每一列的具体含义如下。  
  ●CONTAINER ID：表示生成的容器ID；  
  ●IMAGE：表示生成该容器的镜像名称；  
  ●COMMAND：表示启动容器时运行的命令，Docker要求在启动容器时必须运行一个命令；  
  ●CREATED：表示容器创建的时间；  
  ●STATUS：表示容器运行状态，例如Up表示运行中，Exited表示已停止；  
  ●PORTS：表示容器内部暴露的端口映射到主机的端口；  
  ●NAMES：表示生成容器的名称，由Docker引擎自动生成，可以像上述示例中使用--name参数指定生成容器的名称。  
  另外，docker ps指令运行过程中可以指定多个参数，还可以通过docker ps --help指令对ps指令的其他信息进行查看。

**8.删除容器**  
  当不需要使用容器时，则可以使用docker rm指令删除已停止的容器，具体使用方式如下。
```js
$ docker rm f0c9a8b6e8c5
```  
  需要注意的是，上述指令只能删除已经停止运行的容器，而不能删除正在运行的容器。如果想要删除正在运行的容器，则需要添加-f参数强制删除，具体使用方式如下。
```js
$ docker rm -f f0c9a8b6e8c5
```  
  当需要删除的容器过多时，如果还一个个的删除就略显麻烦了，此时可以通过如下指令将全部容器删除。
```js
$ docker rm -f $(docker ps -aq)
```  
  上述指令中，首先会通过$(docker ps -aq)获取所有容器的ID，然后通过docker rm -f指令进行强制删除。如果开发者有自己特殊的删除需求，可以根据前面docker ps指令进行组装来获取需要删除的容器ID。  
  Docker提供的操作指令远不止这些，这里就不一一列举了，想要了解更多Docker的操作指令，可以通过docker --help指令进行查看。


, 2018-12-05, null, 默认分类, Docker,客户端指令, true, null, 21, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [11, Docker数据管理介绍,   当我们对容器进行相关操作时，产生的一系列数据都会存储在容器中，而Docker内部又是如果管理这些数据的呢？本篇文章将针对Docker数据管理的一些知识进行介绍。
  
**1. Docker数据存储机制**  
  使用Docker时，我们操作的都是镜像和由镜像生成的容器，所以想要更好的了解Docker内部的数据存储机制，就必须从镜像、容器与数据存储的关系出发。  
  Docker镜像是通过读取Dockerfile文件中的指令构建的，Dockerfile中的每条指令都会创建一个镜像层，并且每层都是只读的，这一系列的镜像层就构成了Docker镜像。接下来以一个Dockerfile文件为例进行说明，具体如下列代码示例所示。
```js
 1	FROM ubuntu:16.04
 2	COPY . /app
 3	RUN make /app
 4	CMD python /app/app.py
```  
   上述文件示例中的Dockerfile包含了4条指令，每条指令都会创建一个镜像层，其中每一层与前一层都有所不同，并且是层层叠加的。通过镜像构建容器时，会在镜像层上增加一个容器层（即可写层），所有对容器的更改都会写入容器层，这也是Docker默认的数据存储方式。  
  下面通过一个效果图进行说明，具体如下图所示。
![alt](/article_img/docker/6.png)
  从图中可以看出，Docker容器和镜像之间的主要区别是顶部的容器层，而所有对容器中数据的添加、修改等操作都会被存储在容器层中。当容器被删除时，容器层也会被删除，其中存储的数据会被一同删除，而下面的镜像层却保持不变。  
  由于所有的容器都是通过镜像构建的，所以每个容器都有各自的容器层，对于容器数据的更改就会保存在各自的容器层中。也就是说，由同一个镜像构建的多个容器，它们会拥有相同的底部镜像层，而拥有不同的容器层，多个容器可以访问相同的镜像层，并且有自己的独立数据状态。具体说明如下图所示。 
![alt](/article_img/docker/7.png)
  从图中可以看出，基于同一个镜像构建的多个容器可以共享该镜像层，但是多个容器想要共享相同的数据，就需要将这些数据存储到容器之外的地方，而这种方式就是下一节要提到的Docker volume数据外部挂载机制。  

**2. Docker数据存储方式**    
  在默认情况下，Docker中的数据都是存放在容器层的，但是这样存储数据却有较多的缺陷，具体表现如下。    
  ●当容器不再运行时，容器中的数据无法持久化保存，如果另一个进程需要这些数据，那么将很难从容器中获取数据；  
  ●容器层与正在运行的主机紧密耦合，不能轻易地移动数据；  
  ●容器层需要一个存储驱动程序来管理文件系统，存储驱动程序提供了一个使用Linux内核的联合文件系统，这种额外的抽象化降低了性能。  
  基于上述种种原因，多数情况下Docker数据管理都不会直接将数据写入容器层，而是使用另一种叫做Docker volume数据外部挂载的机制进行数据管理。  
  针对Docker volume数据外部挂载机制，Docker提供了三种不同的方式将数据从容器映射到Docker宿主机，他们分别为：volumes（数据卷）、bind mounts（绑定挂载）和tmpfs mounts（tmpfs挂载）。这三种数据管理方式的具体选择，需要结合实际情况进行考虑，其中的volumes数据卷是最常用也是官方推荐的数据管理方式。无论选择使用哪种数据管理方式，数据在容器内看起来都一样的，而在容器外则会被被挂载到文件系统中的某个目录或文件中。    
  下面通过一张图来展示数据卷、绑定挂载和tmpfs挂载之间的差异，如下图所示。  
![alt](/article_img/docker/8.png)
  从图中可以看出，Docker提供的三种数据管理方式略有不同，具体分析如下。  
  ●volumes：存储在主机文件系统中（在Linux系统下是存在于/var/lib/Docker/volumes/目录），并由Docker管理，非Docker进程无法修改文件系统的这个部分。  
  ●bind mounts：可以存储在主机系统的任意位置，甚至可能是重要的系统文件或目录，在Docker主机或容器上的非Docker进程可以对他们进行任意修改。  
  ●tmpfs mounts：只存储在主机系统的内存中，并没有写入到主机的文件系统中。


, 2018-12-07, 2021-05-19, 默认分类, Docker,数据管理, true, null, 19, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [6, JDK 8——Lambda表达式介绍,   Lambda表达式是JDK 8中一个重要的新特性，它使用一个清晰简洁的表达式来表达一个接口，同时Lambda表达式也简化了对集合以及数组数据的遍历、过滤和提取等操作。下面，本篇文章就对Lambda表达式进行简要介绍，并进行演示说明。

**1. Lambda表达式入门**  

  匿名内部类存在的一个问题是，如果匿名内部类的实现非常简单，例如只包含一个抽象方法的接口，那么匿名内部类的语法仍然显得比较冗余。为此，JDK 8中新增了一个特性Lambda表达式，这种表达式只针对有一个抽象方法的接口实现，以简洁的表达式形式实现接口功能来作为方法参数。  
  一个Lambda表达式由三个部分组成，分别为参数列表、“->”和表达式主体，其语法格式如下：
```js
 ([数据类型 参数名,数据类型 参数名,...]) -> {表达式主体}
```  
  从上述语法格式上看，Lambda表达式的书写非常简单，下面针对Lambda表达式的组成部分进行简单介绍，具体如下：  
  （1）([数据类型 参数名,数据类型 参数名,...])：用来向表达式主体传递接口方法需要的参数，多个参数名中间必须用英文逗号“,”进行分隔；在编写Lambda表达式时，可以省略参数的数据类型，后面的表达式主体会自动进行校对和匹配；同时，如果只有一个参数，则可以省略括号“()”。  
  （2）->：表示Lambda表达式箭牌，用来指定参数数据指向，不能省略，且必须用英文横线和大于号书写。  
  （3）{表达式主体}：由单个表达式或语句块组成的主体，本质就是接口中抽象方法的具体实现，如果表达式主体只有一条语句，那么可以省略包含主体的大括号；另外，在Lambda表达式主体中允许有返回值，当只有一条return语句时，也可以省略return关键字。  
  了解了Lambda表达式的语法后，接下来编写一个示例文件对Lambda表达式的基本使用进行介绍，具体代码如下所示。
```js
 1	// 定义动物类接口
 2	interface Animal { 
 3		void shout(); // 定义方法shout()
 4	}
 5	public class Example22 {
 6		public static void main(String[] args) {
 7	       String name = "小花"; 
 8	       // 1、匿名内部类作为参数传递给animalShout()方法
 9		  animalShout(new Animal() { 
 10				 public void shout() { 
 11				    System.out.println("匿名内部类输出："+name+"喵喵...");
 12				}
 13		  });
 14		  // 2、使用Lambda表达式作为参数传递给animalShout()方法
 15	       animalShout(()-> System.out.println("Lambda表达式输出："
 16	                                                   +name+"喵喵..."));
 17		}
 18	    // 创建一个animalShout()静态方法，接收接口类型的参数
 19		public static void animalShout(Animal an) {
 20			an.shout();  
 21		}
 22	}
```  
  运行结果下图所示。
![alt](/article_img/lambda/1.jpg)
  上述代码示例中，先定义了只有一个抽象方法的接口Animal，然后分别使用匿名内部类和Lambda表达式的方式实现了接口方法。从图中可以看出，使用匿名内部类和Lambda表达式都能实现接口中方法，但很显然使用Lambda表达式更加简洁和清晰。, 2018-11-27, null, 默认分类, 2018,Lambda表达式, true, null, 18, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [7, 函数式接口, &emsp;&emsp;虽然Lambda表达式可以实现匿名内部类的功能，但在使用时却有一个局限，即接口中有且只有一个抽象方法时才能使用Lamdba表达式代替匿名内部类。这是因为Lamdba表达式是基于函数式接口实现的，所谓函数式接口是指有且仅有一个抽象方法的接口，Lambda表达式就是Java中函数式编程的体现，只有确保接口中有且仅有一个抽象方法，Lambda表达式才能顺利地推导出所实现的这个接口中的方法。  
&emsp;&emsp;在JDK 8中，专门为函数式接口引入了一个@FunctionalInterface注解，该注解只是显示的标注了接口是一个函数式接口，并强制编辑器进行更严格的检查，确保该接口是函数式接口，如果不是函数式接口，那么编译器就会报错，而对程序运行并没有实质上的影响。  
&emsp;&emsp;接下来通过一个案例来演示函数式接口的定义与使用，示例代码如下所示。
```js
 1	// 定义无参、无返回值的函数式接口
 2	@FunctionalInterface
 3	interface Animal {
 4		void shout();
 5	}
 6	// 定义有参、有返回值的函数式接口
 7	interface Calculate {
 8		int sum(int a, int b);
 9	}
 10	public class Example23 {
 11		public static void main(String[] args) {
 12		   // 分别两个函数式接口进行测试
 13		   animalShout(() -> System.out.println("无参、无返回值的函数式接口调用"));
 14		   showSum(10, 20, (x, y) -> x + y);
 15		}
 16		// 创建一个动物叫的方法，并传入接口对象Animal作为参数
 17		private static void animalShout(Animal animal) {
 18			animal.shout();
 19		}
 20		// 创建一个求和的方法，并传入两个int类型以及接口Calculate类型的参数
 21		private static void showSum(int x, int y, Calculate calculate) {
 22		   System.out.println(x + "+" + y + "的和为：" + calculate.sum(x, y));
 23		}
 24	}
```  
&emsp;&emsp;运行结果如下图所示。

![alt](/article_img/lambda/2.jpg)
&emsp;&emsp;上述代码示例中，先定义了两个函数式接口Animal和Calculate，然后在测试类中分别编写了两个静态方法，并将这两个函数式接口以参数的形式传入，最后在main()方法中分别调用这两个静态方法，并将所需要的函数式接口参数以Lambda表达式的形式传入。从图中可以看出，程序中函数式接口的定义和使用完全正确。
, 2018-12-01, null, 默认分类, 接口,函数式接口, true, null, 12, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} connected
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} executed. 7.1552 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 108, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [12, Spring Boot 2 权威发布,   如果这两天登录 [https://start.spring.io/ ](https://start.spring.io/ )就会发现，Spring Boot 默认版本已经升到了 2.1.0。这是因为 Spring Boot 刚刚发布了 2.1.0 版本，我们来看下 Spring Boot 2 发布以来第一个子版本都发布了哪些内容？  

**2.1 中的新特性**     
  ●将spring-boot-starter-oauth2-oidc-client重命名为spring-boot-starter-oauth2-client命名更简洁  
  ●添加 OAuth2 资源服务 starter，OAuth2 一个用于认证的组件  
  ●支持 ConditionalOnBean 和 ConditionalOnMissingBean 下的参数化容器  
  ●自动配置 applicationTaskExecutor bean 的延迟加载来避免不必要的日志记录  
  ●将 DatabaseDriver＃SAP 重命名为 DatabaseDriver  
  ●跳过重启器不仅适用于 JUnit4，也适用于 JUnit5  
  ●在 Jest HealthIndicator 中使用集群端点  
  ●当 DevTools 禁用重启时添加日志输出  
  ●添加注解：@ConditionalOnMissingServletFilter提高 Servlet Filters 的自动装配。
  
**2.1 中的组件升级**  
  ●升级 Hibernate 5.3，Hibernate 的支持升级到了 5.3  
  ●升级 Tomcat 9 ，支持最新的 tomcat 9  
  ●支持 Java 11，Java 现在更新越来越快，Spring 快赶不上了    
  ●升级 Thymeleaf Extras Springsecurity 到 3.0.4.RELEASE ，thymeleaf-extras-springsecurity 是 Thymeleaf 提供集成 Spring Security 的组件  
  ●升级 Joda Time 2.10.1，Joda-Time， 面向 Java 应用程序的日期/时间库的替代选择，Joda-Time 令时间和日期值变得易于管理、操作和理解。  
  ●升级 Lettuce 5.1.2.RELEASE ，Lettuce 前面说过，传说中 Redis 最快的客户端。  
  ●升级 Reactor Californium-SR2 ，Californium 是物联网云服务的 Java COAP 实现。因此，它更专注的是可扩展性和可用性而不是像嵌入式设备那样关注资源效率。不过，Californium 也适合嵌入式的 JVM。  
  ●升级 Maven Failsafe Plugin 2.22.1 ，Maven 中的测试插件。  
  ●升级 Flyway 5.2.1 ， Flyway是一款开源的数据库版本管理工具  
  ●升级 Aspectj 1.9.2 ，AspectJ 是 Java 中流行的 AOP（Aspect-oriented Programming）编程扩展框架，是 Eclipse 托管给 Apache 基金会的一个开源项目。  
  ●升级 Mysql 8.0.13 ，Mysql 支持到 8。  
  ●...  
  更多的详细内容可以参考这里：[Spring Boot 2.1 Release Notes](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.1-Release-Notes)
, 2018-12-12, 2021-05-21, 默认分类, Spring Boot 2, true, null, 62, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [8, JDK 8——聚合操作, &emsp;&emsp;在Java8版本中，JDK包含许多聚合操作（如平均值，总和，最小，最大，和计数），返回一个计算流stream的聚合结果。这些聚合操作被称为聚合操作。JDK除返回单个值的聚合操作外，还有很多聚合操作返回一个collection集合实例。很多的reduce操作执行特定的任务，如求平均值或按类别分组元素。  

**1. 聚合操作简介**

  在开发中，多数情况下会涉及到对集合、数组中元素的操作，在JDK 8之前都是通过普通的循环遍历出每一个元素，然后还会穿插一些if条件语句选择性的对元素进行查找、过滤、修改等操作，这种原始的操作方法虽然可行，但是代码量较大并且执行效率较低。  
  为此，JDK 8中新增了一个Stream接口，该接口可以将集合、数组的中的元素转换为Stream流的形式，并结合Lambda表达式的优势来进一步简化集合、数组中元素的查找、过滤、转换等操作，这一新功能就是JDK 8中的聚合操作。  
  在程序中，使用聚合操作没有绝对的语法规范，根据实际操作流程，主要可以分为以下3个步骤：  
  （1）将原始集合或者数组对象转换为Stream流对象；  
  （2）对Stream流对象中的元素进行一系列的过滤、查找等中间操作（Intermediate Operations），然后仍然返回一个Stream流对象；  
  （3）对Stream流进行遍历、统计、收集等终结操作（Terminal Operation），获取想要的结果。  
  接下来，就根据上面聚合操作的3个步骤，通过一个案例来演示聚合操作的基本用法，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example31 {
 4		public static void main(String[] args) {
 5	          // 创建一个List集合对象
 6			List<String> list = new ArrayList<>(); 
 7			list.add("张三");
 8			list.add("李四");
 9			list.add("张小明");
 10			list.add("张阳");
 11			// 1、创建一个Stream流对象
 12			Stream<String> stream = list.stream();
 13			// 2、对Stream流中的元素分别进行过滤、截取操作
 14		       Stream<String> stream2 = stream.filter(i -> i.startsWith("张"));
 15			Stream<String> stream3 = stream2.limit(2);
 16			// 3、对Stream流中的元素进行终结操作，进行遍历输出
 17			stream3.forEach(j -> System.out.println(j));
 18			System.out.println("=======");
 19	         // 通过链式表达式的形式完成聚合操作
 20			list.stream().filter(i -> i.startsWith("张"))
 21						 .limit(2)
 22						 .forEach(j -> System.out.println(j));
 23		}
 24	}
``` 
   运行结果如下图所示。
![alt](/article_img/lambda/3.jpg)
  上述示例代码中，先创建了一个List集合，然后根据聚合操作的3个步骤实现了集合对象的聚合操作，对集合中的元素使用Stream流的形式进行过滤（filter）、截取（limit），并进行遍历输出。其中第12~17行代码分步骤详细展示了聚合操作，而第20~22行代码是使用了链式表达式（调用有返回值的方法时不获取返回值而是直接再调用另一个方法）实现了聚合操作，该表达式的语法格式更简洁、高效，这种链式调用也被称为操作管道流。

**2. 创建Stream流对象**  
  在上一小节中，介绍了聚合操作的主要使用步骤，其中首要解决的问题就是创建Stream流对象。聚合操作针对的就是可迭代数据进行的操作，如集合、数组等，所以创建Stream流对象其实就是将集合、数组等通过一些方法转换为Stream流对象。  
  在Java中，集合对象有对应的集合类，可以通过集合类提供的静态方法创建Stream流对象，而数组数据却没有对应的数组类，所以必须通过其他方法创建Stream流对象。针对不同的源数据，Java提供了多种创建Stream流对象的方式，分别如下：  
  （1）所有的Collections集合都可以使用stream()静态方法获取Stream流对象；  
  （2）Stream接口的of()静态方法可以获取基本类型包装类数组、引用类型数组和单个元素的Stream流对象；  
  （3）Arrays数组工具类的stream()静态方法也可以获取数组元素的Stream流对象。  
  接下来，通过一个案例来学习聚合操作中如何创建Stream流对象，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example32 {
 4		public static void main(String[] args) {
 5	          // 创建一个数组
 6			Integer[] array = { 9, 8, 3, 5, 2 };       
 7	          // 将数组转换为List集合
 8			List<Integer> list = Arrays.asList(array); 
 9			// 1、使用集合对象的stream()静态方法创建Stream流对象
 10			Stream<Integer> stream = list.stream();
 11			stream.forEach(i -> System.out.print(i+" "));
 12			System.out.println();
 13			// 2、使用Stream接口的of()静态方法创建Stream流对象
 14			Stream<Integer> stream2 = Stream.of(array);
 15			stream2.forEach(i -> System.out.print(i+" "));
 16			System.out.println();
 17			// 3、使用Arrays数组工具类的stream()静态方法创建Stream流对象
 18			Stream<Integer> stream3 = Arrays.stream(array);
 19			stream3.forEach(i -> System.out.print(i+" "));
 20		}
 21	}
```  
  运行结果如下图所示。
![alt](/article_img/lambda/4.jpg)
  上述示例代码中，先创建了一个数组和一个集合，然后通过三种方式实现了Stream流对象的创建，并通过Stream流对象的forEach()方法结合Lambda表达式完成了集合和数组中元素的遍历。  

**小提示：**  
  在JDK 8中，只针对单列集合Collections接口对象提供了stream()静态方法获取Stream流对象，并未对Map集合提供相关方法获取Stream流对象，所以想要用Map集合创建Stream流对象必须先通过Map集合的keySet()、values()、entrySet()等方法将Map集合转换为单列Set集合，然后再使用单列集合的stream()静态方法获取对应键、值集合的Stream流对象。

, 2018-12-02, null, 默认分类, JDK 8,聚合操作, true, null, 34, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [9, 虚拟化容器技术——Docker运行机制介绍,   Docker是一个开源的应用容器引擎，它基于go语言开发，并遵从Apache2.0开源协议。使用Docker可以让开发者封装他们的应用以及依赖包到一个可移植的容器中，然后发布到任意的Linux机器上，也可以实现虚拟化。Docker容器完全使用沙箱机制，相互之间不会有任何接口，这保证了容器之间的安全性。  

**1. Docker的引擎介绍**

  Docker Engine（Docker引擎）是Docker的核心部分，使用的是客户端-服务器（C/S）架构模式，其主要组成部分如下图所示。
![alt](/article_img/docker/1.png)
  从上图可以看出，Docker Engine中包含了三个核心组件（docker CLI、REST API和docker daemon），这三个组件的具体说明如下：  
  ①docker CLI（command line interface）：表示Docker命令行接口，开发者可以在命令行中使用Docker相关指令与Docker守护进程进行交互，从而管理诸如image（镜像）、container（容器）、network（网络）和data volumes（数据卷）等实体。  
  ②REST API：表示应用程序API接口，开发者通过该API接口可以与Docker的守护进程进行交互，从而指示后台进行相关操作。  
  ③docker daemon：表示Docker的服务端组件，他是Docker架构中运行在后台的一个守护进程，可以接收并处理来自命令行接口及API接口的指令，然后进行相应的后台操作。  
  对于开发者而言，既可以使用编写好的脚本文件通过REST API来实现与Docker进程交互，又可以直接使用Docker相关指令通过命令行接口来与Docker进程交互，而其他一些Docker应用则是通过底层的API和CLI进行交互的。

**2. Docker的架构介绍**

  了解了Docker内部引擎及作用后，我们还需要通过Docker的具体架构，来了解Docker的整个运行流程。接下来借助Docker官网的架构图来对Docker架构进行详细说明，如下图所示。
![alt](/article_img/docker/2.jpg)
  从图中可以看出，Docker架构主要包括Client、DOCKER_HOST和Register三部分，关于这三部分的具体说明如下。  
&emsp;&emsp;**（1）Client（客户端）**  
  Client即Docker客户端，也就是上一小节Docker Engine中介绍的docker CLI。开发者通过这个客户端使用Docker的相关指令与Docker守护进程进行交互，从而进行Docker镜像的创建、拉取和运行等操作。  
&emsp;&emsp;**（2）DOCKER_HOST（Docker主机）**  
  DOCKER_HOST即Docker内部引擎运行的主机，主要指Docker daemon（Docker守护进程）。可以通过Docker守护进程与客户端还有Docker的镜像仓库Registry进行交互，从而管理Images（镜像）和Containers（容器）等。  
&emsp;&emsp;**（3）Registry（注册中心）**  
  Registry即Docker注册中心，实质就是Docker镜像仓库，默认使用的是Docker官方远程注册中心Docker Hub，也可以使用开发者搭建的本地仓库。Registry中包含了大量的镜像，这些镜像可以是官网基础镜像，也可以是其他开发者上传的镜像。  
  我们在实际使用Docker时，除了会涉及到图中的三个主要部分外，还会涉及到很多Docker Objects（Docker对象），例如Images（镜像）、Containers（容器）、Networks（网络）、Volumes（数据卷）、Plugins（插件）等。其中常用的两个对象Image和Containers的说明如下。  
  ①Images（镜像）  
  Docker 镜像就是一个只读的模板，包含了一些创建Docker容器的操作指令。通常情况下，一个Docker镜像是基于另一个基础镜像创建的，并且新创建的镜像会额外包含一些功能配置。例如：开发者可以依赖于一个Ubuntu的基础镜像创建一个新镜像，并可以在新镜像中安装Apache等软件或其它应用程序。  
  ②Containers（容器）  
  Docker容器属于镜像的一个可运行实例（镜像与容器的关系其实与Java中的类与对象相似），开发者可以通过API接口或者CLI命令行接口来创建、运行、停止、移动、删除一个容器，也可以将一个容器连接到一个或多个网络中，将数据存储与容器进行关联。



, 2018-12-03, null, 默认分类, 虚拟化容器,Docker,运行机制, true, null, 26, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [10, Docker常用客户端指令介绍,   在使用Docker之前，首先会为对应的项目编写Dockerfile镜像构建文件，然后通过Docker的相关指令进行镜像构建，完成镜像的构建后，就可以使用这些项目镜像进行启动测试了。所以要想知道如何使用Docker来执行这些Dockerfile镜像构建文件，还需要学习Docker客户端的常用指令，本篇文章将对Docker客户端的常用指令进行详细讲解。  

**1.列出镜像**  
  通过docker images指令可以查看本地镜像列表中已有的镜像，具体使用方式如下。
```js
$ docker images
```  
  执行上述指令后，系统会将所有本地镜像都展示出来，如下图所示。
![alt](/article_img/docker/3.png)
  从图中可以看出，系统终端将本地镜像列表中的3个镜像分5列进行了展示，每一列的具体含义如下。  
  ●REPOSITORY：镜像名称。  
  ●TAG：镜像的参数，类似于版本号，默认是latest。  
  ●IMAGE ID：镜像ID，是唯一值。此处看到的是一个长度为12的字符串，实际上它是64位完整镜像ID的缩写形式。  
  ●CREATED：距今创建镜像的时间。  
  ●SIZE：镜像大小。    

**2.搜索镜像**  
  想知道在Docker Hub中包含了哪些镜像，除了可以登录Docker Hub，在官网中心进行查看外，还可以直接在Docker客户端进行查询。例如想要查询Ubuntu镜像，可以使用如下指令。
```js
$ docker search ubuntu
```  
  执行上述指令后，系统终端就会将搜索到的有关Ubuntu的镜像展示出来，如下图所示。
![alt](/article_img/docker/4.png)
  从图所示的结果可以看出，系统终端分5列将搜索到的Ubuntu相关镜像都列举出来了，这5列的具体含义如下。  
  ●NAME：表示镜像的名称，这里有两种格式的名称，其中不带有“/”的表示官方镜像，而带有“/”的表示其他用户的公开镜像。公开镜像“/”前面是用户在Docker Hub上的用户名（唯一），后面是对应的镜像名；官方镜像与用户镜像，除了从镜像名称上可以区分外，还可以通过第4列的OFFICIAL声明中看出（该列下内容为OK表示官方镜像）。  
  ●DESCRIPTION：表示镜像的描述，这里只显示了一小部分。  
  ●STARS：表示该镜像的收藏数，用户可以在Docker Hub上对镜像进行收藏，一般可以通过该数字反应出该镜像的受欢迎程度。  
  ●OFFICIAL：表示是否为官方镜像。  
  ●AUTOMATED：表示是否自动构建镜像。例如，用户可以将自己的Docker Hub绑定到如Github上，当代码提交更新后，可以自动构建镜像。   
 
**3.拉取镜像**  
  通过docker pull指令可以拉取仓库镜像到本地（默认都是拉取Docker Hub仓库镜像，也可以指定“IP+端口”拉取某个Docker机器上的私有仓库镜像），具体使用方式如下。
```js
$ docker pull ubuntu
```  
  执行上述指令后，Docker会自动从Docker Hub上下载最新版本的Ubuntu到本地，当然也可以使用以下指令拉取指定版本的镜像到本地，具体指令如下。
```js
$ docker pull ubuntu:14.04
```  
**4.构建镜像**  
  除了可以通过docker pull指令从仓库拉取镜像外，还可以通过docker build指令构建Docker镜像，通常情况下都是通过Dockerfile文件来构建镜像的。  
  这里假设linux系统home目录下/shitou/workspace/dockerspace文件夹中编写有对应的Dockerfile文件，则构建镜像直立示例如下所示。 
```js
$ docker build -t hellodocker3 /home/shitou/workspace/dockerspace/.
```
**5.删除镜像**  
  当本地存放过多不需要的镜像时，可以通过docker rmi指令将其删除。在删除镜像时，需要指定镜像名称或镜像ID。删除镜像的使用方式如下。
```js
$ docker rmi -f hellodocker2 hellodocker3
```  
  上述指令中，docker rmi表示删除镜像，-f表示进行强制删除，而hellodocker2和hellodocker3分别表示需要删除的镜像名称，这里同时删除两个镜像。除了根据名称删除镜像外，还也可以根据镜像ID来删除镜像，只是这里如果指定了删除ID为23c617a866d4的镜像后，会同时删除hellodocker、hellodocker2和hellodocker3三个镜像。  
  需要特别强调的是，在进行镜像删除操作时，如果是通过镜像ID进行镜像删除，那么由该镜像创建的容器必须提前删除或停止。另外，在通过镜像名称操作镜像时，如果出现镜像重名的情况，必须在镜像名称后面指定镜像标签tag参数来确保唯一性。

**6.创建并启动容器**  
  Docker镜像主要用于创建容器，可以使用docker run指令创建并启动容器，具体使用方式如下。
```js
$ docker run -d -p 5000:80 --name test hellodocker
```  
  上述创建并启动容器的指令略微复杂，具体分析如下。  
  ●docker run：表示创建并启动一个容器，而后面的hellodocker就表示要启动运行的镜像名称；  
  ●-d：表示容器启动时在后台运行；  
  ●-p 5000:80：表示将容器内暴露的80端口映射到宿主机指定的5000端口，也可以将-p 5000:80更改为-P来映射主机的随机端口（注意p字母的大小写）；  
  ●--name test：表示为创建后的容器指定名称为test，如果没有该参数配置，则生成的容器会设置一个随机名称。  
  docker run命令是Docker操作中较为复杂的一个，它可以携带多个参数和参数，我们可以通过docker run --help指令进行查看，其中有些参数如-e、-v和-w等都可以在Dockerfile文件中预先声明。 
 
**7.列出容器**  
  生成容器后，可以通过docker ps指令查看当前运行的所有容器，具体使用方式如下。
```js
$ docker ps
```  
  执行上述命令后，会将所有当前运行的容器都展示出来，具体如下图所示。
![alt](/article_img/docker/5.png)
  从图中可以看出，系统终端通过7列对当前的正在运行的一个容器进行了展示，图中每一列的具体含义如下。  
  ●CONTAINER ID：表示生成的容器ID；  
  ●IMAGE：表示生成该容器的镜像名称；  
  ●COMMAND：表示启动容器时运行的命令，Docker要求在启动容器时必须运行一个命令；  
  ●CREATED：表示容器创建的时间；  
  ●STATUS：表示容器运行状态，例如Up表示运行中，Exited表示已停止；  
  ●PORTS：表示容器内部暴露的端口映射到主机的端口；  
  ●NAMES：表示生成容器的名称，由Docker引擎自动生成，可以像上述示例中使用--name参数指定生成容器的名称。  
  另外，docker ps指令运行过程中可以指定多个参数，还可以通过docker ps --help指令对ps指令的其他信息进行查看。

**8.删除容器**  
  当不需要使用容器时，则可以使用docker rm指令删除已停止的容器，具体使用方式如下。
```js
$ docker rm f0c9a8b6e8c5
```  
  需要注意的是，上述指令只能删除已经停止运行的容器，而不能删除正在运行的容器。如果想要删除正在运行的容器，则需要添加-f参数强制删除，具体使用方式如下。
```js
$ docker rm -f f0c9a8b6e8c5
```  
  当需要删除的容器过多时，如果还一个个的删除就略显麻烦了，此时可以通过如下指令将全部容器删除。
```js
$ docker rm -f $(docker ps -aq)
```  
  上述指令中，首先会通过$(docker ps -aq)获取所有容器的ID，然后通过docker rm -f指令进行强制删除。如果开发者有自己特殊的删除需求，可以根据前面docker ps指令进行组装来获取需要删除的容器ID。  
  Docker提供的操作指令远不止这些，这里就不一一列举了，想要了解更多Docker的操作指令，可以通过docker --help指令进行查看。


, 2018-12-05, null, 默认分类, Docker,客户端指令, true, null, 21, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [11, Docker数据管理介绍,   当我们对容器进行相关操作时，产生的一系列数据都会存储在容器中，而Docker内部又是如果管理这些数据的呢？本篇文章将针对Docker数据管理的一些知识进行介绍。
  
**1. Docker数据存储机制**  
  使用Docker时，我们操作的都是镜像和由镜像生成的容器，所以想要更好的了解Docker内部的数据存储机制，就必须从镜像、容器与数据存储的关系出发。  
  Docker镜像是通过读取Dockerfile文件中的指令构建的，Dockerfile中的每条指令都会创建一个镜像层，并且每层都是只读的，这一系列的镜像层就构成了Docker镜像。接下来以一个Dockerfile文件为例进行说明，具体如下列代码示例所示。
```js
 1	FROM ubuntu:16.04
 2	COPY . /app
 3	RUN make /app
 4	CMD python /app/app.py
```  
   上述文件示例中的Dockerfile包含了4条指令，每条指令都会创建一个镜像层，其中每一层与前一层都有所不同，并且是层层叠加的。通过镜像构建容器时，会在镜像层上增加一个容器层（即可写层），所有对容器的更改都会写入容器层，这也是Docker默认的数据存储方式。  
  下面通过一个效果图进行说明，具体如下图所示。
![alt](/article_img/docker/6.png)
  从图中可以看出，Docker容器和镜像之间的主要区别是顶部的容器层，而所有对容器中数据的添加、修改等操作都会被存储在容器层中。当容器被删除时，容器层也会被删除，其中存储的数据会被一同删除，而下面的镜像层却保持不变。  
  由于所有的容器都是通过镜像构建的，所以每个容器都有各自的容器层，对于容器数据的更改就会保存在各自的容器层中。也就是说，由同一个镜像构建的多个容器，它们会拥有相同的底部镜像层，而拥有不同的容器层，多个容器可以访问相同的镜像层，并且有自己的独立数据状态。具体说明如下图所示。 
![alt](/article_img/docker/7.png)
  从图中可以看出，基于同一个镜像构建的多个容器可以共享该镜像层，但是多个容器想要共享相同的数据，就需要将这些数据存储到容器之外的地方，而这种方式就是下一节要提到的Docker volume数据外部挂载机制。  

**2. Docker数据存储方式**    
  在默认情况下，Docker中的数据都是存放在容器层的，但是这样存储数据却有较多的缺陷，具体表现如下。    
  ●当容器不再运行时，容器中的数据无法持久化保存，如果另一个进程需要这些数据，那么将很难从容器中获取数据；  
  ●容器层与正在运行的主机紧密耦合，不能轻易地移动数据；  
  ●容器层需要一个存储驱动程序来管理文件系统，存储驱动程序提供了一个使用Linux内核的联合文件系统，这种额外的抽象化降低了性能。  
  基于上述种种原因，多数情况下Docker数据管理都不会直接将数据写入容器层，而是使用另一种叫做Docker volume数据外部挂载的机制进行数据管理。  
  针对Docker volume数据外部挂载机制，Docker提供了三种不同的方式将数据从容器映射到Docker宿主机，他们分别为：volumes（数据卷）、bind mounts（绑定挂载）和tmpfs mounts（tmpfs挂载）。这三种数据管理方式的具体选择，需要结合实际情况进行考虑，其中的volumes数据卷是最常用也是官方推荐的数据管理方式。无论选择使用哪种数据管理方式，数据在容器内看起来都一样的，而在容器外则会被被挂载到文件系统中的某个目录或文件中。    
  下面通过一张图来展示数据卷、绑定挂载和tmpfs挂载之间的差异，如下图所示。  
![alt](/article_img/docker/8.png)
  从图中可以看出，Docker提供的三种数据管理方式略有不同，具体分析如下。  
  ●volumes：存储在主机文件系统中（在Linux系统下是存在于/var/lib/Docker/volumes/目录），并由Docker管理，非Docker进程无法修改文件系统的这个部分。  
  ●bind mounts：可以存储在主机系统的任意位置，甚至可能是重要的系统文件或目录，在Docker主机或容器上的非Docker进程可以对他们进行任意修改。  
  ●tmpfs mounts：只存储在主机系统的内存中，并没有写入到主机的文件系统中。


, 2018-12-07, 2021-05-19, 默认分类, Docker,数据管理, true, null, 19, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [6, JDK 8——Lambda表达式介绍,   Lambda表达式是JDK 8中一个重要的新特性，它使用一个清晰简洁的表达式来表达一个接口，同时Lambda表达式也简化了对集合以及数组数据的遍历、过滤和提取等操作。下面，本篇文章就对Lambda表达式进行简要介绍，并进行演示说明。

**1. Lambda表达式入门**  

  匿名内部类存在的一个问题是，如果匿名内部类的实现非常简单，例如只包含一个抽象方法的接口，那么匿名内部类的语法仍然显得比较冗余。为此，JDK 8中新增了一个特性Lambda表达式，这种表达式只针对有一个抽象方法的接口实现，以简洁的表达式形式实现接口功能来作为方法参数。  
  一个Lambda表达式由三个部分组成，分别为参数列表、“->”和表达式主体，其语法格式如下：
```js
 ([数据类型 参数名,数据类型 参数名,...]) -> {表达式主体}
```  
  从上述语法格式上看，Lambda表达式的书写非常简单，下面针对Lambda表达式的组成部分进行简单介绍，具体如下：  
  （1）([数据类型 参数名,数据类型 参数名,...])：用来向表达式主体传递接口方法需要的参数，多个参数名中间必须用英文逗号“,”进行分隔；在编写Lambda表达式时，可以省略参数的数据类型，后面的表达式主体会自动进行校对和匹配；同时，如果只有一个参数，则可以省略括号“()”。  
  （2）->：表示Lambda表达式箭牌，用来指定参数数据指向，不能省略，且必须用英文横线和大于号书写。  
  （3）{表达式主体}：由单个表达式或语句块组成的主体，本质就是接口中抽象方法的具体实现，如果表达式主体只有一条语句，那么可以省略包含主体的大括号；另外，在Lambda表达式主体中允许有返回值，当只有一条return语句时，也可以省略return关键字。  
  了解了Lambda表达式的语法后，接下来编写一个示例文件对Lambda表达式的基本使用进行介绍，具体代码如下所示。
```js
 1	// 定义动物类接口
 2	interface Animal { 
 3		void shout(); // 定义方法shout()
 4	}
 5	public class Example22 {
 6		public static void main(String[] args) {
 7	       String name = "小花"; 
 8	       // 1、匿名内部类作为参数传递给animalShout()方法
 9		  animalShout(new Animal() { 
 10				 public void shout() { 
 11				    System.out.println("匿名内部类输出："+name+"喵喵...");
 12				}
 13		  });
 14		  // 2、使用Lambda表达式作为参数传递给animalShout()方法
 15	       animalShout(()-> System.out.println("Lambda表达式输出："
 16	                                                   +name+"喵喵..."));
 17		}
 18	    // 创建一个animalShout()静态方法，接收接口类型的参数
 19		public static void animalShout(Animal an) {
 20			an.shout();  
 21		}
 22	}
```  
  运行结果下图所示。
![alt](/article_img/lambda/1.jpg)
  上述代码示例中，先定义了只有一个抽象方法的接口Animal，然后分别使用匿名内部类和Lambda表达式的方式实现了接口方法。从图中可以看出，使用匿名内部类和Lambda表达式都能实现接口中方法，但很显然使用Lambda表达式更加简洁和清晰。, 2018-11-27, null, 默认分类, 2018,Lambda表达式, true, null, 18, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [7, 函数式接口, &emsp;&emsp;虽然Lambda表达式可以实现匿名内部类的功能，但在使用时却有一个局限，即接口中有且只有一个抽象方法时才能使用Lamdba表达式代替匿名内部类。这是因为Lamdba表达式是基于函数式接口实现的，所谓函数式接口是指有且仅有一个抽象方法的接口，Lambda表达式就是Java中函数式编程的体现，只有确保接口中有且仅有一个抽象方法，Lambda表达式才能顺利地推导出所实现的这个接口中的方法。  
&emsp;&emsp;在JDK 8中，专门为函数式接口引入了一个@FunctionalInterface注解，该注解只是显示的标注了接口是一个函数式接口，并强制编辑器进行更严格的检查，确保该接口是函数式接口，如果不是函数式接口，那么编译器就会报错，而对程序运行并没有实质上的影响。  
&emsp;&emsp;接下来通过一个案例来演示函数式接口的定义与使用，示例代码如下所示。
```js
 1	// 定义无参、无返回值的函数式接口
 2	@FunctionalInterface
 3	interface Animal {
 4		void shout();
 5	}
 6	// 定义有参、有返回值的函数式接口
 7	interface Calculate {
 8		int sum(int a, int b);
 9	}
 10	public class Example23 {
 11		public static void main(String[] args) {
 12		   // 分别两个函数式接口进行测试
 13		   animalShout(() -> System.out.println("无参、无返回值的函数式接口调用"));
 14		   showSum(10, 20, (x, y) -> x + y);
 15		}
 16		// 创建一个动物叫的方法，并传入接口对象Animal作为参数
 17		private static void animalShout(Animal animal) {
 18			animal.shout();
 19		}
 20		// 创建一个求和的方法，并传入两个int类型以及接口Calculate类型的参数
 21		private static void showSum(int x, int y, Calculate calculate) {
 22		   System.out.println(x + "+" + y + "的和为：" + calculate.sum(x, y));
 23		}
 24	}
```  
&emsp;&emsp;运行结果如下图所示。

![alt](/article_img/lambda/2.jpg)
&emsp;&emsp;上述代码示例中，先定义了两个函数式接口Animal和Calculate，然后在测试类中分别编写了两个静态方法，并将这两个函数式接口以参数的形式传入，最后在main()方法中分别调用这两个静态方法，并将所需要的函数式接口参数以Lambda表达式的形式传入。从图中可以看出，程序中函数式接口的定义和使用完全正确。
, 2018-12-01, null, 默认分类, 接口,函数式接口, true, null, 12, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} created. update t_statistic set hits = hits+1 where article_id=?;
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} Parameters : [8]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} executed. 3.418 millis. update t_statistic set hits = hits+1 where article_id=?;
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} created. select * from t_comment where article_id=?
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} Parameters : [8]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} executed. 2.0907 millis. select * from t_comment where article_id=?
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50001} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50001} Header: [id, article_id, created, ip, c_content, status, author]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50001} Result: [14, 8, 2018-12-13, 0:0:0:0:0:0:0:1, very good blog, approved, tom]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50001} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20003} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail
    FROM
    t_article
    WHERE
	t_article.id = ?
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20003} Parameters : [8]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20003} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20003} executed. 0.9038 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail
    FROM
    t_article
    WHERE
	t_article.id = ?
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20003, rs-50002} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20003, rs-50002} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20003, rs-50002} Result: [8, JDK 8——聚合操作, &emsp;&emsp;在Java8版本中，JDK包含许多聚合操作（如平均值，总和，最小，最大，和计数），返回一个计算流stream的聚合结果。这些聚合操作被称为聚合操作。JDK除返回单个值的聚合操作外，还有很多聚合操作返回一个collection集合实例。很多的reduce操作执行特定的任务，如求平均值或按类别分组元素。  

**1. 聚合操作简介**

  在开发中，多数情况下会涉及到对集合、数组中元素的操作，在JDK 8之前都是通过普通的循环遍历出每一个元素，然后还会穿插一些if条件语句选择性的对元素进行查找、过滤、修改等操作，这种原始的操作方法虽然可行，但是代码量较大并且执行效率较低。  
  为此，JDK 8中新增了一个Stream接口，该接口可以将集合、数组的中的元素转换为Stream流的形式，并结合Lambda表达式的优势来进一步简化集合、数组中元素的查找、过滤、转换等操作，这一新功能就是JDK 8中的聚合操作。  
  在程序中，使用聚合操作没有绝对的语法规范，根据实际操作流程，主要可以分为以下3个步骤：  
  （1）将原始集合或者数组对象转换为Stream流对象；  
  （2）对Stream流对象中的元素进行一系列的过滤、查找等中间操作（Intermediate Operations），然后仍然返回一个Stream流对象；  
  （3）对Stream流进行遍历、统计、收集等终结操作（Terminal Operation），获取想要的结果。  
  接下来，就根据上面聚合操作的3个步骤，通过一个案例来演示聚合操作的基本用法，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example31 {
 4		public static void main(String[] args) {
 5	          // 创建一个List集合对象
 6			List<String> list = new ArrayList<>(); 
 7			list.add("张三");
 8			list.add("李四");
 9			list.add("张小明");
 10			list.add("张阳");
 11			// 1、创建一个Stream流对象
 12			Stream<String> stream = list.stream();
 13			// 2、对Stream流中的元素分别进行过滤、截取操作
 14		       Stream<String> stream2 = stream.filter(i -> i.startsWith("张"));
 15			Stream<String> stream3 = stream2.limit(2);
 16			// 3、对Stream流中的元素进行终结操作，进行遍历输出
 17			stream3.forEach(j -> System.out.println(j));
 18			System.out.println("=======");
 19	         // 通过链式表达式的形式完成聚合操作
 20			list.stream().filter(i -> i.startsWith("张"))
 21						 .limit(2)
 22						 .forEach(j -> System.out.println(j));
 23		}
 24	}
``` 
   运行结果如下图所示。
![alt](/article_img/lambda/3.jpg)
  上述示例代码中，先创建了一个List集合，然后根据聚合操作的3个步骤实现了集合对象的聚合操作，对集合中的元素使用Stream流的形式进行过滤（filter）、截取（limit），并进行遍历输出。其中第12~17行代码分步骤详细展示了聚合操作，而第20~22行代码是使用了链式表达式（调用有返回值的方法时不获取返回值而是直接再调用另一个方法）实现了聚合操作，该表达式的语法格式更简洁、高效，这种链式调用也被称为操作管道流。

**2. 创建Stream流对象**  
  在上一小节中，介绍了聚合操作的主要使用步骤，其中首要解决的问题就是创建Stream流对象。聚合操作针对的就是可迭代数据进行的操作，如集合、数组等，所以创建Stream流对象其实就是将集合、数组等通过一些方法转换为Stream流对象。  
  在Java中，集合对象有对应的集合类，可以通过集合类提供的静态方法创建Stream流对象，而数组数据却没有对应的数组类，所以必须通过其他方法创建Stream流对象。针对不同的源数据，Java提供了多种创建Stream流对象的方式，分别如下：  
  （1）所有的Collections集合都可以使用stream()静态方法获取Stream流对象；  
  （2）Stream接口的of()静态方法可以获取基本类型包装类数组、引用类型数组和单个元素的Stream流对象；  
  （3）Arrays数组工具类的stream()静态方法也可以获取数组元素的Stream流对象。  
  接下来，通过一个案例来学习聚合操作中如何创建Stream流对象，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example32 {
 4		public static void main(String[] args) {
 5	          // 创建一个数组
 6			Integer[] array = { 9, 8, 3, 5, 2 };       
 7	          // 将数组转换为List集合
 8			List<Integer> list = Arrays.asList(array); 
 9			// 1、使用集合对象的stream()静态方法创建Stream流对象
 10			Stream<Integer> stream = list.stream();
 11			stream.forEach(i -> System.out.print(i+" "));
 12			System.out.println();
 13			// 2、使用Stream接口的of()静态方法创建Stream流对象
 14			Stream<Integer> stream2 = Stream.of(array);
 15			stream2.forEach(i -> System.out.print(i+" "));
 16			System.out.println();
 17			// 3、使用Arrays数组工具类的stream()静态方法创建Stream流对象
 18			Stream<Integer> stream3 = Arrays.stream(array);
 19			stream3.forEach(i -> System.out.print(i+" "));
 20		}
 21	}
```  
  运行结果如下图所示。
![alt](/article_img/lambda/4.jpg)
  上述示例代码中，先创建了一个数组和一个集合，然后通过三种方式实现了Stream流对象的创建，并通过Stream流对象的forEach()方法结合Lambda表达式完成了集合和数组中元素的遍历。  

**小提示：**  
  在JDK 8中，只针对单列集合Collections接口对象提供了stream()静态方法获取Stream流对象，并未对Map集合提供相关方法获取Stream流对象，所以想要用Map集合创建Stream流对象必须先通过Map集合的keySet()、values()、entrySet()等方法将Map集合转换为单列Set集合，然后再使用单列集合的stream()静态方法获取对应键、值集合的Stream流对象。

, 2018-12-02, null, 默认分类, JDK 8,聚合操作, true, null]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20003, rs-50002} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20003} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20004} created. SELECT count(0) FROM t_comment WHERE article_id = ?
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20004} Parameters : [8]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20004} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20004} executed. 0.61 millis. SELECT count(0) FROM t_comment WHERE article_id = ?
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50003} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50003} Header: [count(0)]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50003} Result: [1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50003} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20004} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20005} created. select * from t_comment where article_id=? LIMIT ? 
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20005} Parameters : [8, 3]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20005} Types : [INTEGER, INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20005} executed. 0.4515 millis. select * from t_comment where article_id=? LIMIT ? 
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20005, rs-50004} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20005, rs-50004} Header: [id, article_id, created, ip, c_content, status, author]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20005, rs-50004} Result: [14, 8, 2018-12-13, 0:0:0:0:0:0:0:1, very good blog, approved, tom]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20005, rs-50004} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20005} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20006} created. update t_statistic set hits = hits+1 where article_id=?;
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20006} Parameters : [8]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20006} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20006} executed. 1.1042 millis. update t_statistic set hits = hits+1 where article_id=?;
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20006} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20007} created. select * from t_comment where article_id=?
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20007} Parameters : [8]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20007} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20007} executed. 0.4414 millis. select * from t_comment where article_id=?
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20007, rs-50005} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20007, rs-50005} Header: [id, article_id, created, ip, c_content, status, author]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20007, rs-50005} Result: [14, 8, 2018-12-13, 0:0:0:0:0:0:0:1, very good blog, approved, tom]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20007, rs-50005} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20007} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20008} created. SELECT count(0) FROM t_comment WHERE article_id = ?
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20008} Parameters : [8]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20008} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20008} executed. 0.4194 millis. SELECT count(0) FROM t_comment WHERE article_id = ?
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20008, rs-50006} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20008, rs-50006} Header: [count(0)]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20008, rs-50006} Result: [1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20008, rs-50006} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20008} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20009} created. select * from t_comment where article_id=? LIMIT ? 
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20009} Parameters : [8, 3]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20009} Types : [INTEGER, INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20009} executed. 0.4624 millis. select * from t_comment where article_id=? LIMIT ? 
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20009, rs-50007} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20009, rs-50007} Header: [id, article_id, created, ip, c_content, status, author]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20009, rs-50007} Result: [14, 8, 2018-12-13, 0:0:0:0:0:0:0:1, very good blog, approved, tom]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20009, rs-50007} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20009} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20010} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20010} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20010} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20010} executed. 0.6886 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20010, rs-50008} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20010, rs-50008} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20010, rs-50008} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 108, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20010, rs-50008} Result: [12, Spring Boot 2 权威发布,   如果这两天登录 [https://start.spring.io/ ](https://start.spring.io/ )就会发现，Spring Boot 默认版本已经升到了 2.1.0。这是因为 Spring Boot 刚刚发布了 2.1.0 版本，我们来看下 Spring Boot 2 发布以来第一个子版本都发布了哪些内容？  

**2.1 中的新特性**     
  ●将spring-boot-starter-oauth2-oidc-client重命名为spring-boot-starter-oauth2-client命名更简洁  
  ●添加 OAuth2 资源服务 starter，OAuth2 一个用于认证的组件  
  ●支持 ConditionalOnBean 和 ConditionalOnMissingBean 下的参数化容器  
  ●自动配置 applicationTaskExecutor bean 的延迟加载来避免不必要的日志记录  
  ●将 DatabaseDriver＃SAP 重命名为 DatabaseDriver  
  ●跳过重启器不仅适用于 JUnit4，也适用于 JUnit5  
  ●在 Jest HealthIndicator 中使用集群端点  
  ●当 DevTools 禁用重启时添加日志输出  
  ●添加注解：@ConditionalOnMissingServletFilter提高 Servlet Filters 的自动装配。
  
**2.1 中的组件升级**  
  ●升级 Hibernate 5.3，Hibernate 的支持升级到了 5.3  
  ●升级 Tomcat 9 ，支持最新的 tomcat 9  
  ●支持 Java 11，Java 现在更新越来越快，Spring 快赶不上了    
  ●升级 Thymeleaf Extras Springsecurity 到 3.0.4.RELEASE ，thymeleaf-extras-springsecurity 是 Thymeleaf 提供集成 Spring Security 的组件  
  ●升级 Joda Time 2.10.1，Joda-Time， 面向 Java 应用程序的日期/时间库的替代选择，Joda-Time 令时间和日期值变得易于管理、操作和理解。  
  ●升级 Lettuce 5.1.2.RELEASE ，Lettuce 前面说过，传说中 Redis 最快的客户端。  
  ●升级 Reactor Californium-SR2 ，Californium 是物联网云服务的 Java COAP 实现。因此，它更专注的是可扩展性和可用性而不是像嵌入式设备那样关注资源效率。不过，Californium 也适合嵌入式的 JVM。  
  ●升级 Maven Failsafe Plugin 2.22.1 ，Maven 中的测试插件。  
  ●升级 Flyway 5.2.1 ， Flyway是一款开源的数据库版本管理工具  
  ●升级 Aspectj 1.9.2 ，AspectJ 是 Java 中流行的 AOP（Aspect-oriented Programming）编程扩展框架，是 Eclipse 托管给 Apache 基金会的一个开源项目。  
  ●升级 Mysql 8.0.13 ，Mysql 支持到 8。  
  ●...  
  更多的详细内容可以参考这里：[Spring Boot 2.1 Release Notes](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.1-Release-Notes)
, 2018-12-12, 2021-05-21, 默认分类, Spring Boot 2, true, null, 62, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20010, rs-50008} Result: [8, JDK 8——聚合操作, &emsp;&emsp;在Java8版本中，JDK包含许多聚合操作（如平均值，总和，最小，最大，和计数），返回一个计算流stream的聚合结果。这些聚合操作被称为聚合操作。JDK除返回单个值的聚合操作外，还有很多聚合操作返回一个collection集合实例。很多的reduce操作执行特定的任务，如求平均值或按类别分组元素。  

**1. 聚合操作简介**

  在开发中，多数情况下会涉及到对集合、数组中元素的操作，在JDK 8之前都是通过普通的循环遍历出每一个元素，然后还会穿插一些if条件语句选择性的对元素进行查找、过滤、修改等操作，这种原始的操作方法虽然可行，但是代码量较大并且执行效率较低。  
  为此，JDK 8中新增了一个Stream接口，该接口可以将集合、数组的中的元素转换为Stream流的形式，并结合Lambda表达式的优势来进一步简化集合、数组中元素的查找、过滤、转换等操作，这一新功能就是JDK 8中的聚合操作。  
  在程序中，使用聚合操作没有绝对的语法规范，根据实际操作流程，主要可以分为以下3个步骤：  
  （1）将原始集合或者数组对象转换为Stream流对象；  
  （2）对Stream流对象中的元素进行一系列的过滤、查找等中间操作（Intermediate Operations），然后仍然返回一个Stream流对象；  
  （3）对Stream流进行遍历、统计、收集等终结操作（Terminal Operation），获取想要的结果。  
  接下来，就根据上面聚合操作的3个步骤，通过一个案例来演示聚合操作的基本用法，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example31 {
 4		public static void main(String[] args) {
 5	          // 创建一个List集合对象
 6			List<String> list = new ArrayList<>(); 
 7			list.add("张三");
 8			list.add("李四");
 9			list.add("张小明");
 10			list.add("张阳");
 11			// 1、创建一个Stream流对象
 12			Stream<String> stream = list.stream();
 13			// 2、对Stream流中的元素分别进行过滤、截取操作
 14		       Stream<String> stream2 = stream.filter(i -> i.startsWith("张"));
 15			Stream<String> stream3 = stream2.limit(2);
 16			// 3、对Stream流中的元素进行终结操作，进行遍历输出
 17			stream3.forEach(j -> System.out.println(j));
 18			System.out.println("=======");
 19	         // 通过链式表达式的形式完成聚合操作
 20			list.stream().filter(i -> i.startsWith("张"))
 21						 .limit(2)
 22						 .forEach(j -> System.out.println(j));
 23		}
 24	}
``` 
   运行结果如下图所示。
![alt](/article_img/lambda/3.jpg)
  上述示例代码中，先创建了一个List集合，然后根据聚合操作的3个步骤实现了集合对象的聚合操作，对集合中的元素使用Stream流的形式进行过滤（filter）、截取（limit），并进行遍历输出。其中第12~17行代码分步骤详细展示了聚合操作，而第20~22行代码是使用了链式表达式（调用有返回值的方法时不获取返回值而是直接再调用另一个方法）实现了聚合操作，该表达式的语法格式更简洁、高效，这种链式调用也被称为操作管道流。

**2. 创建Stream流对象**  
  在上一小节中，介绍了聚合操作的主要使用步骤，其中首要解决的问题就是创建Stream流对象。聚合操作针对的就是可迭代数据进行的操作，如集合、数组等，所以创建Stream流对象其实就是将集合、数组等通过一些方法转换为Stream流对象。  
  在Java中，集合对象有对应的集合类，可以通过集合类提供的静态方法创建Stream流对象，而数组数据却没有对应的数组类，所以必须通过其他方法创建Stream流对象。针对不同的源数据，Java提供了多种创建Stream流对象的方式，分别如下：  
  （1）所有的Collections集合都可以使用stream()静态方法获取Stream流对象；  
  （2）Stream接口的of()静态方法可以获取基本类型包装类数组、引用类型数组和单个元素的Stream流对象；  
  （3）Arrays数组工具类的stream()静态方法也可以获取数组元素的Stream流对象。  
  接下来，通过一个案例来学习聚合操作中如何创建Stream流对象，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example32 {
 4		public static void main(String[] args) {
 5	          // 创建一个数组
 6			Integer[] array = { 9, 8, 3, 5, 2 };       
 7	          // 将数组转换为List集合
 8			List<Integer> list = Arrays.asList(array); 
 9			// 1、使用集合对象的stream()静态方法创建Stream流对象
 10			Stream<Integer> stream = list.stream();
 11			stream.forEach(i -> System.out.print(i+" "));
 12			System.out.println();
 13			// 2、使用Stream接口的of()静态方法创建Stream流对象
 14			Stream<Integer> stream2 = Stream.of(array);
 15			stream2.forEach(i -> System.out.print(i+" "));
 16			System.out.println();
 17			// 3、使用Arrays数组工具类的stream()静态方法创建Stream流对象
 18			Stream<Integer> stream3 = Arrays.stream(array);
 19			stream3.forEach(i -> System.out.print(i+" "));
 20		}
 21	}
```  
  运行结果如下图所示。
![alt](/article_img/lambda/4.jpg)
  上述示例代码中，先创建了一个数组和一个集合，然后通过三种方式实现了Stream流对象的创建，并通过Stream流对象的forEach()方法结合Lambda表达式完成了集合和数组中元素的遍历。  

**小提示：**  
  在JDK 8中，只针对单列集合Collections接口对象提供了stream()静态方法获取Stream流对象，并未对Map集合提供相关方法获取Stream流对象，所以想要用Map集合创建Stream流对象必须先通过Map集合的keySet()、values()、entrySet()等方法将Map集合转换为单列Set集合，然后再使用单列集合的stream()静态方法获取对应键、值集合的Stream流对象。

, 2018-12-02, null, 默认分类, JDK 8,聚合操作, true, null, 36, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20010, rs-50008} Result: [9, 虚拟化容器技术——Docker运行机制介绍,   Docker是一个开源的应用容器引擎，它基于go语言开发，并遵从Apache2.0开源协议。使用Docker可以让开发者封装他们的应用以及依赖包到一个可移植的容器中，然后发布到任意的Linux机器上，也可以实现虚拟化。Docker容器完全使用沙箱机制，相互之间不会有任何接口，这保证了容器之间的安全性。  

**1. Docker的引擎介绍**

  Docker Engine（Docker引擎）是Docker的核心部分，使用的是客户端-服务器（C/S）架构模式，其主要组成部分如下图所示。
![alt](/article_img/docker/1.png)
  从上图可以看出，Docker Engine中包含了三个核心组件（docker CLI、REST API和docker daemon），这三个组件的具体说明如下：  
  ①docker CLI（command line interface）：表示Docker命令行接口，开发者可以在命令行中使用Docker相关指令与Docker守护进程进行交互，从而管理诸如image（镜像）、container（容器）、network（网络）和data volumes（数据卷）等实体。  
  ②REST API：表示应用程序API接口，开发者通过该API接口可以与Docker的守护进程进行交互，从而指示后台进行相关操作。  
  ③docker daemon：表示Docker的服务端组件，他是Docker架构中运行在后台的一个守护进程，可以接收并处理来自命令行接口及API接口的指令，然后进行相应的后台操作。  
  对于开发者而言，既可以使用编写好的脚本文件通过REST API来实现与Docker进程交互，又可以直接使用Docker相关指令通过命令行接口来与Docker进程交互，而其他一些Docker应用则是通过底层的API和CLI进行交互的。

**2. Docker的架构介绍**

  了解了Docker内部引擎及作用后，我们还需要通过Docker的具体架构，来了解Docker的整个运行流程。接下来借助Docker官网的架构图来对Docker架构进行详细说明，如下图所示。
![alt](/article_img/docker/2.jpg)
  从图中可以看出，Docker架构主要包括Client、DOCKER_HOST和Register三部分，关于这三部分的具体说明如下。  
&emsp;&emsp;**（1）Client（客户端）**  
  Client即Docker客户端，也就是上一小节Docker Engine中介绍的docker CLI。开发者通过这个客户端使用Docker的相关指令与Docker守护进程进行交互，从而进行Docker镜像的创建、拉取和运行等操作。  
&emsp;&emsp;**（2）DOCKER_HOST（Docker主机）**  
  DOCKER_HOST即Docker内部引擎运行的主机，主要指Docker daemon（Docker守护进程）。可以通过Docker守护进程与客户端还有Docker的镜像仓库Registry进行交互，从而管理Images（镜像）和Containers（容器）等。  
&emsp;&emsp;**（3）Registry（注册中心）**  
  Registry即Docker注册中心，实质就是Docker镜像仓库，默认使用的是Docker官方远程注册中心Docker Hub，也可以使用开发者搭建的本地仓库。Registry中包含了大量的镜像，这些镜像可以是官网基础镜像，也可以是其他开发者上传的镜像。  
  我们在实际使用Docker时，除了会涉及到图中的三个主要部分外，还会涉及到很多Docker Objects（Docker对象），例如Images（镜像）、Containers（容器）、Networks（网络）、Volumes（数据卷）、Plugins（插件）等。其中常用的两个对象Image和Containers的说明如下。  
  ①Images（镜像）  
  Docker 镜像就是一个只读的模板，包含了一些创建Docker容器的操作指令。通常情况下，一个Docker镜像是基于另一个基础镜像创建的，并且新创建的镜像会额外包含一些功能配置。例如：开发者可以依赖于一个Ubuntu的基础镜像创建一个新镜像，并可以在新镜像中安装Apache等软件或其它应用程序。  
  ②Containers（容器）  
  Docker容器属于镜像的一个可运行实例（镜像与容器的关系其实与Java中的类与对象相似），开发者可以通过API接口或者CLI命令行接口来创建、运行、停止、移动、删除一个容器，也可以将一个容器连接到一个或多个网络中，将数据存储与容器进行关联。



, 2018-12-03, null, 默认分类, 虚拟化容器,Docker,运行机制, true, null, 26, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20010, rs-50008} Result: [10, Docker常用客户端指令介绍,   在使用Docker之前，首先会为对应的项目编写Dockerfile镜像构建文件，然后通过Docker的相关指令进行镜像构建，完成镜像的构建后，就可以使用这些项目镜像进行启动测试了。所以要想知道如何使用Docker来执行这些Dockerfile镜像构建文件，还需要学习Docker客户端的常用指令，本篇文章将对Docker客户端的常用指令进行详细讲解。  

**1.列出镜像**  
  通过docker images指令可以查看本地镜像列表中已有的镜像，具体使用方式如下。
```js
$ docker images
```  
  执行上述指令后，系统会将所有本地镜像都展示出来，如下图所示。
![alt](/article_img/docker/3.png)
  从图中可以看出，系统终端将本地镜像列表中的3个镜像分5列进行了展示，每一列的具体含义如下。  
  ●REPOSITORY：镜像名称。  
  ●TAG：镜像的参数，类似于版本号，默认是latest。  
  ●IMAGE ID：镜像ID，是唯一值。此处看到的是一个长度为12的字符串，实际上它是64位完整镜像ID的缩写形式。  
  ●CREATED：距今创建镜像的时间。  
  ●SIZE：镜像大小。    

**2.搜索镜像**  
  想知道在Docker Hub中包含了哪些镜像，除了可以登录Docker Hub，在官网中心进行查看外，还可以直接在Docker客户端进行查询。例如想要查询Ubuntu镜像，可以使用如下指令。
```js
$ docker search ubuntu
```  
  执行上述指令后，系统终端就会将搜索到的有关Ubuntu的镜像展示出来，如下图所示。
![alt](/article_img/docker/4.png)
  从图所示的结果可以看出，系统终端分5列将搜索到的Ubuntu相关镜像都列举出来了，这5列的具体含义如下。  
  ●NAME：表示镜像的名称，这里有两种格式的名称，其中不带有“/”的表示官方镜像，而带有“/”的表示其他用户的公开镜像。公开镜像“/”前面是用户在Docker Hub上的用户名（唯一），后面是对应的镜像名；官方镜像与用户镜像，除了从镜像名称上可以区分外，还可以通过第4列的OFFICIAL声明中看出（该列下内容为OK表示官方镜像）。  
  ●DESCRIPTION：表示镜像的描述，这里只显示了一小部分。  
  ●STARS：表示该镜像的收藏数，用户可以在Docker Hub上对镜像进行收藏，一般可以通过该数字反应出该镜像的受欢迎程度。  
  ●OFFICIAL：表示是否为官方镜像。  
  ●AUTOMATED：表示是否自动构建镜像。例如，用户可以将自己的Docker Hub绑定到如Github上，当代码提交更新后，可以自动构建镜像。   
 
**3.拉取镜像**  
  通过docker pull指令可以拉取仓库镜像到本地（默认都是拉取Docker Hub仓库镜像，也可以指定“IP+端口”拉取某个Docker机器上的私有仓库镜像），具体使用方式如下。
```js
$ docker pull ubuntu
```  
  执行上述指令后，Docker会自动从Docker Hub上下载最新版本的Ubuntu到本地，当然也可以使用以下指令拉取指定版本的镜像到本地，具体指令如下。
```js
$ docker pull ubuntu:14.04
```  
**4.构建镜像**  
  除了可以通过docker pull指令从仓库拉取镜像外，还可以通过docker build指令构建Docker镜像，通常情况下都是通过Dockerfile文件来构建镜像的。  
  这里假设linux系统home目录下/shitou/workspace/dockerspace文件夹中编写有对应的Dockerfile文件，则构建镜像直立示例如下所示。 
```js
$ docker build -t hellodocker3 /home/shitou/workspace/dockerspace/.
```
**5.删除镜像**  
  当本地存放过多不需要的镜像时，可以通过docker rmi指令将其删除。在删除镜像时，需要指定镜像名称或镜像ID。删除镜像的使用方式如下。
```js
$ docker rmi -f hellodocker2 hellodocker3
```  
  上述指令中，docker rmi表示删除镜像，-f表示进行强制删除，而hellodocker2和hellodocker3分别表示需要删除的镜像名称，这里同时删除两个镜像。除了根据名称删除镜像外，还也可以根据镜像ID来删除镜像，只是这里如果指定了删除ID为23c617a866d4的镜像后，会同时删除hellodocker、hellodocker2和hellodocker3三个镜像。  
  需要特别强调的是，在进行镜像删除操作时，如果是通过镜像ID进行镜像删除，那么由该镜像创建的容器必须提前删除或停止。另外，在通过镜像名称操作镜像时，如果出现镜像重名的情况，必须在镜像名称后面指定镜像标签tag参数来确保唯一性。

**6.创建并启动容器**  
  Docker镜像主要用于创建容器，可以使用docker run指令创建并启动容器，具体使用方式如下。
```js
$ docker run -d -p 5000:80 --name test hellodocker
```  
  上述创建并启动容器的指令略微复杂，具体分析如下。  
  ●docker run：表示创建并启动一个容器，而后面的hellodocker就表示要启动运行的镜像名称；  
  ●-d：表示容器启动时在后台运行；  
  ●-p 5000:80：表示将容器内暴露的80端口映射到宿主机指定的5000端口，也可以将-p 5000:80更改为-P来映射主机的随机端口（注意p字母的大小写）；  
  ●--name test：表示为创建后的容器指定名称为test，如果没有该参数配置，则生成的容器会设置一个随机名称。  
  docker run命令是Docker操作中较为复杂的一个，它可以携带多个参数和参数，我们可以通过docker run --help指令进行查看，其中有些参数如-e、-v和-w等都可以在Dockerfile文件中预先声明。 
 
**7.列出容器**  
  生成容器后，可以通过docker ps指令查看当前运行的所有容器，具体使用方式如下。
```js
$ docker ps
```  
  执行上述命令后，会将所有当前运行的容器都展示出来，具体如下图所示。
![alt](/article_img/docker/5.png)
  从图中可以看出，系统终端通过7列对当前的正在运行的一个容器进行了展示，图中每一列的具体含义如下。  
  ●CONTAINER ID：表示生成的容器ID；  
  ●IMAGE：表示生成该容器的镜像名称；  
  ●COMMAND：表示启动容器时运行的命令，Docker要求在启动容器时必须运行一个命令；  
  ●CREATED：表示容器创建的时间；  
  ●STATUS：表示容器运行状态，例如Up表示运行中，Exited表示已停止；  
  ●PORTS：表示容器内部暴露的端口映射到主机的端口；  
  ●NAMES：表示生成容器的名称，由Docker引擎自动生成，可以像上述示例中使用--name参数指定生成容器的名称。  
  另外，docker ps指令运行过程中可以指定多个参数，还可以通过docker ps --help指令对ps指令的其他信息进行查看。

**8.删除容器**  
  当不需要使用容器时，则可以使用docker rm指令删除已停止的容器，具体使用方式如下。
```js
$ docker rm f0c9a8b6e8c5
```  
  需要注意的是，上述指令只能删除已经停止运行的容器，而不能删除正在运行的容器。如果想要删除正在运行的容器，则需要添加-f参数强制删除，具体使用方式如下。
```js
$ docker rm -f f0c9a8b6e8c5
```  
  当需要删除的容器过多时，如果还一个个的删除就略显麻烦了，此时可以通过如下指令将全部容器删除。
```js
$ docker rm -f $(docker ps -aq)
```  
  上述指令中，首先会通过$(docker ps -aq)获取所有容器的ID，然后通过docker rm -f指令进行强制删除。如果开发者有自己特殊的删除需求，可以根据前面docker ps指令进行组装来获取需要删除的容器ID。  
  Docker提供的操作指令远不止这些，这里就不一一列举了，想要了解更多Docker的操作指令，可以通过docker --help指令进行查看。


, 2018-12-05, null, 默认分类, Docker,客户端指令, true, null, 21, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20010, rs-50008} Result: [11, Docker数据管理介绍,   当我们对容器进行相关操作时，产生的一系列数据都会存储在容器中，而Docker内部又是如果管理这些数据的呢？本篇文章将针对Docker数据管理的一些知识进行介绍。
  
**1. Docker数据存储机制**  
  使用Docker时，我们操作的都是镜像和由镜像生成的容器，所以想要更好的了解Docker内部的数据存储机制，就必须从镜像、容器与数据存储的关系出发。  
  Docker镜像是通过读取Dockerfile文件中的指令构建的，Dockerfile中的每条指令都会创建一个镜像层，并且每层都是只读的，这一系列的镜像层就构成了Docker镜像。接下来以一个Dockerfile文件为例进行说明，具体如下列代码示例所示。
```js
 1	FROM ubuntu:16.04
 2	COPY . /app
 3	RUN make /app
 4	CMD python /app/app.py
```  
   上述文件示例中的Dockerfile包含了4条指令，每条指令都会创建一个镜像层，其中每一层与前一层都有所不同，并且是层层叠加的。通过镜像构建容器时，会在镜像层上增加一个容器层（即可写层），所有对容器的更改都会写入容器层，这也是Docker默认的数据存储方式。  
  下面通过一个效果图进行说明，具体如下图所示。
![alt](/article_img/docker/6.png)
  从图中可以看出，Docker容器和镜像之间的主要区别是顶部的容器层，而所有对容器中数据的添加、修改等操作都会被存储在容器层中。当容器被删除时，容器层也会被删除，其中存储的数据会被一同删除，而下面的镜像层却保持不变。  
  由于所有的容器都是通过镜像构建的，所以每个容器都有各自的容器层，对于容器数据的更改就会保存在各自的容器层中。也就是说，由同一个镜像构建的多个容器，它们会拥有相同的底部镜像层，而拥有不同的容器层，多个容器可以访问相同的镜像层，并且有自己的独立数据状态。具体说明如下图所示。 
![alt](/article_img/docker/7.png)
  从图中可以看出，基于同一个镜像构建的多个容器可以共享该镜像层，但是多个容器想要共享相同的数据，就需要将这些数据存储到容器之外的地方，而这种方式就是下一节要提到的Docker volume数据外部挂载机制。  

**2. Docker数据存储方式**    
  在默认情况下，Docker中的数据都是存放在容器层的，但是这样存储数据却有较多的缺陷，具体表现如下。    
  ●当容器不再运行时，容器中的数据无法持久化保存，如果另一个进程需要这些数据，那么将很难从容器中获取数据；  
  ●容器层与正在运行的主机紧密耦合，不能轻易地移动数据；  
  ●容器层需要一个存储驱动程序来管理文件系统，存储驱动程序提供了一个使用Linux内核的联合文件系统，这种额外的抽象化降低了性能。  
  基于上述种种原因，多数情况下Docker数据管理都不会直接将数据写入容器层，而是使用另一种叫做Docker volume数据外部挂载的机制进行数据管理。  
  针对Docker volume数据外部挂载机制，Docker提供了三种不同的方式将数据从容器映射到Docker宿主机，他们分别为：volumes（数据卷）、bind mounts（绑定挂载）和tmpfs mounts（tmpfs挂载）。这三种数据管理方式的具体选择，需要结合实际情况进行考虑，其中的volumes数据卷是最常用也是官方推荐的数据管理方式。无论选择使用哪种数据管理方式，数据在容器内看起来都一样的，而在容器外则会被被挂载到文件系统中的某个目录或文件中。    
  下面通过一张图来展示数据卷、绑定挂载和tmpfs挂载之间的差异，如下图所示。  
![alt](/article_img/docker/8.png)
  从图中可以看出，Docker提供的三种数据管理方式略有不同，具体分析如下。  
  ●volumes：存储在主机文件系统中（在Linux系统下是存在于/var/lib/Docker/volumes/目录），并由Docker管理，非Docker进程无法修改文件系统的这个部分。  
  ●bind mounts：可以存储在主机系统的任意位置，甚至可能是重要的系统文件或目录，在Docker主机或容器上的非Docker进程可以对他们进行任意修改。  
  ●tmpfs mounts：只存储在主机系统的内存中，并没有写入到主机的文件系统中。


, 2018-12-07, 2021-05-19, 默认分类, Docker,数据管理, true, null, 19, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20010, rs-50008} Result: [6, JDK 8——Lambda表达式介绍,   Lambda表达式是JDK 8中一个重要的新特性，它使用一个清晰简洁的表达式来表达一个接口，同时Lambda表达式也简化了对集合以及数组数据的遍历、过滤和提取等操作。下面，本篇文章就对Lambda表达式进行简要介绍，并进行演示说明。

**1. Lambda表达式入门**  

  匿名内部类存在的一个问题是，如果匿名内部类的实现非常简单，例如只包含一个抽象方法的接口，那么匿名内部类的语法仍然显得比较冗余。为此，JDK 8中新增了一个特性Lambda表达式，这种表达式只针对有一个抽象方法的接口实现，以简洁的表达式形式实现接口功能来作为方法参数。  
  一个Lambda表达式由三个部分组成，分别为参数列表、“->”和表达式主体，其语法格式如下：
```js
 ([数据类型 参数名,数据类型 参数名,...]) -> {表达式主体}
```  
  从上述语法格式上看，Lambda表达式的书写非常简单，下面针对Lambda表达式的组成部分进行简单介绍，具体如下：  
  （1）([数据类型 参数名,数据类型 参数名,...])：用来向表达式主体传递接口方法需要的参数，多个参数名中间必须用英文逗号“,”进行分隔；在编写Lambda表达式时，可以省略参数的数据类型，后面的表达式主体会自动进行校对和匹配；同时，如果只有一个参数，则可以省略括号“()”。  
  （2）->：表示Lambda表达式箭牌，用来指定参数数据指向，不能省略，且必须用英文横线和大于号书写。  
  （3）{表达式主体}：由单个表达式或语句块组成的主体，本质就是接口中抽象方法的具体实现，如果表达式主体只有一条语句，那么可以省略包含主体的大括号；另外，在Lambda表达式主体中允许有返回值，当只有一条return语句时，也可以省略return关键字。  
  了解了Lambda表达式的语法后，接下来编写一个示例文件对Lambda表达式的基本使用进行介绍，具体代码如下所示。
```js
 1	// 定义动物类接口
 2	interface Animal { 
 3		void shout(); // 定义方法shout()
 4	}
 5	public class Example22 {
 6		public static void main(String[] args) {
 7	       String name = "小花"; 
 8	       // 1、匿名内部类作为参数传递给animalShout()方法
 9		  animalShout(new Animal() { 
 10				 public void shout() { 
 11				    System.out.println("匿名内部类输出："+name+"喵喵...");
 12				}
 13		  });
 14		  // 2、使用Lambda表达式作为参数传递给animalShout()方法
 15	       animalShout(()-> System.out.println("Lambda表达式输出："
 16	                                                   +name+"喵喵..."));
 17		}
 18	    // 创建一个animalShout()静态方法，接收接口类型的参数
 19		public static void animalShout(Animal an) {
 20			an.shout();  
 21		}
 22	}
```  
  运行结果下图所示。
![alt](/article_img/lambda/1.jpg)
  上述代码示例中，先定义了只有一个抽象方法的接口Animal，然后分别使用匿名内部类和Lambda表达式的方式实现了接口方法。从图中可以看出，使用匿名内部类和Lambda表达式都能实现接口中方法，但很显然使用Lambda表达式更加简洁和清晰。, 2018-11-27, null, 默认分类, 2018,Lambda表达式, true, null, 18, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20010, rs-50008} Result: [7, 函数式接口, &emsp;&emsp;虽然Lambda表达式可以实现匿名内部类的功能，但在使用时却有一个局限，即接口中有且只有一个抽象方法时才能使用Lamdba表达式代替匿名内部类。这是因为Lamdba表达式是基于函数式接口实现的，所谓函数式接口是指有且仅有一个抽象方法的接口，Lambda表达式就是Java中函数式编程的体现，只有确保接口中有且仅有一个抽象方法，Lambda表达式才能顺利地推导出所实现的这个接口中的方法。  
&emsp;&emsp;在JDK 8中，专门为函数式接口引入了一个@FunctionalInterface注解，该注解只是显示的标注了接口是一个函数式接口，并强制编辑器进行更严格的检查，确保该接口是函数式接口，如果不是函数式接口，那么编译器就会报错，而对程序运行并没有实质上的影响。  
&emsp;&emsp;接下来通过一个案例来演示函数式接口的定义与使用，示例代码如下所示。
```js
 1	// 定义无参、无返回值的函数式接口
 2	@FunctionalInterface
 3	interface Animal {
 4		void shout();
 5	}
 6	// 定义有参、有返回值的函数式接口
 7	interface Calculate {
 8		int sum(int a, int b);
 9	}
 10	public class Example23 {
 11		public static void main(String[] args) {
 12		   // 分别两个函数式接口进行测试
 13		   animalShout(() -> System.out.println("无参、无返回值的函数式接口调用"));
 14		   showSum(10, 20, (x, y) -> x + y);
 15		}
 16		// 创建一个动物叫的方法，并传入接口对象Animal作为参数
 17		private static void animalShout(Animal animal) {
 18			animal.shout();
 19		}
 20		// 创建一个求和的方法，并传入两个int类型以及接口Calculate类型的参数
 21		private static void showSum(int x, int y, Calculate calculate) {
 22		   System.out.println(x + "+" + y + "的和为：" + calculate.sum(x, y));
 23		}
 24	}
```  
&emsp;&emsp;运行结果如下图所示。

![alt](/article_img/lambda/2.jpg)
&emsp;&emsp;上述代码示例中，先定义了两个函数式接口Animal和Calculate，然后在测试类中分别编写了两个静态方法，并将这两个函数式接口以参数的形式传入，最后在main()方法中分别调用这两个静态方法，并将所需要的函数式接口参数以Lambda表达式的形式传入。从图中可以看出，程序中函数式接口的定义和使用完全正确。
, 2018-12-01, null, 默认分类, 接口,函数式接口, true, null, 12, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20010, rs-50008} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20010, rs-50008} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20010, rs-50008} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20010, rs-50008} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20010, rs-50008} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20010} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} connected
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} created. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} executed. 6.8546 millis. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Header: [count(0)]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [12]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} Parameters : [5]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} executed. 1.2132 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 108, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} executed. 0.9165 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 108, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [12, Spring Boot 2 权威发布,   如果这两天登录 [https://start.spring.io/ ](https://start.spring.io/ )就会发现，Spring Boot 默认版本已经升到了 2.1.0。这是因为 Spring Boot 刚刚发布了 2.1.0 版本，我们来看下 Spring Boot 2 发布以来第一个子版本都发布了哪些内容？  

**2.1 中的新特性**     
  ●将spring-boot-starter-oauth2-oidc-client重命名为spring-boot-starter-oauth2-client命名更简洁  
  ●添加 OAuth2 资源服务 starter，OAuth2 一个用于认证的组件  
  ●支持 ConditionalOnBean 和 ConditionalOnMissingBean 下的参数化容器  
  ●自动配置 applicationTaskExecutor bean 的延迟加载来避免不必要的日志记录  
  ●将 DatabaseDriver＃SAP 重命名为 DatabaseDriver  
  ●跳过重启器不仅适用于 JUnit4，也适用于 JUnit5  
  ●在 Jest HealthIndicator 中使用集群端点  
  ●当 DevTools 禁用重启时添加日志输出  
  ●添加注解：@ConditionalOnMissingServletFilter提高 Servlet Filters 的自动装配。
  
**2.1 中的组件升级**  
  ●升级 Hibernate 5.3，Hibernate 的支持升级到了 5.3  
  ●升级 Tomcat 9 ，支持最新的 tomcat 9  
  ●支持 Java 11，Java 现在更新越来越快，Spring 快赶不上了    
  ●升级 Thymeleaf Extras Springsecurity 到 3.0.4.RELEASE ，thymeleaf-extras-springsecurity 是 Thymeleaf 提供集成 Spring Security 的组件  
  ●升级 Joda Time 2.10.1，Joda-Time， 面向 Java 应用程序的日期/时间库的替代选择，Joda-Time 令时间和日期值变得易于管理、操作和理解。  
  ●升级 Lettuce 5.1.2.RELEASE ，Lettuce 前面说过，传说中 Redis 最快的客户端。  
  ●升级 Reactor Californium-SR2 ，Californium 是物联网云服务的 Java COAP 实现。因此，它更专注的是可扩展性和可用性而不是像嵌入式设备那样关注资源效率。不过，Californium 也适合嵌入式的 JVM。  
  ●升级 Maven Failsafe Plugin 2.22.1 ，Maven 中的测试插件。  
  ●升级 Flyway 5.2.1 ， Flyway是一款开源的数据库版本管理工具  
  ●升级 Aspectj 1.9.2 ，AspectJ 是 Java 中流行的 AOP（Aspect-oriented Programming）编程扩展框架，是 Eclipse 托管给 Apache 基金会的一个开源项目。  
  ●升级 Mysql 8.0.13 ，Mysql 支持到 8。  
  ●...  
  更多的详细内容可以参考这里：[Spring Boot 2.1 Release Notes](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.1-Release-Notes)
, 2018-12-12, 2021-05-21, 默认分类, Spring Boot 2, true, null, 62, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [8, JDK 8——聚合操作, &emsp;&emsp;在Java8版本中，JDK包含许多聚合操作（如平均值，总和，最小，最大，和计数），返回一个计算流stream的聚合结果。这些聚合操作被称为聚合操作。JDK除返回单个值的聚合操作外，还有很多聚合操作返回一个collection集合实例。很多的reduce操作执行特定的任务，如求平均值或按类别分组元素。  

**1. 聚合操作简介**

  在开发中，多数情况下会涉及到对集合、数组中元素的操作，在JDK 8之前都是通过普通的循环遍历出每一个元素，然后还会穿插一些if条件语句选择性的对元素进行查找、过滤、修改等操作，这种原始的操作方法虽然可行，但是代码量较大并且执行效率较低。  
  为此，JDK 8中新增了一个Stream接口，该接口可以将集合、数组的中的元素转换为Stream流的形式，并结合Lambda表达式的优势来进一步简化集合、数组中元素的查找、过滤、转换等操作，这一新功能就是JDK 8中的聚合操作。  
  在程序中，使用聚合操作没有绝对的语法规范，根据实际操作流程，主要可以分为以下3个步骤：  
  （1）将原始集合或者数组对象转换为Stream流对象；  
  （2）对Stream流对象中的元素进行一系列的过滤、查找等中间操作（Intermediate Operations），然后仍然返回一个Stream流对象；  
  （3）对Stream流进行遍历、统计、收集等终结操作（Terminal Operation），获取想要的结果。  
  接下来，就根据上面聚合操作的3个步骤，通过一个案例来演示聚合操作的基本用法，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example31 {
 4		public static void main(String[] args) {
 5	          // 创建一个List集合对象
 6			List<String> list = new ArrayList<>(); 
 7			list.add("张三");
 8			list.add("李四");
 9			list.add("张小明");
 10			list.add("张阳");
 11			// 1、创建一个Stream流对象
 12			Stream<String> stream = list.stream();
 13			// 2、对Stream流中的元素分别进行过滤、截取操作
 14		       Stream<String> stream2 = stream.filter(i -> i.startsWith("张"));
 15			Stream<String> stream3 = stream2.limit(2);
 16			// 3、对Stream流中的元素进行终结操作，进行遍历输出
 17			stream3.forEach(j -> System.out.println(j));
 18			System.out.println("=======");
 19	         // 通过链式表达式的形式完成聚合操作
 20			list.stream().filter(i -> i.startsWith("张"))
 21						 .limit(2)
 22						 .forEach(j -> System.out.println(j));
 23		}
 24	}
``` 
   运行结果如下图所示。
![alt](/article_img/lambda/3.jpg)
  上述示例代码中，先创建了一个List集合，然后根据聚合操作的3个步骤实现了集合对象的聚合操作，对集合中的元素使用Stream流的形式进行过滤（filter）、截取（limit），并进行遍历输出。其中第12~17行代码分步骤详细展示了聚合操作，而第20~22行代码是使用了链式表达式（调用有返回值的方法时不获取返回值而是直接再调用另一个方法）实现了聚合操作，该表达式的语法格式更简洁、高效，这种链式调用也被称为操作管道流。

**2. 创建Stream流对象**  
  在上一小节中，介绍了聚合操作的主要使用步骤，其中首要解决的问题就是创建Stream流对象。聚合操作针对的就是可迭代数据进行的操作，如集合、数组等，所以创建Stream流对象其实就是将集合、数组等通过一些方法转换为Stream流对象。  
  在Java中，集合对象有对应的集合类，可以通过集合类提供的静态方法创建Stream流对象，而数组数据却没有对应的数组类，所以必须通过其他方法创建Stream流对象。针对不同的源数据，Java提供了多种创建Stream流对象的方式，分别如下：  
  （1）所有的Collections集合都可以使用stream()静态方法获取Stream流对象；  
  （2）Stream接口的of()静态方法可以获取基本类型包装类数组、引用类型数组和单个元素的Stream流对象；  
  （3）Arrays数组工具类的stream()静态方法也可以获取数组元素的Stream流对象。  
  接下来，通过一个案例来学习聚合操作中如何创建Stream流对象，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example32 {
 4		public static void main(String[] args) {
 5	          // 创建一个数组
 6			Integer[] array = { 9, 8, 3, 5, 2 };       
 7	          // 将数组转换为List集合
 8			List<Integer> list = Arrays.asList(array); 
 9			// 1、使用集合对象的stream()静态方法创建Stream流对象
 10			Stream<Integer> stream = list.stream();
 11			stream.forEach(i -> System.out.print(i+" "));
 12			System.out.println();
 13			// 2、使用Stream接口的of()静态方法创建Stream流对象
 14			Stream<Integer> stream2 = Stream.of(array);
 15			stream2.forEach(i -> System.out.print(i+" "));
 16			System.out.println();
 17			// 3、使用Arrays数组工具类的stream()静态方法创建Stream流对象
 18			Stream<Integer> stream3 = Arrays.stream(array);
 19			stream3.forEach(i -> System.out.print(i+" "));
 20		}
 21	}
```  
  运行结果如下图所示。
![alt](/article_img/lambda/4.jpg)
  上述示例代码中，先创建了一个数组和一个集合，然后通过三种方式实现了Stream流对象的创建，并通过Stream流对象的forEach()方法结合Lambda表达式完成了集合和数组中元素的遍历。  

**小提示：**  
  在JDK 8中，只针对单列集合Collections接口对象提供了stream()静态方法获取Stream流对象，并未对Map集合提供相关方法获取Stream流对象，所以想要用Map集合创建Stream流对象必须先通过Map集合的keySet()、values()、entrySet()等方法将Map集合转换为单列Set集合，然后再使用单列集合的stream()静态方法获取对应键、值集合的Stream流对象。

, 2018-12-02, null, 默认分类, JDK 8,聚合操作, true, null, 36, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [9, 虚拟化容器技术——Docker运行机制介绍,   Docker是一个开源的应用容器引擎，它基于go语言开发，并遵从Apache2.0开源协议。使用Docker可以让开发者封装他们的应用以及依赖包到一个可移植的容器中，然后发布到任意的Linux机器上，也可以实现虚拟化。Docker容器完全使用沙箱机制，相互之间不会有任何接口，这保证了容器之间的安全性。  

**1. Docker的引擎介绍**

  Docker Engine（Docker引擎）是Docker的核心部分，使用的是客户端-服务器（C/S）架构模式，其主要组成部分如下图所示。
![alt](/article_img/docker/1.png)
  从上图可以看出，Docker Engine中包含了三个核心组件（docker CLI、REST API和docker daemon），这三个组件的具体说明如下：  
  ①docker CLI（command line interface）：表示Docker命令行接口，开发者可以在命令行中使用Docker相关指令与Docker守护进程进行交互，从而管理诸如image（镜像）、container（容器）、network（网络）和data volumes（数据卷）等实体。  
  ②REST API：表示应用程序API接口，开发者通过该API接口可以与Docker的守护进程进行交互，从而指示后台进行相关操作。  
  ③docker daemon：表示Docker的服务端组件，他是Docker架构中运行在后台的一个守护进程，可以接收并处理来自命令行接口及API接口的指令，然后进行相应的后台操作。  
  对于开发者而言，既可以使用编写好的脚本文件通过REST API来实现与Docker进程交互，又可以直接使用Docker相关指令通过命令行接口来与Docker进程交互，而其他一些Docker应用则是通过底层的API和CLI进行交互的。

**2. Docker的架构介绍**

  了解了Docker内部引擎及作用后，我们还需要通过Docker的具体架构，来了解Docker的整个运行流程。接下来借助Docker官网的架构图来对Docker架构进行详细说明，如下图所示。
![alt](/article_img/docker/2.jpg)
  从图中可以看出，Docker架构主要包括Client、DOCKER_HOST和Register三部分，关于这三部分的具体说明如下。  
&emsp;&emsp;**（1）Client（客户端）**  
  Client即Docker客户端，也就是上一小节Docker Engine中介绍的docker CLI。开发者通过这个客户端使用Docker的相关指令与Docker守护进程进行交互，从而进行Docker镜像的创建、拉取和运行等操作。  
&emsp;&emsp;**（2）DOCKER_HOST（Docker主机）**  
  DOCKER_HOST即Docker内部引擎运行的主机，主要指Docker daemon（Docker守护进程）。可以通过Docker守护进程与客户端还有Docker的镜像仓库Registry进行交互，从而管理Images（镜像）和Containers（容器）等。  
&emsp;&emsp;**（3）Registry（注册中心）**  
  Registry即Docker注册中心，实质就是Docker镜像仓库，默认使用的是Docker官方远程注册中心Docker Hub，也可以使用开发者搭建的本地仓库。Registry中包含了大量的镜像，这些镜像可以是官网基础镜像，也可以是其他开发者上传的镜像。  
  我们在实际使用Docker时，除了会涉及到图中的三个主要部分外，还会涉及到很多Docker Objects（Docker对象），例如Images（镜像）、Containers（容器）、Networks（网络）、Volumes（数据卷）、Plugins（插件）等。其中常用的两个对象Image和Containers的说明如下。  
  ①Images（镜像）  
  Docker 镜像就是一个只读的模板，包含了一些创建Docker容器的操作指令。通常情况下，一个Docker镜像是基于另一个基础镜像创建的，并且新创建的镜像会额外包含一些功能配置。例如：开发者可以依赖于一个Ubuntu的基础镜像创建一个新镜像，并可以在新镜像中安装Apache等软件或其它应用程序。  
  ②Containers（容器）  
  Docker容器属于镜像的一个可运行实例（镜像与容器的关系其实与Java中的类与对象相似），开发者可以通过API接口或者CLI命令行接口来创建、运行、停止、移动、删除一个容器，也可以将一个容器连接到一个或多个网络中，将数据存储与容器进行关联。



, 2018-12-03, null, 默认分类, 虚拟化容器,Docker,运行机制, true, null, 26, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [10, Docker常用客户端指令介绍,   在使用Docker之前，首先会为对应的项目编写Dockerfile镜像构建文件，然后通过Docker的相关指令进行镜像构建，完成镜像的构建后，就可以使用这些项目镜像进行启动测试了。所以要想知道如何使用Docker来执行这些Dockerfile镜像构建文件，还需要学习Docker客户端的常用指令，本篇文章将对Docker客户端的常用指令进行详细讲解。  

**1.列出镜像**  
  通过docker images指令可以查看本地镜像列表中已有的镜像，具体使用方式如下。
```js
$ docker images
```  
  执行上述指令后，系统会将所有本地镜像都展示出来，如下图所示。
![alt](/article_img/docker/3.png)
  从图中可以看出，系统终端将本地镜像列表中的3个镜像分5列进行了展示，每一列的具体含义如下。  
  ●REPOSITORY：镜像名称。  
  ●TAG：镜像的参数，类似于版本号，默认是latest。  
  ●IMAGE ID：镜像ID，是唯一值。此处看到的是一个长度为12的字符串，实际上它是64位完整镜像ID的缩写形式。  
  ●CREATED：距今创建镜像的时间。  
  ●SIZE：镜像大小。    

**2.搜索镜像**  
  想知道在Docker Hub中包含了哪些镜像，除了可以登录Docker Hub，在官网中心进行查看外，还可以直接在Docker客户端进行查询。例如想要查询Ubuntu镜像，可以使用如下指令。
```js
$ docker search ubuntu
```  
  执行上述指令后，系统终端就会将搜索到的有关Ubuntu的镜像展示出来，如下图所示。
![alt](/article_img/docker/4.png)
  从图所示的结果可以看出，系统终端分5列将搜索到的Ubuntu相关镜像都列举出来了，这5列的具体含义如下。  
  ●NAME：表示镜像的名称，这里有两种格式的名称，其中不带有“/”的表示官方镜像，而带有“/”的表示其他用户的公开镜像。公开镜像“/”前面是用户在Docker Hub上的用户名（唯一），后面是对应的镜像名；官方镜像与用户镜像，除了从镜像名称上可以区分外，还可以通过第4列的OFFICIAL声明中看出（该列下内容为OK表示官方镜像）。  
  ●DESCRIPTION：表示镜像的描述，这里只显示了一小部分。  
  ●STARS：表示该镜像的收藏数，用户可以在Docker Hub上对镜像进行收藏，一般可以通过该数字反应出该镜像的受欢迎程度。  
  ●OFFICIAL：表示是否为官方镜像。  
  ●AUTOMATED：表示是否自动构建镜像。例如，用户可以将自己的Docker Hub绑定到如Github上，当代码提交更新后，可以自动构建镜像。   
 
**3.拉取镜像**  
  通过docker pull指令可以拉取仓库镜像到本地（默认都是拉取Docker Hub仓库镜像，也可以指定“IP+端口”拉取某个Docker机器上的私有仓库镜像），具体使用方式如下。
```js
$ docker pull ubuntu
```  
  执行上述指令后，Docker会自动从Docker Hub上下载最新版本的Ubuntu到本地，当然也可以使用以下指令拉取指定版本的镜像到本地，具体指令如下。
```js
$ docker pull ubuntu:14.04
```  
**4.构建镜像**  
  除了可以通过docker pull指令从仓库拉取镜像外，还可以通过docker build指令构建Docker镜像，通常情况下都是通过Dockerfile文件来构建镜像的。  
  这里假设linux系统home目录下/shitou/workspace/dockerspace文件夹中编写有对应的Dockerfile文件，则构建镜像直立示例如下所示。 
```js
$ docker build -t hellodocker3 /home/shitou/workspace/dockerspace/.
```
**5.删除镜像**  
  当本地存放过多不需要的镜像时，可以通过docker rmi指令将其删除。在删除镜像时，需要指定镜像名称或镜像ID。删除镜像的使用方式如下。
```js
$ docker rmi -f hellodocker2 hellodocker3
```  
  上述指令中，docker rmi表示删除镜像，-f表示进行强制删除，而hellodocker2和hellodocker3分别表示需要删除的镜像名称，这里同时删除两个镜像。除了根据名称删除镜像外，还也可以根据镜像ID来删除镜像，只是这里如果指定了删除ID为23c617a866d4的镜像后，会同时删除hellodocker、hellodocker2和hellodocker3三个镜像。  
  需要特别强调的是，在进行镜像删除操作时，如果是通过镜像ID进行镜像删除，那么由该镜像创建的容器必须提前删除或停止。另外，在通过镜像名称操作镜像时，如果出现镜像重名的情况，必须在镜像名称后面指定镜像标签tag参数来确保唯一性。

**6.创建并启动容器**  
  Docker镜像主要用于创建容器，可以使用docker run指令创建并启动容器，具体使用方式如下。
```js
$ docker run -d -p 5000:80 --name test hellodocker
```  
  上述创建并启动容器的指令略微复杂，具体分析如下。  
  ●docker run：表示创建并启动一个容器，而后面的hellodocker就表示要启动运行的镜像名称；  
  ●-d：表示容器启动时在后台运行；  
  ●-p 5000:80：表示将容器内暴露的80端口映射到宿主机指定的5000端口，也可以将-p 5000:80更改为-P来映射主机的随机端口（注意p字母的大小写）；  
  ●--name test：表示为创建后的容器指定名称为test，如果没有该参数配置，则生成的容器会设置一个随机名称。  
  docker run命令是Docker操作中较为复杂的一个，它可以携带多个参数和参数，我们可以通过docker run --help指令进行查看，其中有些参数如-e、-v和-w等都可以在Dockerfile文件中预先声明。 
 
**7.列出容器**  
  生成容器后，可以通过docker ps指令查看当前运行的所有容器，具体使用方式如下。
```js
$ docker ps
```  
  执行上述命令后，会将所有当前运行的容器都展示出来，具体如下图所示。
![alt](/article_img/docker/5.png)
  从图中可以看出，系统终端通过7列对当前的正在运行的一个容器进行了展示，图中每一列的具体含义如下。  
  ●CONTAINER ID：表示生成的容器ID；  
  ●IMAGE：表示生成该容器的镜像名称；  
  ●COMMAND：表示启动容器时运行的命令，Docker要求在启动容器时必须运行一个命令；  
  ●CREATED：表示容器创建的时间；  
  ●STATUS：表示容器运行状态，例如Up表示运行中，Exited表示已停止；  
  ●PORTS：表示容器内部暴露的端口映射到主机的端口；  
  ●NAMES：表示生成容器的名称，由Docker引擎自动生成，可以像上述示例中使用--name参数指定生成容器的名称。  
  另外，docker ps指令运行过程中可以指定多个参数，还可以通过docker ps --help指令对ps指令的其他信息进行查看。

**8.删除容器**  
  当不需要使用容器时，则可以使用docker rm指令删除已停止的容器，具体使用方式如下。
```js
$ docker rm f0c9a8b6e8c5
```  
  需要注意的是，上述指令只能删除已经停止运行的容器，而不能删除正在运行的容器。如果想要删除正在运行的容器，则需要添加-f参数强制删除，具体使用方式如下。
```js
$ docker rm -f f0c9a8b6e8c5
```  
  当需要删除的容器过多时，如果还一个个的删除就略显麻烦了，此时可以通过如下指令将全部容器删除。
```js
$ docker rm -f $(docker ps -aq)
```  
  上述指令中，首先会通过$(docker ps -aq)获取所有容器的ID，然后通过docker rm -f指令进行强制删除。如果开发者有自己特殊的删除需求，可以根据前面docker ps指令进行组装来获取需要删除的容器ID。  
  Docker提供的操作指令远不止这些，这里就不一一列举了，想要了解更多Docker的操作指令，可以通过docker --help指令进行查看。


, 2018-12-05, null, 默认分类, Docker,客户端指令, true, null, 21, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [11, Docker数据管理介绍,   当我们对容器进行相关操作时，产生的一系列数据都会存储在容器中，而Docker内部又是如果管理这些数据的呢？本篇文章将针对Docker数据管理的一些知识进行介绍。
  
**1. Docker数据存储机制**  
  使用Docker时，我们操作的都是镜像和由镜像生成的容器，所以想要更好的了解Docker内部的数据存储机制，就必须从镜像、容器与数据存储的关系出发。  
  Docker镜像是通过读取Dockerfile文件中的指令构建的，Dockerfile中的每条指令都会创建一个镜像层，并且每层都是只读的，这一系列的镜像层就构成了Docker镜像。接下来以一个Dockerfile文件为例进行说明，具体如下列代码示例所示。
```js
 1	FROM ubuntu:16.04
 2	COPY . /app
 3	RUN make /app
 4	CMD python /app/app.py
```  
   上述文件示例中的Dockerfile包含了4条指令，每条指令都会创建一个镜像层，其中每一层与前一层都有所不同，并且是层层叠加的。通过镜像构建容器时，会在镜像层上增加一个容器层（即可写层），所有对容器的更改都会写入容器层，这也是Docker默认的数据存储方式。  
  下面通过一个效果图进行说明，具体如下图所示。
![alt](/article_img/docker/6.png)
  从图中可以看出，Docker容器和镜像之间的主要区别是顶部的容器层，而所有对容器中数据的添加、修改等操作都会被存储在容器层中。当容器被删除时，容器层也会被删除，其中存储的数据会被一同删除，而下面的镜像层却保持不变。  
  由于所有的容器都是通过镜像构建的，所以每个容器都有各自的容器层，对于容器数据的更改就会保存在各自的容器层中。也就是说，由同一个镜像构建的多个容器，它们会拥有相同的底部镜像层，而拥有不同的容器层，多个容器可以访问相同的镜像层，并且有自己的独立数据状态。具体说明如下图所示。 
![alt](/article_img/docker/7.png)
  从图中可以看出，基于同一个镜像构建的多个容器可以共享该镜像层，但是多个容器想要共享相同的数据，就需要将这些数据存储到容器之外的地方，而这种方式就是下一节要提到的Docker volume数据外部挂载机制。  

**2. Docker数据存储方式**    
  在默认情况下，Docker中的数据都是存放在容器层的，但是这样存储数据却有较多的缺陷，具体表现如下。    
  ●当容器不再运行时，容器中的数据无法持久化保存，如果另一个进程需要这些数据，那么将很难从容器中获取数据；  
  ●容器层与正在运行的主机紧密耦合，不能轻易地移动数据；  
  ●容器层需要一个存储驱动程序来管理文件系统，存储驱动程序提供了一个使用Linux内核的联合文件系统，这种额外的抽象化降低了性能。  
  基于上述种种原因，多数情况下Docker数据管理都不会直接将数据写入容器层，而是使用另一种叫做Docker volume数据外部挂载的机制进行数据管理。  
  针对Docker volume数据外部挂载机制，Docker提供了三种不同的方式将数据从容器映射到Docker宿主机，他们分别为：volumes（数据卷）、bind mounts（绑定挂载）和tmpfs mounts（tmpfs挂载）。这三种数据管理方式的具体选择，需要结合实际情况进行考虑，其中的volumes数据卷是最常用也是官方推荐的数据管理方式。无论选择使用哪种数据管理方式，数据在容器内看起来都一样的，而在容器外则会被被挂载到文件系统中的某个目录或文件中。    
  下面通过一张图来展示数据卷、绑定挂载和tmpfs挂载之间的差异，如下图所示。  
![alt](/article_img/docker/8.png)
  从图中可以看出，Docker提供的三种数据管理方式略有不同，具体分析如下。  
  ●volumes：存储在主机文件系统中（在Linux系统下是存在于/var/lib/Docker/volumes/目录），并由Docker管理，非Docker进程无法修改文件系统的这个部分。  
  ●bind mounts：可以存储在主机系统的任意位置，甚至可能是重要的系统文件或目录，在Docker主机或容器上的非Docker进程可以对他们进行任意修改。  
  ●tmpfs mounts：只存储在主机系统的内存中，并没有写入到主机的文件系统中。


, 2018-12-07, 2021-05-19, 默认分类, Docker,数据管理, true, null, 19, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [6, JDK 8——Lambda表达式介绍,   Lambda表达式是JDK 8中一个重要的新特性，它使用一个清晰简洁的表达式来表达一个接口，同时Lambda表达式也简化了对集合以及数组数据的遍历、过滤和提取等操作。下面，本篇文章就对Lambda表达式进行简要介绍，并进行演示说明。

**1. Lambda表达式入门**  

  匿名内部类存在的一个问题是，如果匿名内部类的实现非常简单，例如只包含一个抽象方法的接口，那么匿名内部类的语法仍然显得比较冗余。为此，JDK 8中新增了一个特性Lambda表达式，这种表达式只针对有一个抽象方法的接口实现，以简洁的表达式形式实现接口功能来作为方法参数。  
  一个Lambda表达式由三个部分组成，分别为参数列表、“->”和表达式主体，其语法格式如下：
```js
 ([数据类型 参数名,数据类型 参数名,...]) -> {表达式主体}
```  
  从上述语法格式上看，Lambda表达式的书写非常简单，下面针对Lambda表达式的组成部分进行简单介绍，具体如下：  
  （1）([数据类型 参数名,数据类型 参数名,...])：用来向表达式主体传递接口方法需要的参数，多个参数名中间必须用英文逗号“,”进行分隔；在编写Lambda表达式时，可以省略参数的数据类型，后面的表达式主体会自动进行校对和匹配；同时，如果只有一个参数，则可以省略括号“()”。  
  （2）->：表示Lambda表达式箭牌，用来指定参数数据指向，不能省略，且必须用英文横线和大于号书写。  
  （3）{表达式主体}：由单个表达式或语句块组成的主体，本质就是接口中抽象方法的具体实现，如果表达式主体只有一条语句，那么可以省略包含主体的大括号；另外，在Lambda表达式主体中允许有返回值，当只有一条return语句时，也可以省略return关键字。  
  了解了Lambda表达式的语法后，接下来编写一个示例文件对Lambda表达式的基本使用进行介绍，具体代码如下所示。
```js
 1	// 定义动物类接口
 2	interface Animal { 
 3		void shout(); // 定义方法shout()
 4	}
 5	public class Example22 {
 6		public static void main(String[] args) {
 7	       String name = "小花"; 
 8	       // 1、匿名内部类作为参数传递给animalShout()方法
 9		  animalShout(new Animal() { 
 10				 public void shout() { 
 11				    System.out.println("匿名内部类输出："+name+"喵喵...");
 12				}
 13		  });
 14		  // 2、使用Lambda表达式作为参数传递给animalShout()方法
 15	       animalShout(()-> System.out.println("Lambda表达式输出："
 16	                                                   +name+"喵喵..."));
 17		}
 18	    // 创建一个animalShout()静态方法，接收接口类型的参数
 19		public static void animalShout(Animal an) {
 20			an.shout();  
 21		}
 22	}
```  
  运行结果下图所示。
![alt](/article_img/lambda/1.jpg)
  上述代码示例中，先定义了只有一个抽象方法的接口Animal，然后分别使用匿名内部类和Lambda表达式的方式实现了接口方法。从图中可以看出，使用匿名内部类和Lambda表达式都能实现接口中方法，但很显然使用Lambda表达式更加简洁和清晰。, 2018-11-27, null, 默认分类, 2018,Lambda表达式, true, null, 18, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [7, 函数式接口, &emsp;&emsp;虽然Lambda表达式可以实现匿名内部类的功能，但在使用时却有一个局限，即接口中有且只有一个抽象方法时才能使用Lamdba表达式代替匿名内部类。这是因为Lamdba表达式是基于函数式接口实现的，所谓函数式接口是指有且仅有一个抽象方法的接口，Lambda表达式就是Java中函数式编程的体现，只有确保接口中有且仅有一个抽象方法，Lambda表达式才能顺利地推导出所实现的这个接口中的方法。  
&emsp;&emsp;在JDK 8中，专门为函数式接口引入了一个@FunctionalInterface注解，该注解只是显示的标注了接口是一个函数式接口，并强制编辑器进行更严格的检查，确保该接口是函数式接口，如果不是函数式接口，那么编译器就会报错，而对程序运行并没有实质上的影响。  
&emsp;&emsp;接下来通过一个案例来演示函数式接口的定义与使用，示例代码如下所示。
```js
 1	// 定义无参、无返回值的函数式接口
 2	@FunctionalInterface
 3	interface Animal {
 4		void shout();
 5	}
 6	// 定义有参、有返回值的函数式接口
 7	interface Calculate {
 8		int sum(int a, int b);
 9	}
 10	public class Example23 {
 11		public static void main(String[] args) {
 12		   // 分别两个函数式接口进行测试
 13		   animalShout(() -> System.out.println("无参、无返回值的函数式接口调用"));
 14		   showSum(10, 20, (x, y) -> x + y);
 15		}
 16		// 创建一个动物叫的方法，并传入接口对象Animal作为参数
 17		private static void animalShout(Animal animal) {
 18			animal.shout();
 19		}
 20		// 创建一个求和的方法，并传入两个int类型以及接口Calculate类型的参数
 21		private static void showSum(int x, int y, Calculate calculate) {
 22		   System.out.println(x + "+" + y + "的和为：" + calculate.sum(x, y));
 23		}
 24	}
```  
&emsp;&emsp;运行结果如下图所示。

![alt](/article_img/lambda/2.jpg)
&emsp;&emsp;上述代码示例中，先定义了两个函数式接口Animal和Calculate，然后在测试类中分别编写了两个静态方法，并将这两个函数式接口以参数的形式传入，最后在main()方法中分别调用这两个静态方法，并将所需要的函数式接口参数以Lambda表达式的形式传入。从图中可以看出，程序中函数式接口的定义和使用完全正确。
, 2018-12-01, null, 默认分类, 接口,函数式接口, true, null, 12, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20003} created. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20003} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20003} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20003} executed. 0.6671 millis. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20003, rs-50003} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20003, rs-50003} Header: [count(0)]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20003, rs-50003} Result: [12]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20003, rs-50003} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20003} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20004} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20004} Parameters : [5]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20004} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20004} executed. 0.5081 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 108, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20004} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20005} created. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20005} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20005} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20005} executed. 0.5328 millis. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20005, rs-50005} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20005, rs-50005} Header: [count(0)]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20005, rs-50005} Result: [12]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20005, rs-50005} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20005} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20006} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20006} Parameters : [5]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20006} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20006} executed. 0.5041 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20006, rs-50006} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20006, rs-50006} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20006, rs-50006} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 108, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20006, rs-50006} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20006, rs-50006} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20006, rs-50006} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20006, rs-50006} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20006, rs-50006} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20006} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20007} created. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20007} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20007} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20007} executed. 0.5334 millis. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20007, rs-50007} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20007, rs-50007} Header: [count(0)]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20007, rs-50007} Result: [12]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20007, rs-50007} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20007} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20008} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20008} Parameters : [5]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20008} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20008} executed. 0.4576 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20008, rs-50008} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20008, rs-50008} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20008, rs-50008} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 108, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20008, rs-50008} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20008, rs-50008} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20008, rs-50008} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20008, rs-50008} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20008, rs-50008} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20008} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20009} created. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20009} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20009} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20009} executed. 0.4936 millis. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20009, rs-50009} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20009, rs-50009} Header: [count(0)]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20009, rs-50009} Result: [12]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20009, rs-50009} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20009} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20010} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20010} Parameters : [5]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20010} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20010} executed. 0.7675 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20010, rs-50010} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20010, rs-50010} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20010, rs-50010} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 108, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20010, rs-50010} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20010, rs-50010} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20010, rs-50010} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20010, rs-50010} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20010, rs-50010} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20010} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20011} created. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20011} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20011} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20011} executed. 0.493 millis. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20011, rs-50011} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20011, rs-50011} Header: [count(0)]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20011, rs-50011} Result: [12]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20011, rs-50011} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20011} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20012} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20012} Parameters : [5]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20012} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20012} executed. 0.5422 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20012, rs-50012} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20012, rs-50012} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20012, rs-50012} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 108, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20012, rs-50012} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20012, rs-50012} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20012, rs-50012} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20012, rs-50012} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20012, rs-50012} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20012} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20013} created. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20013} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20013} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20013} executed. 0.4755 millis. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20013, rs-50013} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20013, rs-50013} Header: [count(0)]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20013, rs-50013} Result: [12]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20013, rs-50013} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20013} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20014} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20014} Parameters : [5]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20014} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20014} executed. 0.4628 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20014, rs-50014} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20014, rs-50014} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20014, rs-50014} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 108, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20014, rs-50014} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20014, rs-50014} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20014, rs-50014} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20014, rs-50014} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20014, rs-50014} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20014} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20015} created. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20015} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20015} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20015} executed. 0.696 millis. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20015, rs-50015} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20015, rs-50015} Header: [count(0)]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20015, rs-50015} Result: [12]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20015, rs-50015} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20015} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20016} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20016} Parameters : [5]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20016} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20016} executed. 0.7338 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20016, rs-50016} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20016, rs-50016} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20016, rs-50016} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 108, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20016, rs-50016} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20016, rs-50016} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20016, rs-50016} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20016, rs-50016} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20016, rs-50016} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20016} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20017} created. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20017} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20017} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20017} executed. 0.4677 millis. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20017, rs-50017} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20017, rs-50017} Header: [count(0)]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20017, rs-50017} Result: [12]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20017, rs-50017} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20017} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20018} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ?, ? 
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20018} Parameters : [5, 5]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20018} Types : [INTEGER, INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20018} executed. 0.5134 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ?, ? 
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20018, rs-50018} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20018, rs-50018} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20018, rs-50018} Result: [6, JDK 8——Lambda表达式介绍,   Lambda表达式是JDK 8中一个重要的新特性，它使用一个清晰简洁的表达式来表达一个接口，同时Lambda表达式也简化了对集合以及数组数据的遍历、过滤和提取等操作。下面，本篇文章就对Lambda表达式进行简要介绍，并进行演示说明。

**1. Lambda表达式入门**  

  匿名内部类存在的一个问题是，如果匿名内部类的实现非常简单，例如只包含一个抽象方法的接口，那么匿名内部类的语法仍然显得比较冗余。为此，JDK 8中新增了一个特性Lambda表达式，这种表达式只针对有一个抽象方法的接口实现，以简洁的表达式形式实现接口功能来作为方法参数。  
  一个Lambda表达式由三个部分组成，分别为参数列表、“->”和表达式主体，其语法格式如下：
```js
 ([数据类型 参数名,数据类型 参数名,...]) -> {表达式主体}
```  
  从上述语法格式上看，Lambda表达式的书写非常简单，下面针对Lambda表达式的组成部分进行简单介绍，具体如下：  
  （1）([数据类型 参数名,数据类型 参数名,...])：用来向表达式主体传递接口方法需要的参数，多个参数名中间必须用英文逗号“,”进行分隔；在编写Lambda表达式时，可以省略参数的数据类型，后面的表达式主体会自动进行校对和匹配；同时，如果只有一个参数，则可以省略括号“()”。  
  （2）->：表示Lambda表达式箭牌，用来指定参数数据指向，不能省略，且必须用英文横线和大于号书写。  
  （3）{表达式主体}：由单个表达式或语句块组成的主体，本质就是接口中抽象方法的具体实现，如果表达式主体只有一条语句，那么可以省略包含主体的大括号；另外，在Lambda表达式主体中允许有返回值，当只有一条return语句时，也可以省略return关键字。  
  了解了Lambda表达式的语法后，接下来编写一个示例文件对Lambda表达式的基本使用进行介绍，具体代码如下所示。
```js
 1	// 定义动物类接口
 2	interface Animal { 
 3		void shout(); // 定义方法shout()
 4	}
 5	public class Example22 {
 6		public static void main(String[] args) {
 7	       String name = "小花"; 
 8	       // 1、匿名内部类作为参数传递给animalShout()方法
 9		  animalShout(new Animal() { 
 10				 public void shout() { 
 11				    System.out.println("匿名内部类输出："+name+"喵喵...");
 12				}
 13		  });
 14		  // 2、使用Lambda表达式作为参数传递给animalShout()方法
 15	       animalShout(()-> System.out.println("Lambda表达式输出："
 16	                                                   +name+"喵喵..."));
 17		}
 18	    // 创建一个animalShout()静态方法，接收接口类型的参数
 19		public static void animalShout(Animal an) {
 20			an.shout();  
 21		}
 22	}
```  
  运行结果下图所示。
![alt](/article_img/lambda/1.jpg)
  上述代码示例中，先定义了只有一个抽象方法的接口Animal，然后分别使用匿名内部类和Lambda表达式的方式实现了接口方法。从图中可以看出，使用匿名内部类和Lambda表达式都能实现接口中方法，但很显然使用Lambda表达式更加简洁和清晰。, 2018-11-27, null, 默认分类, 2018,Lambda表达式, true, null, 18, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20018, rs-50018} Result: [7, 函数式接口, &emsp;&emsp;虽然Lambda表达式可以实现匿名内部类的功能，但在使用时却有一个局限，即接口中有且只有一个抽象方法时才能使用Lamdba表达式代替匿名内部类。这是因为Lamdba表达式是基于函数式接口实现的，所谓函数式接口是指有且仅有一个抽象方法的接口，Lambda表达式就是Java中函数式编程的体现，只有确保接口中有且仅有一个抽象方法，Lambda表达式才能顺利地推导出所实现的这个接口中的方法。  
&emsp;&emsp;在JDK 8中，专门为函数式接口引入了一个@FunctionalInterface注解，该注解只是显示的标注了接口是一个函数式接口，并强制编辑器进行更严格的检查，确保该接口是函数式接口，如果不是函数式接口，那么编译器就会报错，而对程序运行并没有实质上的影响。  
&emsp;&emsp;接下来通过一个案例来演示函数式接口的定义与使用，示例代码如下所示。
```js
 1	// 定义无参、无返回值的函数式接口
 2	@FunctionalInterface
 3	interface Animal {
 4		void shout();
 5	}
 6	// 定义有参、有返回值的函数式接口
 7	interface Calculate {
 8		int sum(int a, int b);
 9	}
 10	public class Example23 {
 11		public static void main(String[] args) {
 12		   // 分别两个函数式接口进行测试
 13		   animalShout(() -> System.out.println("无参、无返回值的函数式接口调用"));
 14		   showSum(10, 20, (x, y) -> x + y);
 15		}
 16		// 创建一个动物叫的方法，并传入接口对象Animal作为参数
 17		private static void animalShout(Animal animal) {
 18			animal.shout();
 19		}
 20		// 创建一个求和的方法，并传入两个int类型以及接口Calculate类型的参数
 21		private static void showSum(int x, int y, Calculate calculate) {
 22		   System.out.println(x + "+" + y + "的和为：" + calculate.sum(x, y));
 23		}
 24	}
```  
&emsp;&emsp;运行结果如下图所示。

![alt](/article_img/lambda/2.jpg)
&emsp;&emsp;上述代码示例中，先定义了两个函数式接口Animal和Calculate，然后在测试类中分别编写了两个静态方法，并将这两个函数式接口以参数的形式传入，最后在main()方法中分别调用这两个静态方法，并将所需要的函数式接口参数以Lambda表达式的形式传入。从图中可以看出，程序中函数式接口的定义和使用完全正确。
, 2018-12-01, null, 默认分类, 接口,函数式接口, true, null, 12, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20018, rs-50018} Result: [8, JDK 8——聚合操作, &emsp;&emsp;在Java8版本中，JDK包含许多聚合操作（如平均值，总和，最小，最大，和计数），返回一个计算流stream的聚合结果。这些聚合操作被称为聚合操作。JDK除返回单个值的聚合操作外，还有很多聚合操作返回一个collection集合实例。很多的reduce操作执行特定的任务，如求平均值或按类别分组元素。  

**1. 聚合操作简介**

  在开发中，多数情况下会涉及到对集合、数组中元素的操作，在JDK 8之前都是通过普通的循环遍历出每一个元素，然后还会穿插一些if条件语句选择性的对元素进行查找、过滤、修改等操作，这种原始的操作方法虽然可行，但是代码量较大并且执行效率较低。  
  为此，JDK 8中新增了一个Stream接口，该接口可以将集合、数组的中的元素转换为Stream流的形式，并结合Lambda表达式的优势来进一步简化集合、数组中元素的查找、过滤、转换等操作，这一新功能就是JDK 8中的聚合操作。  
  在程序中，使用聚合操作没有绝对的语法规范，根据实际操作流程，主要可以分为以下3个步骤：  
  （1）将原始集合或者数组对象转换为Stream流对象；  
  （2）对Stream流对象中的元素进行一系列的过滤、查找等中间操作（Intermediate Operations），然后仍然返回一个Stream流对象；  
  （3）对Stream流进行遍历、统计、收集等终结操作（Terminal Operation），获取想要的结果。  
  接下来，就根据上面聚合操作的3个步骤，通过一个案例来演示聚合操作的基本用法，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example31 {
 4		public static void main(String[] args) {
 5	          // 创建一个List集合对象
 6			List<String> list = new ArrayList<>(); 
 7			list.add("张三");
 8			list.add("李四");
 9			list.add("张小明");
 10			list.add("张阳");
 11			// 1、创建一个Stream流对象
 12			Stream<String> stream = list.stream();
 13			// 2、对Stream流中的元素分别进行过滤、截取操作
 14		       Stream<String> stream2 = stream.filter(i -> i.startsWith("张"));
 15			Stream<String> stream3 = stream2.limit(2);
 16			// 3、对Stream流中的元素进行终结操作，进行遍历输出
 17			stream3.forEach(j -> System.out.println(j));
 18			System.out.println("=======");
 19	         // 通过链式表达式的形式完成聚合操作
 20			list.stream().filter(i -> i.startsWith("张"))
 21						 .limit(2)
 22						 .forEach(j -> System.out.println(j));
 23		}
 24	}
``` 
   运行结果如下图所示。
![alt](/article_img/lambda/3.jpg)
  上述示例代码中，先创建了一个List集合，然后根据聚合操作的3个步骤实现了集合对象的聚合操作，对集合中的元素使用Stream流的形式进行过滤（filter）、截取（limit），并进行遍历输出。其中第12~17行代码分步骤详细展示了聚合操作，而第20~22行代码是使用了链式表达式（调用有返回值的方法时不获取返回值而是直接再调用另一个方法）实现了聚合操作，该表达式的语法格式更简洁、高效，这种链式调用也被称为操作管道流。

**2. 创建Stream流对象**  
  在上一小节中，介绍了聚合操作的主要使用步骤，其中首要解决的问题就是创建Stream流对象。聚合操作针对的就是可迭代数据进行的操作，如集合、数组等，所以创建Stream流对象其实就是将集合、数组等通过一些方法转换为Stream流对象。  
  在Java中，集合对象有对应的集合类，可以通过集合类提供的静态方法创建Stream流对象，而数组数据却没有对应的数组类，所以必须通过其他方法创建Stream流对象。针对不同的源数据，Java提供了多种创建Stream流对象的方式，分别如下：  
  （1）所有的Collections集合都可以使用stream()静态方法获取Stream流对象；  
  （2）Stream接口的of()静态方法可以获取基本类型包装类数组、引用类型数组和单个元素的Stream流对象；  
  （3）Arrays数组工具类的stream()静态方法也可以获取数组元素的Stream流对象。  
  接下来，通过一个案例来学习聚合操作中如何创建Stream流对象，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example32 {
 4		public static void main(String[] args) {
 5	          // 创建一个数组
 6			Integer[] array = { 9, 8, 3, 5, 2 };       
 7	          // 将数组转换为List集合
 8			List<Integer> list = Arrays.asList(array); 
 9			// 1、使用集合对象的stream()静态方法创建Stream流对象
 10			Stream<Integer> stream = list.stream();
 11			stream.forEach(i -> System.out.print(i+" "));
 12			System.out.println();
 13			// 2、使用Stream接口的of()静态方法创建Stream流对象
 14			Stream<Integer> stream2 = Stream.of(array);
 15			stream2.forEach(i -> System.out.print(i+" "));
 16			System.out.println();
 17			// 3、使用Arrays数组工具类的stream()静态方法创建Stream流对象
 18			Stream<Integer> stream3 = Arrays.stream(array);
 19			stream3.forEach(i -> System.out.print(i+" "));
 20		}
 21	}
```  
  运行结果如下图所示。
![alt](/article_img/lambda/4.jpg)
  上述示例代码中，先创建了一个数组和一个集合，然后通过三种方式实现了Stream流对象的创建，并通过Stream流对象的forEach()方法结合Lambda表达式完成了集合和数组中元素的遍历。  

**小提示：**  
  在JDK 8中，只针对单列集合Collections接口对象提供了stream()静态方法获取Stream流对象，并未对Map集合提供相关方法获取Stream流对象，所以想要用Map集合创建Stream流对象必须先通过Map集合的keySet()、values()、entrySet()等方法将Map集合转换为单列Set集合，然后再使用单列集合的stream()静态方法获取对应键、值集合的Stream流对象。

, 2018-12-02, null, 默认分类, JDK 8,聚合操作, true, null, 36, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20018, rs-50018} Result: [9, 虚拟化容器技术——Docker运行机制介绍,   Docker是一个开源的应用容器引擎，它基于go语言开发，并遵从Apache2.0开源协议。使用Docker可以让开发者封装他们的应用以及依赖包到一个可移植的容器中，然后发布到任意的Linux机器上，也可以实现虚拟化。Docker容器完全使用沙箱机制，相互之间不会有任何接口，这保证了容器之间的安全性。  

**1. Docker的引擎介绍**

  Docker Engine（Docker引擎）是Docker的核心部分，使用的是客户端-服务器（C/S）架构模式，其主要组成部分如下图所示。
![alt](/article_img/docker/1.png)
  从上图可以看出，Docker Engine中包含了三个核心组件（docker CLI、REST API和docker daemon），这三个组件的具体说明如下：  
  ①docker CLI（command line interface）：表示Docker命令行接口，开发者可以在命令行中使用Docker相关指令与Docker守护进程进行交互，从而管理诸如image（镜像）、container（容器）、network（网络）和data volumes（数据卷）等实体。  
  ②REST API：表示应用程序API接口，开发者通过该API接口可以与Docker的守护进程进行交互，从而指示后台进行相关操作。  
  ③docker daemon：表示Docker的服务端组件，他是Docker架构中运行在后台的一个守护进程，可以接收并处理来自命令行接口及API接口的指令，然后进行相应的后台操作。  
  对于开发者而言，既可以使用编写好的脚本文件通过REST API来实现与Docker进程交互，又可以直接使用Docker相关指令通过命令行接口来与Docker进程交互，而其他一些Docker应用则是通过底层的API和CLI进行交互的。

**2. Docker的架构介绍**

  了解了Docker内部引擎及作用后，我们还需要通过Docker的具体架构，来了解Docker的整个运行流程。接下来借助Docker官网的架构图来对Docker架构进行详细说明，如下图所示。
![alt](/article_img/docker/2.jpg)
  从图中可以看出，Docker架构主要包括Client、DOCKER_HOST和Register三部分，关于这三部分的具体说明如下。  
&emsp;&emsp;**（1）Client（客户端）**  
  Client即Docker客户端，也就是上一小节Docker Engine中介绍的docker CLI。开发者通过这个客户端使用Docker的相关指令与Docker守护进程进行交互，从而进行Docker镜像的创建、拉取和运行等操作。  
&emsp;&emsp;**（2）DOCKER_HOST（Docker主机）**  
  DOCKER_HOST即Docker内部引擎运行的主机，主要指Docker daemon（Docker守护进程）。可以通过Docker守护进程与客户端还有Docker的镜像仓库Registry进行交互，从而管理Images（镜像）和Containers（容器）等。  
&emsp;&emsp;**（3）Registry（注册中心）**  
  Registry即Docker注册中心，实质就是Docker镜像仓库，默认使用的是Docker官方远程注册中心Docker Hub，也可以使用开发者搭建的本地仓库。Registry中包含了大量的镜像，这些镜像可以是官网基础镜像，也可以是其他开发者上传的镜像。  
  我们在实际使用Docker时，除了会涉及到图中的三个主要部分外，还会涉及到很多Docker Objects（Docker对象），例如Images（镜像）、Containers（容器）、Networks（网络）、Volumes（数据卷）、Plugins（插件）等。其中常用的两个对象Image和Containers的说明如下。  
  ①Images（镜像）  
  Docker 镜像就是一个只读的模板，包含了一些创建Docker容器的操作指令。通常情况下，一个Docker镜像是基于另一个基础镜像创建的，并且新创建的镜像会额外包含一些功能配置。例如：开发者可以依赖于一个Ubuntu的基础镜像创建一个新镜像，并可以在新镜像中安装Apache等软件或其它应用程序。  
  ②Containers（容器）  
  Docker容器属于镜像的一个可运行实例（镜像与容器的关系其实与Java中的类与对象相似），开发者可以通过API接口或者CLI命令行接口来创建、运行、停止、移动、删除一个容器，也可以将一个容器连接到一个或多个网络中，将数据存储与容器进行关联。



, 2018-12-03, null, 默认分类, 虚拟化容器,Docker,运行机制, true, null, 26, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20018, rs-50018} Result: [10, Docker常用客户端指令介绍,   在使用Docker之前，首先会为对应的项目编写Dockerfile镜像构建文件，然后通过Docker的相关指令进行镜像构建，完成镜像的构建后，就可以使用这些项目镜像进行启动测试了。所以要想知道如何使用Docker来执行这些Dockerfile镜像构建文件，还需要学习Docker客户端的常用指令，本篇文章将对Docker客户端的常用指令进行详细讲解。  

**1.列出镜像**  
  通过docker images指令可以查看本地镜像列表中已有的镜像，具体使用方式如下。
```js
$ docker images
```  
  执行上述指令后，系统会将所有本地镜像都展示出来，如下图所示。
![alt](/article_img/docker/3.png)
  从图中可以看出，系统终端将本地镜像列表中的3个镜像分5列进行了展示，每一列的具体含义如下。  
  ●REPOSITORY：镜像名称。  
  ●TAG：镜像的参数，类似于版本号，默认是latest。  
  ●IMAGE ID：镜像ID，是唯一值。此处看到的是一个长度为12的字符串，实际上它是64位完整镜像ID的缩写形式。  
  ●CREATED：距今创建镜像的时间。  
  ●SIZE：镜像大小。    

**2.搜索镜像**  
  想知道在Docker Hub中包含了哪些镜像，除了可以登录Docker Hub，在官网中心进行查看外，还可以直接在Docker客户端进行查询。例如想要查询Ubuntu镜像，可以使用如下指令。
```js
$ docker search ubuntu
```  
  执行上述指令后，系统终端就会将搜索到的有关Ubuntu的镜像展示出来，如下图所示。
![alt](/article_img/docker/4.png)
  从图所示的结果可以看出，系统终端分5列将搜索到的Ubuntu相关镜像都列举出来了，这5列的具体含义如下。  
  ●NAME：表示镜像的名称，这里有两种格式的名称，其中不带有“/”的表示官方镜像，而带有“/”的表示其他用户的公开镜像。公开镜像“/”前面是用户在Docker Hub上的用户名（唯一），后面是对应的镜像名；官方镜像与用户镜像，除了从镜像名称上可以区分外，还可以通过第4列的OFFICIAL声明中看出（该列下内容为OK表示官方镜像）。  
  ●DESCRIPTION：表示镜像的描述，这里只显示了一小部分。  
  ●STARS：表示该镜像的收藏数，用户可以在Docker Hub上对镜像进行收藏，一般可以通过该数字反应出该镜像的受欢迎程度。  
  ●OFFICIAL：表示是否为官方镜像。  
  ●AUTOMATED：表示是否自动构建镜像。例如，用户可以将自己的Docker Hub绑定到如Github上，当代码提交更新后，可以自动构建镜像。   
 
**3.拉取镜像**  
  通过docker pull指令可以拉取仓库镜像到本地（默认都是拉取Docker Hub仓库镜像，也可以指定“IP+端口”拉取某个Docker机器上的私有仓库镜像），具体使用方式如下。
```js
$ docker pull ubuntu
```  
  执行上述指令后，Docker会自动从Docker Hub上下载最新版本的Ubuntu到本地，当然也可以使用以下指令拉取指定版本的镜像到本地，具体指令如下。
```js
$ docker pull ubuntu:14.04
```  
**4.构建镜像**  
  除了可以通过docker pull指令从仓库拉取镜像外，还可以通过docker build指令构建Docker镜像，通常情况下都是通过Dockerfile文件来构建镜像的。  
  这里假设linux系统home目录下/shitou/workspace/dockerspace文件夹中编写有对应的Dockerfile文件，则构建镜像直立示例如下所示。 
```js
$ docker build -t hellodocker3 /home/shitou/workspace/dockerspace/.
```
**5.删除镜像**  
  当本地存放过多不需要的镜像时，可以通过docker rmi指令将其删除。在删除镜像时，需要指定镜像名称或镜像ID。删除镜像的使用方式如下。
```js
$ docker rmi -f hellodocker2 hellodocker3
```  
  上述指令中，docker rmi表示删除镜像，-f表示进行强制删除，而hellodocker2和hellodocker3分别表示需要删除的镜像名称，这里同时删除两个镜像。除了根据名称删除镜像外，还也可以根据镜像ID来删除镜像，只是这里如果指定了删除ID为23c617a866d4的镜像后，会同时删除hellodocker、hellodocker2和hellodocker3三个镜像。  
  需要特别强调的是，在进行镜像删除操作时，如果是通过镜像ID进行镜像删除，那么由该镜像创建的容器必须提前删除或停止。另外，在通过镜像名称操作镜像时，如果出现镜像重名的情况，必须在镜像名称后面指定镜像标签tag参数来确保唯一性。

**6.创建并启动容器**  
  Docker镜像主要用于创建容器，可以使用docker run指令创建并启动容器，具体使用方式如下。
```js
$ docker run -d -p 5000:80 --name test hellodocker
```  
  上述创建并启动容器的指令略微复杂，具体分析如下。  
  ●docker run：表示创建并启动一个容器，而后面的hellodocker就表示要启动运行的镜像名称；  
  ●-d：表示容器启动时在后台运行；  
  ●-p 5000:80：表示将容器内暴露的80端口映射到宿主机指定的5000端口，也可以将-p 5000:80更改为-P来映射主机的随机端口（注意p字母的大小写）；  
  ●--name test：表示为创建后的容器指定名称为test，如果没有该参数配置，则生成的容器会设置一个随机名称。  
  docker run命令是Docker操作中较为复杂的一个，它可以携带多个参数和参数，我们可以通过docker run --help指令进行查看，其中有些参数如-e、-v和-w等都可以在Dockerfile文件中预先声明。 
 
**7.列出容器**  
  生成容器后，可以通过docker ps指令查看当前运行的所有容器，具体使用方式如下。
```js
$ docker ps
```  
  执行上述命令后，会将所有当前运行的容器都展示出来，具体如下图所示。
![alt](/article_img/docker/5.png)
  从图中可以看出，系统终端通过7列对当前的正在运行的一个容器进行了展示，图中每一列的具体含义如下。  
  ●CONTAINER ID：表示生成的容器ID；  
  ●IMAGE：表示生成该容器的镜像名称；  
  ●COMMAND：表示启动容器时运行的命令，Docker要求在启动容器时必须运行一个命令；  
  ●CREATED：表示容器创建的时间；  
  ●STATUS：表示容器运行状态，例如Up表示运行中，Exited表示已停止；  
  ●PORTS：表示容器内部暴露的端口映射到主机的端口；  
  ●NAMES：表示生成容器的名称，由Docker引擎自动生成，可以像上述示例中使用--name参数指定生成容器的名称。  
  另外，docker ps指令运行过程中可以指定多个参数，还可以通过docker ps --help指令对ps指令的其他信息进行查看。

**8.删除容器**  
  当不需要使用容器时，则可以使用docker rm指令删除已停止的容器，具体使用方式如下。
```js
$ docker rm f0c9a8b6e8c5
```  
  需要注意的是，上述指令只能删除已经停止运行的容器，而不能删除正在运行的容器。如果想要删除正在运行的容器，则需要添加-f参数强制删除，具体使用方式如下。
```js
$ docker rm -f f0c9a8b6e8c5
```  
  当需要删除的容器过多时，如果还一个个的删除就略显麻烦了，此时可以通过如下指令将全部容器删除。
```js
$ docker rm -f $(docker ps -aq)
```  
  上述指令中，首先会通过$(docker ps -aq)获取所有容器的ID，然后通过docker rm -f指令进行强制删除。如果开发者有自己特殊的删除需求，可以根据前面docker ps指令进行组装来获取需要删除的容器ID。  
  Docker提供的操作指令远不止这些，这里就不一一列举了，想要了解更多Docker的操作指令，可以通过docker --help指令进行查看。


, 2018-12-05, null, 默认分类, Docker,客户端指令, true, null, 21, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20018, rs-50018} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20018} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20019} created. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20019} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20019} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20019} executed. 0.5093 millis. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20019, rs-50019} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20019, rs-50019} Header: [count(0)]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20019, rs-50019} Result: [12]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20019, rs-50019} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20019} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20020} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20020} Parameters : [5]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20020} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20020} executed. 0.4087 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20020, rs-50020} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20020, rs-50020} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20020, rs-50020} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 108, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20020, rs-50020} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20020, rs-50020} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20020, rs-50020} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20020, rs-50020} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20020, rs-50020} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20020} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20021} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20021} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20021} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20021} executed. 0.6579 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20021, rs-50021} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20021, rs-50021} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20021, rs-50021} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 108, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20021, rs-50021} Result: [12, Spring Boot 2 权威发布,   如果这两天登录 [https://start.spring.io/ ](https://start.spring.io/ )就会发现，Spring Boot 默认版本已经升到了 2.1.0。这是因为 Spring Boot 刚刚发布了 2.1.0 版本，我们来看下 Spring Boot 2 发布以来第一个子版本都发布了哪些内容？  

**2.1 中的新特性**     
  ●将spring-boot-starter-oauth2-oidc-client重命名为spring-boot-starter-oauth2-client命名更简洁  
  ●添加 OAuth2 资源服务 starter，OAuth2 一个用于认证的组件  
  ●支持 ConditionalOnBean 和 ConditionalOnMissingBean 下的参数化容器  
  ●自动配置 applicationTaskExecutor bean 的延迟加载来避免不必要的日志记录  
  ●将 DatabaseDriver＃SAP 重命名为 DatabaseDriver  
  ●跳过重启器不仅适用于 JUnit4，也适用于 JUnit5  
  ●在 Jest HealthIndicator 中使用集群端点  
  ●当 DevTools 禁用重启时添加日志输出  
  ●添加注解：@ConditionalOnMissingServletFilter提高 Servlet Filters 的自动装配。
  
**2.1 中的组件升级**  
  ●升级 Hibernate 5.3，Hibernate 的支持升级到了 5.3  
  ●升级 Tomcat 9 ，支持最新的 tomcat 9  
  ●支持 Java 11，Java 现在更新越来越快，Spring 快赶不上了    
  ●升级 Thymeleaf Extras Springsecurity 到 3.0.4.RELEASE ，thymeleaf-extras-springsecurity 是 Thymeleaf 提供集成 Spring Security 的组件  
  ●升级 Joda Time 2.10.1，Joda-Time， 面向 Java 应用程序的日期/时间库的替代选择，Joda-Time 令时间和日期值变得易于管理、操作和理解。  
  ●升级 Lettuce 5.1.2.RELEASE ，Lettuce 前面说过，传说中 Redis 最快的客户端。  
  ●升级 Reactor Californium-SR2 ，Californium 是物联网云服务的 Java COAP 实现。因此，它更专注的是可扩展性和可用性而不是像嵌入式设备那样关注资源效率。不过，Californium 也适合嵌入式的 JVM。  
  ●升级 Maven Failsafe Plugin 2.22.1 ，Maven 中的测试插件。  
  ●升级 Flyway 5.2.1 ， Flyway是一款开源的数据库版本管理工具  
  ●升级 Aspectj 1.9.2 ，AspectJ 是 Java 中流行的 AOP（Aspect-oriented Programming）编程扩展框架，是 Eclipse 托管给 Apache 基金会的一个开源项目。  
  ●升级 Mysql 8.0.13 ，Mysql 支持到 8。  
  ●...  
  更多的详细内容可以参考这里：[Spring Boot 2.1 Release Notes](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.1-Release-Notes)
, 2018-12-12, 2021-05-21, 默认分类, Spring Boot 2, true, null, 62, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20021, rs-50021} Result: [8, JDK 8——聚合操作, &emsp;&emsp;在Java8版本中，JDK包含许多聚合操作（如平均值，总和，最小，最大，和计数），返回一个计算流stream的聚合结果。这些聚合操作被称为聚合操作。JDK除返回单个值的聚合操作外，还有很多聚合操作返回一个collection集合实例。很多的reduce操作执行特定的任务，如求平均值或按类别分组元素。  

**1. 聚合操作简介**

  在开发中，多数情况下会涉及到对集合、数组中元素的操作，在JDK 8之前都是通过普通的循环遍历出每一个元素，然后还会穿插一些if条件语句选择性的对元素进行查找、过滤、修改等操作，这种原始的操作方法虽然可行，但是代码量较大并且执行效率较低。  
  为此，JDK 8中新增了一个Stream接口，该接口可以将集合、数组的中的元素转换为Stream流的形式，并结合Lambda表达式的优势来进一步简化集合、数组中元素的查找、过滤、转换等操作，这一新功能就是JDK 8中的聚合操作。  
  在程序中，使用聚合操作没有绝对的语法规范，根据实际操作流程，主要可以分为以下3个步骤：  
  （1）将原始集合或者数组对象转换为Stream流对象；  
  （2）对Stream流对象中的元素进行一系列的过滤、查找等中间操作（Intermediate Operations），然后仍然返回一个Stream流对象；  
  （3）对Stream流进行遍历、统计、收集等终结操作（Terminal Operation），获取想要的结果。  
  接下来，就根据上面聚合操作的3个步骤，通过一个案例来演示聚合操作的基本用法，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example31 {
 4		public static void main(String[] args) {
 5	          // 创建一个List集合对象
 6			List<String> list = new ArrayList<>(); 
 7			list.add("张三");
 8			list.add("李四");
 9			list.add("张小明");
 10			list.add("张阳");
 11			// 1、创建一个Stream流对象
 12			Stream<String> stream = list.stream();
 13			// 2、对Stream流中的元素分别进行过滤、截取操作
 14		       Stream<String> stream2 = stream.filter(i -> i.startsWith("张"));
 15			Stream<String> stream3 = stream2.limit(2);
 16			// 3、对Stream流中的元素进行终结操作，进行遍历输出
 17			stream3.forEach(j -> System.out.println(j));
 18			System.out.println("=======");
 19	         // 通过链式表达式的形式完成聚合操作
 20			list.stream().filter(i -> i.startsWith("张"))
 21						 .limit(2)
 22						 .forEach(j -> System.out.println(j));
 23		}
 24	}
``` 
   运行结果如下图所示。
![alt](/article_img/lambda/3.jpg)
  上述示例代码中，先创建了一个List集合，然后根据聚合操作的3个步骤实现了集合对象的聚合操作，对集合中的元素使用Stream流的形式进行过滤（filter）、截取（limit），并进行遍历输出。其中第12~17行代码分步骤详细展示了聚合操作，而第20~22行代码是使用了链式表达式（调用有返回值的方法时不获取返回值而是直接再调用另一个方法）实现了聚合操作，该表达式的语法格式更简洁、高效，这种链式调用也被称为操作管道流。

**2. 创建Stream流对象**  
  在上一小节中，介绍了聚合操作的主要使用步骤，其中首要解决的问题就是创建Stream流对象。聚合操作针对的就是可迭代数据进行的操作，如集合、数组等，所以创建Stream流对象其实就是将集合、数组等通过一些方法转换为Stream流对象。  
  在Java中，集合对象有对应的集合类，可以通过集合类提供的静态方法创建Stream流对象，而数组数据却没有对应的数组类，所以必须通过其他方法创建Stream流对象。针对不同的源数据，Java提供了多种创建Stream流对象的方式，分别如下：  
  （1）所有的Collections集合都可以使用stream()静态方法获取Stream流对象；  
  （2）Stream接口的of()静态方法可以获取基本类型包装类数组、引用类型数组和单个元素的Stream流对象；  
  （3）Arrays数组工具类的stream()静态方法也可以获取数组元素的Stream流对象。  
  接下来，通过一个案例来学习聚合操作中如何创建Stream流对象，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example32 {
 4		public static void main(String[] args) {
 5	          // 创建一个数组
 6			Integer[] array = { 9, 8, 3, 5, 2 };       
 7	          // 将数组转换为List集合
 8			List<Integer> list = Arrays.asList(array); 
 9			// 1、使用集合对象的stream()静态方法创建Stream流对象
 10			Stream<Integer> stream = list.stream();
 11			stream.forEach(i -> System.out.print(i+" "));
 12			System.out.println();
 13			// 2、使用Stream接口的of()静态方法创建Stream流对象
 14			Stream<Integer> stream2 = Stream.of(array);
 15			stream2.forEach(i -> System.out.print(i+" "));
 16			System.out.println();
 17			// 3、使用Arrays数组工具类的stream()静态方法创建Stream流对象
 18			Stream<Integer> stream3 = Arrays.stream(array);
 19			stream3.forEach(i -> System.out.print(i+" "));
 20		}
 21	}
```  
  运行结果如下图所示。
![alt](/article_img/lambda/4.jpg)
  上述示例代码中，先创建了一个数组和一个集合，然后通过三种方式实现了Stream流对象的创建，并通过Stream流对象的forEach()方法结合Lambda表达式完成了集合和数组中元素的遍历。  

**小提示：**  
  在JDK 8中，只针对单列集合Collections接口对象提供了stream()静态方法获取Stream流对象，并未对Map集合提供相关方法获取Stream流对象，所以想要用Map集合创建Stream流对象必须先通过Map集合的keySet()、values()、entrySet()等方法将Map集合转换为单列Set集合，然后再使用单列集合的stream()静态方法获取对应键、值集合的Stream流对象。

, 2018-12-02, null, 默认分类, JDK 8,聚合操作, true, null, 36, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20021, rs-50021} Result: [9, 虚拟化容器技术——Docker运行机制介绍,   Docker是一个开源的应用容器引擎，它基于go语言开发，并遵从Apache2.0开源协议。使用Docker可以让开发者封装他们的应用以及依赖包到一个可移植的容器中，然后发布到任意的Linux机器上，也可以实现虚拟化。Docker容器完全使用沙箱机制，相互之间不会有任何接口，这保证了容器之间的安全性。  

**1. Docker的引擎介绍**

  Docker Engine（Docker引擎）是Docker的核心部分，使用的是客户端-服务器（C/S）架构模式，其主要组成部分如下图所示。
![alt](/article_img/docker/1.png)
  从上图可以看出，Docker Engine中包含了三个核心组件（docker CLI、REST API和docker daemon），这三个组件的具体说明如下：  
  ①docker CLI（command line interface）：表示Docker命令行接口，开发者可以在命令行中使用Docker相关指令与Docker守护进程进行交互，从而管理诸如image（镜像）、container（容器）、network（网络）和data volumes（数据卷）等实体。  
  ②REST API：表示应用程序API接口，开发者通过该API接口可以与Docker的守护进程进行交互，从而指示后台进行相关操作。  
  ③docker daemon：表示Docker的服务端组件，他是Docker架构中运行在后台的一个守护进程，可以接收并处理来自命令行接口及API接口的指令，然后进行相应的后台操作。  
  对于开发者而言，既可以使用编写好的脚本文件通过REST API来实现与Docker进程交互，又可以直接使用Docker相关指令通过命令行接口来与Docker进程交互，而其他一些Docker应用则是通过底层的API和CLI进行交互的。

**2. Docker的架构介绍**

  了解了Docker内部引擎及作用后，我们还需要通过Docker的具体架构，来了解Docker的整个运行流程。接下来借助Docker官网的架构图来对Docker架构进行详细说明，如下图所示。
![alt](/article_img/docker/2.jpg)
  从图中可以看出，Docker架构主要包括Client、DOCKER_HOST和Register三部分，关于这三部分的具体说明如下。  
&emsp;&emsp;**（1）Client（客户端）**  
  Client即Docker客户端，也就是上一小节Docker Engine中介绍的docker CLI。开发者通过这个客户端使用Docker的相关指令与Docker守护进程进行交互，从而进行Docker镜像的创建、拉取和运行等操作。  
&emsp;&emsp;**（2）DOCKER_HOST（Docker主机）**  
  DOCKER_HOST即Docker内部引擎运行的主机，主要指Docker daemon（Docker守护进程）。可以通过Docker守护进程与客户端还有Docker的镜像仓库Registry进行交互，从而管理Images（镜像）和Containers（容器）等。  
&emsp;&emsp;**（3）Registry（注册中心）**  
  Registry即Docker注册中心，实质就是Docker镜像仓库，默认使用的是Docker官方远程注册中心Docker Hub，也可以使用开发者搭建的本地仓库。Registry中包含了大量的镜像，这些镜像可以是官网基础镜像，也可以是其他开发者上传的镜像。  
  我们在实际使用Docker时，除了会涉及到图中的三个主要部分外，还会涉及到很多Docker Objects（Docker对象），例如Images（镜像）、Containers（容器）、Networks（网络）、Volumes（数据卷）、Plugins（插件）等。其中常用的两个对象Image和Containers的说明如下。  
  ①Images（镜像）  
  Docker 镜像就是一个只读的模板，包含了一些创建Docker容器的操作指令。通常情况下，一个Docker镜像是基于另一个基础镜像创建的，并且新创建的镜像会额外包含一些功能配置。例如：开发者可以依赖于一个Ubuntu的基础镜像创建一个新镜像，并可以在新镜像中安装Apache等软件或其它应用程序。  
  ②Containers（容器）  
  Docker容器属于镜像的一个可运行实例（镜像与容器的关系其实与Java中的类与对象相似），开发者可以通过API接口或者CLI命令行接口来创建、运行、停止、移动、删除一个容器，也可以将一个容器连接到一个或多个网络中，将数据存储与容器进行关联。



, 2018-12-03, null, 默认分类, 虚拟化容器,Docker,运行机制, true, null, 26, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20021, rs-50021} Result: [10, Docker常用客户端指令介绍,   在使用Docker之前，首先会为对应的项目编写Dockerfile镜像构建文件，然后通过Docker的相关指令进行镜像构建，完成镜像的构建后，就可以使用这些项目镜像进行启动测试了。所以要想知道如何使用Docker来执行这些Dockerfile镜像构建文件，还需要学习Docker客户端的常用指令，本篇文章将对Docker客户端的常用指令进行详细讲解。  

**1.列出镜像**  
  通过docker images指令可以查看本地镜像列表中已有的镜像，具体使用方式如下。
```js
$ docker images
```  
  执行上述指令后，系统会将所有本地镜像都展示出来，如下图所示。
![alt](/article_img/docker/3.png)
  从图中可以看出，系统终端将本地镜像列表中的3个镜像分5列进行了展示，每一列的具体含义如下。  
  ●REPOSITORY：镜像名称。  
  ●TAG：镜像的参数，类似于版本号，默认是latest。  
  ●IMAGE ID：镜像ID，是唯一值。此处看到的是一个长度为12的字符串，实际上它是64位完整镜像ID的缩写形式。  
  ●CREATED：距今创建镜像的时间。  
  ●SIZE：镜像大小。    

**2.搜索镜像**  
  想知道在Docker Hub中包含了哪些镜像，除了可以登录Docker Hub，在官网中心进行查看外，还可以直接在Docker客户端进行查询。例如想要查询Ubuntu镜像，可以使用如下指令。
```js
$ docker search ubuntu
```  
  执行上述指令后，系统终端就会将搜索到的有关Ubuntu的镜像展示出来，如下图所示。
![alt](/article_img/docker/4.png)
  从图所示的结果可以看出，系统终端分5列将搜索到的Ubuntu相关镜像都列举出来了，这5列的具体含义如下。  
  ●NAME：表示镜像的名称，这里有两种格式的名称，其中不带有“/”的表示官方镜像，而带有“/”的表示其他用户的公开镜像。公开镜像“/”前面是用户在Docker Hub上的用户名（唯一），后面是对应的镜像名；官方镜像与用户镜像，除了从镜像名称上可以区分外，还可以通过第4列的OFFICIAL声明中看出（该列下内容为OK表示官方镜像）。  
  ●DESCRIPTION：表示镜像的描述，这里只显示了一小部分。  
  ●STARS：表示该镜像的收藏数，用户可以在Docker Hub上对镜像进行收藏，一般可以通过该数字反应出该镜像的受欢迎程度。  
  ●OFFICIAL：表示是否为官方镜像。  
  ●AUTOMATED：表示是否自动构建镜像。例如，用户可以将自己的Docker Hub绑定到如Github上，当代码提交更新后，可以自动构建镜像。   
 
**3.拉取镜像**  
  通过docker pull指令可以拉取仓库镜像到本地（默认都是拉取Docker Hub仓库镜像，也可以指定“IP+端口”拉取某个Docker机器上的私有仓库镜像），具体使用方式如下。
```js
$ docker pull ubuntu
```  
  执行上述指令后，Docker会自动从Docker Hub上下载最新版本的Ubuntu到本地，当然也可以使用以下指令拉取指定版本的镜像到本地，具体指令如下。
```js
$ docker pull ubuntu:14.04
```  
**4.构建镜像**  
  除了可以通过docker pull指令从仓库拉取镜像外，还可以通过docker build指令构建Docker镜像，通常情况下都是通过Dockerfile文件来构建镜像的。  
  这里假设linux系统home目录下/shitou/workspace/dockerspace文件夹中编写有对应的Dockerfile文件，则构建镜像直立示例如下所示。 
```js
$ docker build -t hellodocker3 /home/shitou/workspace/dockerspace/.
```
**5.删除镜像**  
  当本地存放过多不需要的镜像时，可以通过docker rmi指令将其删除。在删除镜像时，需要指定镜像名称或镜像ID。删除镜像的使用方式如下。
```js
$ docker rmi -f hellodocker2 hellodocker3
```  
  上述指令中，docker rmi表示删除镜像，-f表示进行强制删除，而hellodocker2和hellodocker3分别表示需要删除的镜像名称，这里同时删除两个镜像。除了根据名称删除镜像外，还也可以根据镜像ID来删除镜像，只是这里如果指定了删除ID为23c617a866d4的镜像后，会同时删除hellodocker、hellodocker2和hellodocker3三个镜像。  
  需要特别强调的是，在进行镜像删除操作时，如果是通过镜像ID进行镜像删除，那么由该镜像创建的容器必须提前删除或停止。另外，在通过镜像名称操作镜像时，如果出现镜像重名的情况，必须在镜像名称后面指定镜像标签tag参数来确保唯一性。

**6.创建并启动容器**  
  Docker镜像主要用于创建容器，可以使用docker run指令创建并启动容器，具体使用方式如下。
```js
$ docker run -d -p 5000:80 --name test hellodocker
```  
  上述创建并启动容器的指令略微复杂，具体分析如下。  
  ●docker run：表示创建并启动一个容器，而后面的hellodocker就表示要启动运行的镜像名称；  
  ●-d：表示容器启动时在后台运行；  
  ●-p 5000:80：表示将容器内暴露的80端口映射到宿主机指定的5000端口，也可以将-p 5000:80更改为-P来映射主机的随机端口（注意p字母的大小写）；  
  ●--name test：表示为创建后的容器指定名称为test，如果没有该参数配置，则生成的容器会设置一个随机名称。  
  docker run命令是Docker操作中较为复杂的一个，它可以携带多个参数和参数，我们可以通过docker run --help指令进行查看，其中有些参数如-e、-v和-w等都可以在Dockerfile文件中预先声明。 
 
**7.列出容器**  
  生成容器后，可以通过docker ps指令查看当前运行的所有容器，具体使用方式如下。
```js
$ docker ps
```  
  执行上述命令后，会将所有当前运行的容器都展示出来，具体如下图所示。
![alt](/article_img/docker/5.png)
  从图中可以看出，系统终端通过7列对当前的正在运行的一个容器进行了展示，图中每一列的具体含义如下。  
  ●CONTAINER ID：表示生成的容器ID；  
  ●IMAGE：表示生成该容器的镜像名称；  
  ●COMMAND：表示启动容器时运行的命令，Docker要求在启动容器时必须运行一个命令；  
  ●CREATED：表示容器创建的时间；  
  ●STATUS：表示容器运行状态，例如Up表示运行中，Exited表示已停止；  
  ●PORTS：表示容器内部暴露的端口映射到主机的端口；  
  ●NAMES：表示生成容器的名称，由Docker引擎自动生成，可以像上述示例中使用--name参数指定生成容器的名称。  
  另外，docker ps指令运行过程中可以指定多个参数，还可以通过docker ps --help指令对ps指令的其他信息进行查看。

**8.删除容器**  
  当不需要使用容器时，则可以使用docker rm指令删除已停止的容器，具体使用方式如下。
```js
$ docker rm f0c9a8b6e8c5
```  
  需要注意的是，上述指令只能删除已经停止运行的容器，而不能删除正在运行的容器。如果想要删除正在运行的容器，则需要添加-f参数强制删除，具体使用方式如下。
```js
$ docker rm -f f0c9a8b6e8c5
```  
  当需要删除的容器过多时，如果还一个个的删除就略显麻烦了，此时可以通过如下指令将全部容器删除。
```js
$ docker rm -f $(docker ps -aq)
```  
  上述指令中，首先会通过$(docker ps -aq)获取所有容器的ID，然后通过docker rm -f指令进行强制删除。如果开发者有自己特殊的删除需求，可以根据前面docker ps指令进行组装来获取需要删除的容器ID。  
  Docker提供的操作指令远不止这些，这里就不一一列举了，想要了解更多Docker的操作指令，可以通过docker --help指令进行查看。


, 2018-12-05, null, 默认分类, Docker,客户端指令, true, null, 21, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20021, rs-50021} Result: [11, Docker数据管理介绍,   当我们对容器进行相关操作时，产生的一系列数据都会存储在容器中，而Docker内部又是如果管理这些数据的呢？本篇文章将针对Docker数据管理的一些知识进行介绍。
  
**1. Docker数据存储机制**  
  使用Docker时，我们操作的都是镜像和由镜像生成的容器，所以想要更好的了解Docker内部的数据存储机制，就必须从镜像、容器与数据存储的关系出发。  
  Docker镜像是通过读取Dockerfile文件中的指令构建的，Dockerfile中的每条指令都会创建一个镜像层，并且每层都是只读的，这一系列的镜像层就构成了Docker镜像。接下来以一个Dockerfile文件为例进行说明，具体如下列代码示例所示。
```js
 1	FROM ubuntu:16.04
 2	COPY . /app
 3	RUN make /app
 4	CMD python /app/app.py
```  
   上述文件示例中的Dockerfile包含了4条指令，每条指令都会创建一个镜像层，其中每一层与前一层都有所不同，并且是层层叠加的。通过镜像构建容器时，会在镜像层上增加一个容器层（即可写层），所有对容器的更改都会写入容器层，这也是Docker默认的数据存储方式。  
  下面通过一个效果图进行说明，具体如下图所示。
![alt](/article_img/docker/6.png)
  从图中可以看出，Docker容器和镜像之间的主要区别是顶部的容器层，而所有对容器中数据的添加、修改等操作都会被存储在容器层中。当容器被删除时，容器层也会被删除，其中存储的数据会被一同删除，而下面的镜像层却保持不变。  
  由于所有的容器都是通过镜像构建的，所以每个容器都有各自的容器层，对于容器数据的更改就会保存在各自的容器层中。也就是说，由同一个镜像构建的多个容器，它们会拥有相同的底部镜像层，而拥有不同的容器层，多个容器可以访问相同的镜像层，并且有自己的独立数据状态。具体说明如下图所示。 
![alt](/article_img/docker/7.png)
  从图中可以看出，基于同一个镜像构建的多个容器可以共享该镜像层，但是多个容器想要共享相同的数据，就需要将这些数据存储到容器之外的地方，而这种方式就是下一节要提到的Docker volume数据外部挂载机制。  

**2. Docker数据存储方式**    
  在默认情况下，Docker中的数据都是存放在容器层的，但是这样存储数据却有较多的缺陷，具体表现如下。    
  ●当容器不再运行时，容器中的数据无法持久化保存，如果另一个进程需要这些数据，那么将很难从容器中获取数据；  
  ●容器层与正在运行的主机紧密耦合，不能轻易地移动数据；  
  ●容器层需要一个存储驱动程序来管理文件系统，存储驱动程序提供了一个使用Linux内核的联合文件系统，这种额外的抽象化降低了性能。  
  基于上述种种原因，多数情况下Docker数据管理都不会直接将数据写入容器层，而是使用另一种叫做Docker volume数据外部挂载的机制进行数据管理。  
  针对Docker volume数据外部挂载机制，Docker提供了三种不同的方式将数据从容器映射到Docker宿主机，他们分别为：volumes（数据卷）、bind mounts（绑定挂载）和tmpfs mounts（tmpfs挂载）。这三种数据管理方式的具体选择，需要结合实际情况进行考虑，其中的volumes数据卷是最常用也是官方推荐的数据管理方式。无论选择使用哪种数据管理方式，数据在容器内看起来都一样的，而在容器外则会被被挂载到文件系统中的某个目录或文件中。    
  下面通过一张图来展示数据卷、绑定挂载和tmpfs挂载之间的差异，如下图所示。  
![alt](/article_img/docker/8.png)
  从图中可以看出，Docker提供的三种数据管理方式略有不同，具体分析如下。  
  ●volumes：存储在主机文件系统中（在Linux系统下是存在于/var/lib/Docker/volumes/目录），并由Docker管理，非Docker进程无法修改文件系统的这个部分。  
  ●bind mounts：可以存储在主机系统的任意位置，甚至可能是重要的系统文件或目录，在Docker主机或容器上的非Docker进程可以对他们进行任意修改。  
  ●tmpfs mounts：只存储在主机系统的内存中，并没有写入到主机的文件系统中。


, 2018-12-07, 2021-05-19, 默认分类, Docker,数据管理, true, null, 19, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20021, rs-50021} Result: [6, JDK 8——Lambda表达式介绍,   Lambda表达式是JDK 8中一个重要的新特性，它使用一个清晰简洁的表达式来表达一个接口，同时Lambda表达式也简化了对集合以及数组数据的遍历、过滤和提取等操作。下面，本篇文章就对Lambda表达式进行简要介绍，并进行演示说明。

**1. Lambda表达式入门**  

  匿名内部类存在的一个问题是，如果匿名内部类的实现非常简单，例如只包含一个抽象方法的接口，那么匿名内部类的语法仍然显得比较冗余。为此，JDK 8中新增了一个特性Lambda表达式，这种表达式只针对有一个抽象方法的接口实现，以简洁的表达式形式实现接口功能来作为方法参数。  
  一个Lambda表达式由三个部分组成，分别为参数列表、“->”和表达式主体，其语法格式如下：
```js
 ([数据类型 参数名,数据类型 参数名,...]) -> {表达式主体}
```  
  从上述语法格式上看，Lambda表达式的书写非常简单，下面针对Lambda表达式的组成部分进行简单介绍，具体如下：  
  （1）([数据类型 参数名,数据类型 参数名,...])：用来向表达式主体传递接口方法需要的参数，多个参数名中间必须用英文逗号“,”进行分隔；在编写Lambda表达式时，可以省略参数的数据类型，后面的表达式主体会自动进行校对和匹配；同时，如果只有一个参数，则可以省略括号“()”。  
  （2）->：表示Lambda表达式箭牌，用来指定参数数据指向，不能省略，且必须用英文横线和大于号书写。  
  （3）{表达式主体}：由单个表达式或语句块组成的主体，本质就是接口中抽象方法的具体实现，如果表达式主体只有一条语句，那么可以省略包含主体的大括号；另外，在Lambda表达式主体中允许有返回值，当只有一条return语句时，也可以省略return关键字。  
  了解了Lambda表达式的语法后，接下来编写一个示例文件对Lambda表达式的基本使用进行介绍，具体代码如下所示。
```js
 1	// 定义动物类接口
 2	interface Animal { 
 3		void shout(); // 定义方法shout()
 4	}
 5	public class Example22 {
 6		public static void main(String[] args) {
 7	       String name = "小花"; 
 8	       // 1、匿名内部类作为参数传递给animalShout()方法
 9		  animalShout(new Animal() { 
 10				 public void shout() { 
 11				    System.out.println("匿名内部类输出："+name+"喵喵...");
 12				}
 13		  });
 14		  // 2、使用Lambda表达式作为参数传递给animalShout()方法
 15	       animalShout(()-> System.out.println("Lambda表达式输出："
 16	                                                   +name+"喵喵..."));
 17		}
 18	    // 创建一个animalShout()静态方法，接收接口类型的参数
 19		public static void animalShout(Animal an) {
 20			an.shout();  
 21		}
 22	}
```  
  运行结果下图所示。
![alt](/article_img/lambda/1.jpg)
  上述代码示例中，先定义了只有一个抽象方法的接口Animal，然后分别使用匿名内部类和Lambda表达式的方式实现了接口方法。从图中可以看出，使用匿名内部类和Lambda表达式都能实现接口中方法，但很显然使用Lambda表达式更加简洁和清晰。, 2018-11-27, null, 默认分类, 2018,Lambda表达式, true, null, 18, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20021, rs-50021} Result: [7, 函数式接口, &emsp;&emsp;虽然Lambda表达式可以实现匿名内部类的功能，但在使用时却有一个局限，即接口中有且只有一个抽象方法时才能使用Lamdba表达式代替匿名内部类。这是因为Lamdba表达式是基于函数式接口实现的，所谓函数式接口是指有且仅有一个抽象方法的接口，Lambda表达式就是Java中函数式编程的体现，只有确保接口中有且仅有一个抽象方法，Lambda表达式才能顺利地推导出所实现的这个接口中的方法。  
&emsp;&emsp;在JDK 8中，专门为函数式接口引入了一个@FunctionalInterface注解，该注解只是显示的标注了接口是一个函数式接口，并强制编辑器进行更严格的检查，确保该接口是函数式接口，如果不是函数式接口，那么编译器就会报错，而对程序运行并没有实质上的影响。  
&emsp;&emsp;接下来通过一个案例来演示函数式接口的定义与使用，示例代码如下所示。
```js
 1	// 定义无参、无返回值的函数式接口
 2	@FunctionalInterface
 3	interface Animal {
 4		void shout();
 5	}
 6	// 定义有参、有返回值的函数式接口
 7	interface Calculate {
 8		int sum(int a, int b);
 9	}
 10	public class Example23 {
 11		public static void main(String[] args) {
 12		   // 分别两个函数式接口进行测试
 13		   animalShout(() -> System.out.println("无参、无返回值的函数式接口调用"));
 14		   showSum(10, 20, (x, y) -> x + y);
 15		}
 16		// 创建一个动物叫的方法，并传入接口对象Animal作为参数
 17		private static void animalShout(Animal animal) {
 18			animal.shout();
 19		}
 20		// 创建一个求和的方法，并传入两个int类型以及接口Calculate类型的参数
 21		private static void showSum(int x, int y, Calculate calculate) {
 22		   System.out.println(x + "+" + y + "的和为：" + calculate.sum(x, y));
 23		}
 24	}
```  
&emsp;&emsp;运行结果如下图所示。

![alt](/article_img/lambda/2.jpg)
&emsp;&emsp;上述代码示例中，先定义了两个函数式接口Animal和Calculate，然后在测试类中分别编写了两个静态方法，并将这两个函数式接口以参数的形式传入，最后在main()方法中分别调用这两个静态方法，并将所需要的函数式接口参数以Lambda表达式的形式传入。从图中可以看出，程序中函数式接口的定义和使用完全正确。
, 2018-12-01, null, 默认分类, 接口,函数式接口, true, null, 12, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20021, rs-50021} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20021, rs-50021} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20021, rs-50021} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20021, rs-50021} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20021, rs-50021} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20021} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20022} created. update t_statistic set hits = hits+1 where article_id=?;
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20022} Parameters : [1]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20022} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20022} executed. 2.5463 millis. update t_statistic set hits = hits+1 where article_id=?;
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20022} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20023} created. select * from t_comment where article_id=?
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20023} Parameters : [1]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20023} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20023} executed. 2.6978 millis. select * from t_comment where article_id=?
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20023, rs-50022} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20023, rs-50022} Header: [id, article_id, created, ip, c_content, status, author]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20023, rs-50022} Result: [9, 1, 2018-12-13, 0:0:0:0:0:0:0:1, 非常不错，赞一个！, approved, 李四]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20023, rs-50022} Result: [10, 1, 2018-12-13, 0:0:0:0:0:0:0:1, 博主，这资料怎么弄的？有相关资源和教材推荐吗？, approved, 李四]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20023, rs-50022} Result: [11, 1, 2018-12-13, 0:0:0:0:0:0:0:1, 很详细，感谢..., approved, 东方不败]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20023, rs-50022} Result: [12, 1, 2018-12-13, 0:0:0:0:0:0:0:1, 很全，努力学习中..., approved, 东方不败]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20023, rs-50022} Result: [13, 1, 2018-12-13, 0:0:0:0:0:0:0:1, 好东西，先收藏起来，哈哈, approved, tom]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20023, rs-50022} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20023} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20024} created. SELECT count(0) FROM t_comment WHERE article_id = ?
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20024} Parameters : [1]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20024} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20024} executed. 0.5225 millis. SELECT count(0) FROM t_comment WHERE article_id = ?
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20024, rs-50023} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20024, rs-50023} Header: [count(0)]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20024, rs-50023} Result: [5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20024, rs-50023} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20024} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20025} created. select * from t_comment where article_id=? LIMIT ? 
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20025} Parameters : [1, 3]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20025} Types : [INTEGER, INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20025} executed. 0.3133 millis. select * from t_comment where article_id=? LIMIT ? 
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20025, rs-50024} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20025, rs-50024} Header: [id, article_id, created, ip, c_content, status, author]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20025, rs-50024} Result: [9, 1, 2018-12-13, 0:0:0:0:0:0:0:1, 非常不错，赞一个！, approved, 李四]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20025, rs-50024} Result: [10, 1, 2018-12-13, 0:0:0:0:0:0:0:1, 博主，这资料怎么弄的？有相关资源和教材推荐吗？, approved, 李四]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20025, rs-50024} Result: [11, 1, 2018-12-13, 0:0:0:0:0:0:0:1, 很详细，感谢..., approved, 东方不败]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20025, rs-50024} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20025} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20026} created. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20026} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20026} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20026} executed. 0.498 millis. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20026, rs-50025} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20026, rs-50025} Header: [count(0)]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20026, rs-50025} Result: [12]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20026, rs-50025} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20026} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20027} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20027} Parameters : [5]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20027} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20027} executed. 0.4297 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20027, rs-50026} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20027, rs-50026} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20027, rs-50026} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 109, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20027, rs-50026} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20027, rs-50026} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20027, rs-50026} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20027, rs-50026} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20027, rs-50026} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20027} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20028} created. update t_statistic set hits = hits+1 where article_id=?;
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20028} Parameters : [1]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20028} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20028} executed. 2.7702 millis. update t_statistic set hits = hits+1 where article_id=?;
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20028} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20029} created. select * from t_comment where article_id=?
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20029} Parameters : [1]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20029} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20029} executed. 0.3966 millis. select * from t_comment where article_id=?
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20029, rs-50027} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20029, rs-50027} Header: [id, article_id, created, ip, c_content, status, author]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20029, rs-50027} Result: [9, 1, 2018-12-13, 0:0:0:0:0:0:0:1, 非常不错，赞一个！, approved, 李四]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20029, rs-50027} Result: [10, 1, 2018-12-13, 0:0:0:0:0:0:0:1, 博主，这资料怎么弄的？有相关资源和教材推荐吗？, approved, 李四]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20029, rs-50027} Result: [11, 1, 2018-12-13, 0:0:0:0:0:0:0:1, 很详细，感谢..., approved, 东方不败]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20029, rs-50027} Result: [12, 1, 2018-12-13, 0:0:0:0:0:0:0:1, 很全，努力学习中..., approved, 东方不败]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20029, rs-50027} Result: [13, 1, 2018-12-13, 0:0:0:0:0:0:0:1, 好东西，先收藏起来，哈哈, approved, tom]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20029, rs-50027} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20029} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20030} created. SELECT count(0) FROM t_comment WHERE article_id = ?
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20030} Parameters : [1]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20030} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20030} executed. 0.3762 millis. SELECT count(0) FROM t_comment WHERE article_id = ?
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20030, rs-50028} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20030, rs-50028} Header: [count(0)]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20030, rs-50028} Result: [5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20030, rs-50028} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20030} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20031} created. select * from t_comment where article_id=? LIMIT ? 
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20031} Parameters : [1, 3]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20031} Types : [INTEGER, INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20031} executed. 0.3279 millis. select * from t_comment where article_id=? LIMIT ? 
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20031, rs-50029} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20031, rs-50029} Header: [id, article_id, created, ip, c_content, status, author]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20031, rs-50029} Result: [9, 1, 2018-12-13, 0:0:0:0:0:0:0:1, 非常不错，赞一个！, approved, 李四]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20031, rs-50029} Result: [10, 1, 2018-12-13, 0:0:0:0:0:0:0:1, 博主，这资料怎么弄的？有相关资源和教材推荐吗？, approved, 李四]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20031, rs-50029} Result: [11, 1, 2018-12-13, 0:0:0:0:0:0:0:1, 很详细，感谢..., approved, 东方不败]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20031, rs-50029} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20031} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20032} created. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20032} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20032} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20032} executed. 0.4621 millis. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20032, rs-50030} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20032, rs-50030} Header: [count(0)]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20032, rs-50030} Result: [12]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20032, rs-50030} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20032} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20033} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20033} Parameters : [5]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20033} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20033} executed. 0.428 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20033, rs-50031} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20033, rs-50031} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20033, rs-50031} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20033, rs-50031} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20033, rs-50031} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20033, rs-50031} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20033, rs-50031} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20033, rs-50031} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20033} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20034} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20034} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20034} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20034} executed. 0.6594 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20034, rs-50032} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20034, rs-50032} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20034, rs-50032} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20034, rs-50032} Result: [12, Spring Boot 2 权威发布,   如果这两天登录 [https://start.spring.io/ ](https://start.spring.io/ )就会发现，Spring Boot 默认版本已经升到了 2.1.0。这是因为 Spring Boot 刚刚发布了 2.1.0 版本，我们来看下 Spring Boot 2 发布以来第一个子版本都发布了哪些内容？  

**2.1 中的新特性**     
  ●将spring-boot-starter-oauth2-oidc-client重命名为spring-boot-starter-oauth2-client命名更简洁  
  ●添加 OAuth2 资源服务 starter，OAuth2 一个用于认证的组件  
  ●支持 ConditionalOnBean 和 ConditionalOnMissingBean 下的参数化容器  
  ●自动配置 applicationTaskExecutor bean 的延迟加载来避免不必要的日志记录  
  ●将 DatabaseDriver＃SAP 重命名为 DatabaseDriver  
  ●跳过重启器不仅适用于 JUnit4，也适用于 JUnit5  
  ●在 Jest HealthIndicator 中使用集群端点  
  ●当 DevTools 禁用重启时添加日志输出  
  ●添加注解：@ConditionalOnMissingServletFilter提高 Servlet Filters 的自动装配。
  
**2.1 中的组件升级**  
  ●升级 Hibernate 5.3，Hibernate 的支持升级到了 5.3  
  ●升级 Tomcat 9 ，支持最新的 tomcat 9  
  ●支持 Java 11，Java 现在更新越来越快，Spring 快赶不上了    
  ●升级 Thymeleaf Extras Springsecurity 到 3.0.4.RELEASE ，thymeleaf-extras-springsecurity 是 Thymeleaf 提供集成 Spring Security 的组件  
  ●升级 Joda Time 2.10.1，Joda-Time， 面向 Java 应用程序的日期/时间库的替代选择，Joda-Time 令时间和日期值变得易于管理、操作和理解。  
  ●升级 Lettuce 5.1.2.RELEASE ，Lettuce 前面说过，传说中 Redis 最快的客户端。  
  ●升级 Reactor Californium-SR2 ，Californium 是物联网云服务的 Java COAP 实现。因此，它更专注的是可扩展性和可用性而不是像嵌入式设备那样关注资源效率。不过，Californium 也适合嵌入式的 JVM。  
  ●升级 Maven Failsafe Plugin 2.22.1 ，Maven 中的测试插件。  
  ●升级 Flyway 5.2.1 ， Flyway是一款开源的数据库版本管理工具  
  ●升级 Aspectj 1.9.2 ，AspectJ 是 Java 中流行的 AOP（Aspect-oriented Programming）编程扩展框架，是 Eclipse 托管给 Apache 基金会的一个开源项目。  
  ●升级 Mysql 8.0.13 ，Mysql 支持到 8。  
  ●...  
  更多的详细内容可以参考这里：[Spring Boot 2.1 Release Notes](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.1-Release-Notes)
, 2018-12-12, 2021-05-21, 默认分类, Spring Boot 2, true, null, 62, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20034, rs-50032} Result: [8, JDK 8——聚合操作, &emsp;&emsp;在Java8版本中，JDK包含许多聚合操作（如平均值，总和，最小，最大，和计数），返回一个计算流stream的聚合结果。这些聚合操作被称为聚合操作。JDK除返回单个值的聚合操作外，还有很多聚合操作返回一个collection集合实例。很多的reduce操作执行特定的任务，如求平均值或按类别分组元素。  

**1. 聚合操作简介**

  在开发中，多数情况下会涉及到对集合、数组中元素的操作，在JDK 8之前都是通过普通的循环遍历出每一个元素，然后还会穿插一些if条件语句选择性的对元素进行查找、过滤、修改等操作，这种原始的操作方法虽然可行，但是代码量较大并且执行效率较低。  
  为此，JDK 8中新增了一个Stream接口，该接口可以将集合、数组的中的元素转换为Stream流的形式，并结合Lambda表达式的优势来进一步简化集合、数组中元素的查找、过滤、转换等操作，这一新功能就是JDK 8中的聚合操作。  
  在程序中，使用聚合操作没有绝对的语法规范，根据实际操作流程，主要可以分为以下3个步骤：  
  （1）将原始集合或者数组对象转换为Stream流对象；  
  （2）对Stream流对象中的元素进行一系列的过滤、查找等中间操作（Intermediate Operations），然后仍然返回一个Stream流对象；  
  （3）对Stream流进行遍历、统计、收集等终结操作（Terminal Operation），获取想要的结果。  
  接下来，就根据上面聚合操作的3个步骤，通过一个案例来演示聚合操作的基本用法，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example31 {
 4		public static void main(String[] args) {
 5	          // 创建一个List集合对象
 6			List<String> list = new ArrayList<>(); 
 7			list.add("张三");
 8			list.add("李四");
 9			list.add("张小明");
 10			list.add("张阳");
 11			// 1、创建一个Stream流对象
 12			Stream<String> stream = list.stream();
 13			// 2、对Stream流中的元素分别进行过滤、截取操作
 14		       Stream<String> stream2 = stream.filter(i -> i.startsWith("张"));
 15			Stream<String> stream3 = stream2.limit(2);
 16			// 3、对Stream流中的元素进行终结操作，进行遍历输出
 17			stream3.forEach(j -> System.out.println(j));
 18			System.out.println("=======");
 19	         // 通过链式表达式的形式完成聚合操作
 20			list.stream().filter(i -> i.startsWith("张"))
 21						 .limit(2)
 22						 .forEach(j -> System.out.println(j));
 23		}
 24	}
``` 
   运行结果如下图所示。
![alt](/article_img/lambda/3.jpg)
  上述示例代码中，先创建了一个List集合，然后根据聚合操作的3个步骤实现了集合对象的聚合操作，对集合中的元素使用Stream流的形式进行过滤（filter）、截取（limit），并进行遍历输出。其中第12~17行代码分步骤详细展示了聚合操作，而第20~22行代码是使用了链式表达式（调用有返回值的方法时不获取返回值而是直接再调用另一个方法）实现了聚合操作，该表达式的语法格式更简洁、高效，这种链式调用也被称为操作管道流。

**2. 创建Stream流对象**  
  在上一小节中，介绍了聚合操作的主要使用步骤，其中首要解决的问题就是创建Stream流对象。聚合操作针对的就是可迭代数据进行的操作，如集合、数组等，所以创建Stream流对象其实就是将集合、数组等通过一些方法转换为Stream流对象。  
  在Java中，集合对象有对应的集合类，可以通过集合类提供的静态方法创建Stream流对象，而数组数据却没有对应的数组类，所以必须通过其他方法创建Stream流对象。针对不同的源数据，Java提供了多种创建Stream流对象的方式，分别如下：  
  （1）所有的Collections集合都可以使用stream()静态方法获取Stream流对象；  
  （2）Stream接口的of()静态方法可以获取基本类型包装类数组、引用类型数组和单个元素的Stream流对象；  
  （3）Arrays数组工具类的stream()静态方法也可以获取数组元素的Stream流对象。  
  接下来，通过一个案例来学习聚合操作中如何创建Stream流对象，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example32 {
 4		public static void main(String[] args) {
 5	          // 创建一个数组
 6			Integer[] array = { 9, 8, 3, 5, 2 };       
 7	          // 将数组转换为List集合
 8			List<Integer> list = Arrays.asList(array); 
 9			// 1、使用集合对象的stream()静态方法创建Stream流对象
 10			Stream<Integer> stream = list.stream();
 11			stream.forEach(i -> System.out.print(i+" "));
 12			System.out.println();
 13			// 2、使用Stream接口的of()静态方法创建Stream流对象
 14			Stream<Integer> stream2 = Stream.of(array);
 15			stream2.forEach(i -> System.out.print(i+" "));
 16			System.out.println();
 17			// 3、使用Arrays数组工具类的stream()静态方法创建Stream流对象
 18			Stream<Integer> stream3 = Arrays.stream(array);
 19			stream3.forEach(i -> System.out.print(i+" "));
 20		}
 21	}
```  
  运行结果如下图所示。
![alt](/article_img/lambda/4.jpg)
  上述示例代码中，先创建了一个数组和一个集合，然后通过三种方式实现了Stream流对象的创建，并通过Stream流对象的forEach()方法结合Lambda表达式完成了集合和数组中元素的遍历。  

**小提示：**  
  在JDK 8中，只针对单列集合Collections接口对象提供了stream()静态方法获取Stream流对象，并未对Map集合提供相关方法获取Stream流对象，所以想要用Map集合创建Stream流对象必须先通过Map集合的keySet()、values()、entrySet()等方法将Map集合转换为单列Set集合，然后再使用单列集合的stream()静态方法获取对应键、值集合的Stream流对象。

, 2018-12-02, null, 默认分类, JDK 8,聚合操作, true, null, 36, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20034, rs-50032} Result: [9, 虚拟化容器技术——Docker运行机制介绍,   Docker是一个开源的应用容器引擎，它基于go语言开发，并遵从Apache2.0开源协议。使用Docker可以让开发者封装他们的应用以及依赖包到一个可移植的容器中，然后发布到任意的Linux机器上，也可以实现虚拟化。Docker容器完全使用沙箱机制，相互之间不会有任何接口，这保证了容器之间的安全性。  

**1. Docker的引擎介绍**

  Docker Engine（Docker引擎）是Docker的核心部分，使用的是客户端-服务器（C/S）架构模式，其主要组成部分如下图所示。
![alt](/article_img/docker/1.png)
  从上图可以看出，Docker Engine中包含了三个核心组件（docker CLI、REST API和docker daemon），这三个组件的具体说明如下：  
  ①docker CLI（command line interface）：表示Docker命令行接口，开发者可以在命令行中使用Docker相关指令与Docker守护进程进行交互，从而管理诸如image（镜像）、container（容器）、network（网络）和data volumes（数据卷）等实体。  
  ②REST API：表示应用程序API接口，开发者通过该API接口可以与Docker的守护进程进行交互，从而指示后台进行相关操作。  
  ③docker daemon：表示Docker的服务端组件，他是Docker架构中运行在后台的一个守护进程，可以接收并处理来自命令行接口及API接口的指令，然后进行相应的后台操作。  
  对于开发者而言，既可以使用编写好的脚本文件通过REST API来实现与Docker进程交互，又可以直接使用Docker相关指令通过命令行接口来与Docker进程交互，而其他一些Docker应用则是通过底层的API和CLI进行交互的。

**2. Docker的架构介绍**

  了解了Docker内部引擎及作用后，我们还需要通过Docker的具体架构，来了解Docker的整个运行流程。接下来借助Docker官网的架构图来对Docker架构进行详细说明，如下图所示。
![alt](/article_img/docker/2.jpg)
  从图中可以看出，Docker架构主要包括Client、DOCKER_HOST和Register三部分，关于这三部分的具体说明如下。  
&emsp;&emsp;**（1）Client（客户端）**  
  Client即Docker客户端，也就是上一小节Docker Engine中介绍的docker CLI。开发者通过这个客户端使用Docker的相关指令与Docker守护进程进行交互，从而进行Docker镜像的创建、拉取和运行等操作。  
&emsp;&emsp;**（2）DOCKER_HOST（Docker主机）**  
  DOCKER_HOST即Docker内部引擎运行的主机，主要指Docker daemon（Docker守护进程）。可以通过Docker守护进程与客户端还有Docker的镜像仓库Registry进行交互，从而管理Images（镜像）和Containers（容器）等。  
&emsp;&emsp;**（3）Registry（注册中心）**  
  Registry即Docker注册中心，实质就是Docker镜像仓库，默认使用的是Docker官方远程注册中心Docker Hub，也可以使用开发者搭建的本地仓库。Registry中包含了大量的镜像，这些镜像可以是官网基础镜像，也可以是其他开发者上传的镜像。  
  我们在实际使用Docker时，除了会涉及到图中的三个主要部分外，还会涉及到很多Docker Objects（Docker对象），例如Images（镜像）、Containers（容器）、Networks（网络）、Volumes（数据卷）、Plugins（插件）等。其中常用的两个对象Image和Containers的说明如下。  
  ①Images（镜像）  
  Docker 镜像就是一个只读的模板，包含了一些创建Docker容器的操作指令。通常情况下，一个Docker镜像是基于另一个基础镜像创建的，并且新创建的镜像会额外包含一些功能配置。例如：开发者可以依赖于一个Ubuntu的基础镜像创建一个新镜像，并可以在新镜像中安装Apache等软件或其它应用程序。  
  ②Containers（容器）  
  Docker容器属于镜像的一个可运行实例（镜像与容器的关系其实与Java中的类与对象相似），开发者可以通过API接口或者CLI命令行接口来创建、运行、停止、移动、删除一个容器，也可以将一个容器连接到一个或多个网络中，将数据存储与容器进行关联。



, 2018-12-03, null, 默认分类, 虚拟化容器,Docker,运行机制, true, null, 26, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20034, rs-50032} Result: [10, Docker常用客户端指令介绍,   在使用Docker之前，首先会为对应的项目编写Dockerfile镜像构建文件，然后通过Docker的相关指令进行镜像构建，完成镜像的构建后，就可以使用这些项目镜像进行启动测试了。所以要想知道如何使用Docker来执行这些Dockerfile镜像构建文件，还需要学习Docker客户端的常用指令，本篇文章将对Docker客户端的常用指令进行详细讲解。  

**1.列出镜像**  
  通过docker images指令可以查看本地镜像列表中已有的镜像，具体使用方式如下。
```js
$ docker images
```  
  执行上述指令后，系统会将所有本地镜像都展示出来，如下图所示。
![alt](/article_img/docker/3.png)
  从图中可以看出，系统终端将本地镜像列表中的3个镜像分5列进行了展示，每一列的具体含义如下。  
  ●REPOSITORY：镜像名称。  
  ●TAG：镜像的参数，类似于版本号，默认是latest。  
  ●IMAGE ID：镜像ID，是唯一值。此处看到的是一个长度为12的字符串，实际上它是64位完整镜像ID的缩写形式。  
  ●CREATED：距今创建镜像的时间。  
  ●SIZE：镜像大小。    

**2.搜索镜像**  
  想知道在Docker Hub中包含了哪些镜像，除了可以登录Docker Hub，在官网中心进行查看外，还可以直接在Docker客户端进行查询。例如想要查询Ubuntu镜像，可以使用如下指令。
```js
$ docker search ubuntu
```  
  执行上述指令后，系统终端就会将搜索到的有关Ubuntu的镜像展示出来，如下图所示。
![alt](/article_img/docker/4.png)
  从图所示的结果可以看出，系统终端分5列将搜索到的Ubuntu相关镜像都列举出来了，这5列的具体含义如下。  
  ●NAME：表示镜像的名称，这里有两种格式的名称，其中不带有“/”的表示官方镜像，而带有“/”的表示其他用户的公开镜像。公开镜像“/”前面是用户在Docker Hub上的用户名（唯一），后面是对应的镜像名；官方镜像与用户镜像，除了从镜像名称上可以区分外，还可以通过第4列的OFFICIAL声明中看出（该列下内容为OK表示官方镜像）。  
  ●DESCRIPTION：表示镜像的描述，这里只显示了一小部分。  
  ●STARS：表示该镜像的收藏数，用户可以在Docker Hub上对镜像进行收藏，一般可以通过该数字反应出该镜像的受欢迎程度。  
  ●OFFICIAL：表示是否为官方镜像。  
  ●AUTOMATED：表示是否自动构建镜像。例如，用户可以将自己的Docker Hub绑定到如Github上，当代码提交更新后，可以自动构建镜像。   
 
**3.拉取镜像**  
  通过docker pull指令可以拉取仓库镜像到本地（默认都是拉取Docker Hub仓库镜像，也可以指定“IP+端口”拉取某个Docker机器上的私有仓库镜像），具体使用方式如下。
```js
$ docker pull ubuntu
```  
  执行上述指令后，Docker会自动从Docker Hub上下载最新版本的Ubuntu到本地，当然也可以使用以下指令拉取指定版本的镜像到本地，具体指令如下。
```js
$ docker pull ubuntu:14.04
```  
**4.构建镜像**  
  除了可以通过docker pull指令从仓库拉取镜像外，还可以通过docker build指令构建Docker镜像，通常情况下都是通过Dockerfile文件来构建镜像的。  
  这里假设linux系统home目录下/shitou/workspace/dockerspace文件夹中编写有对应的Dockerfile文件，则构建镜像直立示例如下所示。 
```js
$ docker build -t hellodocker3 /home/shitou/workspace/dockerspace/.
```
**5.删除镜像**  
  当本地存放过多不需要的镜像时，可以通过docker rmi指令将其删除。在删除镜像时，需要指定镜像名称或镜像ID。删除镜像的使用方式如下。
```js
$ docker rmi -f hellodocker2 hellodocker3
```  
  上述指令中，docker rmi表示删除镜像，-f表示进行强制删除，而hellodocker2和hellodocker3分别表示需要删除的镜像名称，这里同时删除两个镜像。除了根据名称删除镜像外，还也可以根据镜像ID来删除镜像，只是这里如果指定了删除ID为23c617a866d4的镜像后，会同时删除hellodocker、hellodocker2和hellodocker3三个镜像。  
  需要特别强调的是，在进行镜像删除操作时，如果是通过镜像ID进行镜像删除，那么由该镜像创建的容器必须提前删除或停止。另外，在通过镜像名称操作镜像时，如果出现镜像重名的情况，必须在镜像名称后面指定镜像标签tag参数来确保唯一性。

**6.创建并启动容器**  
  Docker镜像主要用于创建容器，可以使用docker run指令创建并启动容器，具体使用方式如下。
```js
$ docker run -d -p 5000:80 --name test hellodocker
```  
  上述创建并启动容器的指令略微复杂，具体分析如下。  
  ●docker run：表示创建并启动一个容器，而后面的hellodocker就表示要启动运行的镜像名称；  
  ●-d：表示容器启动时在后台运行；  
  ●-p 5000:80：表示将容器内暴露的80端口映射到宿主机指定的5000端口，也可以将-p 5000:80更改为-P来映射主机的随机端口（注意p字母的大小写）；  
  ●--name test：表示为创建后的容器指定名称为test，如果没有该参数配置，则生成的容器会设置一个随机名称。  
  docker run命令是Docker操作中较为复杂的一个，它可以携带多个参数和参数，我们可以通过docker run --help指令进行查看，其中有些参数如-e、-v和-w等都可以在Dockerfile文件中预先声明。 
 
**7.列出容器**  
  生成容器后，可以通过docker ps指令查看当前运行的所有容器，具体使用方式如下。
```js
$ docker ps
```  
  执行上述命令后，会将所有当前运行的容器都展示出来，具体如下图所示。
![alt](/article_img/docker/5.png)
  从图中可以看出，系统终端通过7列对当前的正在运行的一个容器进行了展示，图中每一列的具体含义如下。  
  ●CONTAINER ID：表示生成的容器ID；  
  ●IMAGE：表示生成该容器的镜像名称；  
  ●COMMAND：表示启动容器时运行的命令，Docker要求在启动容器时必须运行一个命令；  
  ●CREATED：表示容器创建的时间；  
  ●STATUS：表示容器运行状态，例如Up表示运行中，Exited表示已停止；  
  ●PORTS：表示容器内部暴露的端口映射到主机的端口；  
  ●NAMES：表示生成容器的名称，由Docker引擎自动生成，可以像上述示例中使用--name参数指定生成容器的名称。  
  另外，docker ps指令运行过程中可以指定多个参数，还可以通过docker ps --help指令对ps指令的其他信息进行查看。

**8.删除容器**  
  当不需要使用容器时，则可以使用docker rm指令删除已停止的容器，具体使用方式如下。
```js
$ docker rm f0c9a8b6e8c5
```  
  需要注意的是，上述指令只能删除已经停止运行的容器，而不能删除正在运行的容器。如果想要删除正在运行的容器，则需要添加-f参数强制删除，具体使用方式如下。
```js
$ docker rm -f f0c9a8b6e8c5
```  
  当需要删除的容器过多时，如果还一个个的删除就略显麻烦了，此时可以通过如下指令将全部容器删除。
```js
$ docker rm -f $(docker ps -aq)
```  
  上述指令中，首先会通过$(docker ps -aq)获取所有容器的ID，然后通过docker rm -f指令进行强制删除。如果开发者有自己特殊的删除需求，可以根据前面docker ps指令进行组装来获取需要删除的容器ID。  
  Docker提供的操作指令远不止这些，这里就不一一列举了，想要了解更多Docker的操作指令，可以通过docker --help指令进行查看。


, 2018-12-05, null, 默认分类, Docker,客户端指令, true, null, 21, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20034, rs-50032} Result: [11, Docker数据管理介绍,   当我们对容器进行相关操作时，产生的一系列数据都会存储在容器中，而Docker内部又是如果管理这些数据的呢？本篇文章将针对Docker数据管理的一些知识进行介绍。
  
**1. Docker数据存储机制**  
  使用Docker时，我们操作的都是镜像和由镜像生成的容器，所以想要更好的了解Docker内部的数据存储机制，就必须从镜像、容器与数据存储的关系出发。  
  Docker镜像是通过读取Dockerfile文件中的指令构建的，Dockerfile中的每条指令都会创建一个镜像层，并且每层都是只读的，这一系列的镜像层就构成了Docker镜像。接下来以一个Dockerfile文件为例进行说明，具体如下列代码示例所示。
```js
 1	FROM ubuntu:16.04
 2	COPY . /app
 3	RUN make /app
 4	CMD python /app/app.py
```  
   上述文件示例中的Dockerfile包含了4条指令，每条指令都会创建一个镜像层，其中每一层与前一层都有所不同，并且是层层叠加的。通过镜像构建容器时，会在镜像层上增加一个容器层（即可写层），所有对容器的更改都会写入容器层，这也是Docker默认的数据存储方式。  
  下面通过一个效果图进行说明，具体如下图所示。
![alt](/article_img/docker/6.png)
  从图中可以看出，Docker容器和镜像之间的主要区别是顶部的容器层，而所有对容器中数据的添加、修改等操作都会被存储在容器层中。当容器被删除时，容器层也会被删除，其中存储的数据会被一同删除，而下面的镜像层却保持不变。  
  由于所有的容器都是通过镜像构建的，所以每个容器都有各自的容器层，对于容器数据的更改就会保存在各自的容器层中。也就是说，由同一个镜像构建的多个容器，它们会拥有相同的底部镜像层，而拥有不同的容器层，多个容器可以访问相同的镜像层，并且有自己的独立数据状态。具体说明如下图所示。 
![alt](/article_img/docker/7.png)
  从图中可以看出，基于同一个镜像构建的多个容器可以共享该镜像层，但是多个容器想要共享相同的数据，就需要将这些数据存储到容器之外的地方，而这种方式就是下一节要提到的Docker volume数据外部挂载机制。  

**2. Docker数据存储方式**    
  在默认情况下，Docker中的数据都是存放在容器层的，但是这样存储数据却有较多的缺陷，具体表现如下。    
  ●当容器不再运行时，容器中的数据无法持久化保存，如果另一个进程需要这些数据，那么将很难从容器中获取数据；  
  ●容器层与正在运行的主机紧密耦合，不能轻易地移动数据；  
  ●容器层需要一个存储驱动程序来管理文件系统，存储驱动程序提供了一个使用Linux内核的联合文件系统，这种额外的抽象化降低了性能。  
  基于上述种种原因，多数情况下Docker数据管理都不会直接将数据写入容器层，而是使用另一种叫做Docker volume数据外部挂载的机制进行数据管理。  
  针对Docker volume数据外部挂载机制，Docker提供了三种不同的方式将数据从容器映射到Docker宿主机，他们分别为：volumes（数据卷）、bind mounts（绑定挂载）和tmpfs mounts（tmpfs挂载）。这三种数据管理方式的具体选择，需要结合实际情况进行考虑，其中的volumes数据卷是最常用也是官方推荐的数据管理方式。无论选择使用哪种数据管理方式，数据在容器内看起来都一样的，而在容器外则会被被挂载到文件系统中的某个目录或文件中。    
  下面通过一张图来展示数据卷、绑定挂载和tmpfs挂载之间的差异，如下图所示。  
![alt](/article_img/docker/8.png)
  从图中可以看出，Docker提供的三种数据管理方式略有不同，具体分析如下。  
  ●volumes：存储在主机文件系统中（在Linux系统下是存在于/var/lib/Docker/volumes/目录），并由Docker管理，非Docker进程无法修改文件系统的这个部分。  
  ●bind mounts：可以存储在主机系统的任意位置，甚至可能是重要的系统文件或目录，在Docker主机或容器上的非Docker进程可以对他们进行任意修改。  
  ●tmpfs mounts：只存储在主机系统的内存中，并没有写入到主机的文件系统中。


, 2018-12-07, 2021-05-19, 默认分类, Docker,数据管理, true, null, 19, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20034, rs-50032} Result: [6, JDK 8——Lambda表达式介绍,   Lambda表达式是JDK 8中一个重要的新特性，它使用一个清晰简洁的表达式来表达一个接口，同时Lambda表达式也简化了对集合以及数组数据的遍历、过滤和提取等操作。下面，本篇文章就对Lambda表达式进行简要介绍，并进行演示说明。

**1. Lambda表达式入门**  

  匿名内部类存在的一个问题是，如果匿名内部类的实现非常简单，例如只包含一个抽象方法的接口，那么匿名内部类的语法仍然显得比较冗余。为此，JDK 8中新增了一个特性Lambda表达式，这种表达式只针对有一个抽象方法的接口实现，以简洁的表达式形式实现接口功能来作为方法参数。  
  一个Lambda表达式由三个部分组成，分别为参数列表、“->”和表达式主体，其语法格式如下：
```js
 ([数据类型 参数名,数据类型 参数名,...]) -> {表达式主体}
```  
  从上述语法格式上看，Lambda表达式的书写非常简单，下面针对Lambda表达式的组成部分进行简单介绍，具体如下：  
  （1）([数据类型 参数名,数据类型 参数名,...])：用来向表达式主体传递接口方法需要的参数，多个参数名中间必须用英文逗号“,”进行分隔；在编写Lambda表达式时，可以省略参数的数据类型，后面的表达式主体会自动进行校对和匹配；同时，如果只有一个参数，则可以省略括号“()”。  
  （2）->：表示Lambda表达式箭牌，用来指定参数数据指向，不能省略，且必须用英文横线和大于号书写。  
  （3）{表达式主体}：由单个表达式或语句块组成的主体，本质就是接口中抽象方法的具体实现，如果表达式主体只有一条语句，那么可以省略包含主体的大括号；另外，在Lambda表达式主体中允许有返回值，当只有一条return语句时，也可以省略return关键字。  
  了解了Lambda表达式的语法后，接下来编写一个示例文件对Lambda表达式的基本使用进行介绍，具体代码如下所示。
```js
 1	// 定义动物类接口
 2	interface Animal { 
 3		void shout(); // 定义方法shout()
 4	}
 5	public class Example22 {
 6		public static void main(String[] args) {
 7	       String name = "小花"; 
 8	       // 1、匿名内部类作为参数传递给animalShout()方法
 9		  animalShout(new Animal() { 
 10				 public void shout() { 
 11				    System.out.println("匿名内部类输出："+name+"喵喵...");
 12				}
 13		  });
 14		  // 2、使用Lambda表达式作为参数传递给animalShout()方法
 15	       animalShout(()-> System.out.println("Lambda表达式输出："
 16	                                                   +name+"喵喵..."));
 17		}
 18	    // 创建一个animalShout()静态方法，接收接口类型的参数
 19		public static void animalShout(Animal an) {
 20			an.shout();  
 21		}
 22	}
```  
  运行结果下图所示。
![alt](/article_img/lambda/1.jpg)
  上述代码示例中，先定义了只有一个抽象方法的接口Animal，然后分别使用匿名内部类和Lambda表达式的方式实现了接口方法。从图中可以看出，使用匿名内部类和Lambda表达式都能实现接口中方法，但很显然使用Lambda表达式更加简洁和清晰。, 2018-11-27, null, 默认分类, 2018,Lambda表达式, true, null, 18, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20034, rs-50032} Result: [7, 函数式接口, &emsp;&emsp;虽然Lambda表达式可以实现匿名内部类的功能，但在使用时却有一个局限，即接口中有且只有一个抽象方法时才能使用Lamdba表达式代替匿名内部类。这是因为Lamdba表达式是基于函数式接口实现的，所谓函数式接口是指有且仅有一个抽象方法的接口，Lambda表达式就是Java中函数式编程的体现，只有确保接口中有且仅有一个抽象方法，Lambda表达式才能顺利地推导出所实现的这个接口中的方法。  
&emsp;&emsp;在JDK 8中，专门为函数式接口引入了一个@FunctionalInterface注解，该注解只是显示的标注了接口是一个函数式接口，并强制编辑器进行更严格的检查，确保该接口是函数式接口，如果不是函数式接口，那么编译器就会报错，而对程序运行并没有实质上的影响。  
&emsp;&emsp;接下来通过一个案例来演示函数式接口的定义与使用，示例代码如下所示。
```js
 1	// 定义无参、无返回值的函数式接口
 2	@FunctionalInterface
 3	interface Animal {
 4		void shout();
 5	}
 6	// 定义有参、有返回值的函数式接口
 7	interface Calculate {
 8		int sum(int a, int b);
 9	}
 10	public class Example23 {
 11		public static void main(String[] args) {
 12		   // 分别两个函数式接口进行测试
 13		   animalShout(() -> System.out.println("无参、无返回值的函数式接口调用"));
 14		   showSum(10, 20, (x, y) -> x + y);
 15		}
 16		// 创建一个动物叫的方法，并传入接口对象Animal作为参数
 17		private static void animalShout(Animal animal) {
 18			animal.shout();
 19		}
 20		// 创建一个求和的方法，并传入两个int类型以及接口Calculate类型的参数
 21		private static void showSum(int x, int y, Calculate calculate) {
 22		   System.out.println(x + "+" + y + "的和为：" + calculate.sum(x, y));
 23		}
 24	}
```  
&emsp;&emsp;运行结果如下图所示。

![alt](/article_img/lambda/2.jpg)
&emsp;&emsp;上述代码示例中，先定义了两个函数式接口Animal和Calculate，然后在测试类中分别编写了两个静态方法，并将这两个函数式接口以参数的形式传入，最后在main()方法中分别调用这两个静态方法，并将所需要的函数式接口参数以Lambda表达式的形式传入。从图中可以看出，程序中函数式接口的定义和使用完全正确。
, 2018-12-01, null, 默认分类, 接口,函数式接口, true, null, 12, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20034, rs-50032} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20034, rs-50032} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20034, rs-50032} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20034, rs-50032} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20034, rs-50032} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20034} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20035} created. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20035} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20035} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20035} executed. 0.4623 millis. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20035, rs-50033} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20035, rs-50033} Header: [count(0)]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20035, rs-50033} Result: [12]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20035, rs-50033} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20035} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20036} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20036} Parameters : [5]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20036} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20036} executed. 0.463 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20036, rs-50034} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20036, rs-50034} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20036, rs-50034} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20036, rs-50034} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20036, rs-50034} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20036, rs-50034} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20036, rs-50034} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20036, rs-50034} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20036} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20037} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20037} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20037} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20037} executed. 0.5151 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20037, rs-50035} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20037, rs-50035} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20037, rs-50035} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20037, rs-50035} Result: [12, Spring Boot 2 权威发布,   如果这两天登录 [https://start.spring.io/ ](https://start.spring.io/ )就会发现，Spring Boot 默认版本已经升到了 2.1.0。这是因为 Spring Boot 刚刚发布了 2.1.0 版本，我们来看下 Spring Boot 2 发布以来第一个子版本都发布了哪些内容？  

**2.1 中的新特性**     
  ●将spring-boot-starter-oauth2-oidc-client重命名为spring-boot-starter-oauth2-client命名更简洁  
  ●添加 OAuth2 资源服务 starter，OAuth2 一个用于认证的组件  
  ●支持 ConditionalOnBean 和 ConditionalOnMissingBean 下的参数化容器  
  ●自动配置 applicationTaskExecutor bean 的延迟加载来避免不必要的日志记录  
  ●将 DatabaseDriver＃SAP 重命名为 DatabaseDriver  
  ●跳过重启器不仅适用于 JUnit4，也适用于 JUnit5  
  ●在 Jest HealthIndicator 中使用集群端点  
  ●当 DevTools 禁用重启时添加日志输出  
  ●添加注解：@ConditionalOnMissingServletFilter提高 Servlet Filters 的自动装配。
  
**2.1 中的组件升级**  
  ●升级 Hibernate 5.3，Hibernate 的支持升级到了 5.3  
  ●升级 Tomcat 9 ，支持最新的 tomcat 9  
  ●支持 Java 11，Java 现在更新越来越快，Spring 快赶不上了    
  ●升级 Thymeleaf Extras Springsecurity 到 3.0.4.RELEASE ，thymeleaf-extras-springsecurity 是 Thymeleaf 提供集成 Spring Security 的组件  
  ●升级 Joda Time 2.10.1，Joda-Time， 面向 Java 应用程序的日期/时间库的替代选择，Joda-Time 令时间和日期值变得易于管理、操作和理解。  
  ●升级 Lettuce 5.1.2.RELEASE ，Lettuce 前面说过，传说中 Redis 最快的客户端。  
  ●升级 Reactor Californium-SR2 ，Californium 是物联网云服务的 Java COAP 实现。因此，它更专注的是可扩展性和可用性而不是像嵌入式设备那样关注资源效率。不过，Californium 也适合嵌入式的 JVM。  
  ●升级 Maven Failsafe Plugin 2.22.1 ，Maven 中的测试插件。  
  ●升级 Flyway 5.2.1 ， Flyway是一款开源的数据库版本管理工具  
  ●升级 Aspectj 1.9.2 ，AspectJ 是 Java 中流行的 AOP（Aspect-oriented Programming）编程扩展框架，是 Eclipse 托管给 Apache 基金会的一个开源项目。  
  ●升级 Mysql 8.0.13 ，Mysql 支持到 8。  
  ●...  
  更多的详细内容可以参考这里：[Spring Boot 2.1 Release Notes](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.1-Release-Notes)
, 2018-12-12, 2021-05-21, 默认分类, Spring Boot 2, true, null, 62, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20037, rs-50035} Result: [8, JDK 8——聚合操作, &emsp;&emsp;在Java8版本中，JDK包含许多聚合操作（如平均值，总和，最小，最大，和计数），返回一个计算流stream的聚合结果。这些聚合操作被称为聚合操作。JDK除返回单个值的聚合操作外，还有很多聚合操作返回一个collection集合实例。很多的reduce操作执行特定的任务，如求平均值或按类别分组元素。  

**1. 聚合操作简介**

  在开发中，多数情况下会涉及到对集合、数组中元素的操作，在JDK 8之前都是通过普通的循环遍历出每一个元素，然后还会穿插一些if条件语句选择性的对元素进行查找、过滤、修改等操作，这种原始的操作方法虽然可行，但是代码量较大并且执行效率较低。  
  为此，JDK 8中新增了一个Stream接口，该接口可以将集合、数组的中的元素转换为Stream流的形式，并结合Lambda表达式的优势来进一步简化集合、数组中元素的查找、过滤、转换等操作，这一新功能就是JDK 8中的聚合操作。  
  在程序中，使用聚合操作没有绝对的语法规范，根据实际操作流程，主要可以分为以下3个步骤：  
  （1）将原始集合或者数组对象转换为Stream流对象；  
  （2）对Stream流对象中的元素进行一系列的过滤、查找等中间操作（Intermediate Operations），然后仍然返回一个Stream流对象；  
  （3）对Stream流进行遍历、统计、收集等终结操作（Terminal Operation），获取想要的结果。  
  接下来，就根据上面聚合操作的3个步骤，通过一个案例来演示聚合操作的基本用法，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example31 {
 4		public static void main(String[] args) {
 5	          // 创建一个List集合对象
 6			List<String> list = new ArrayList<>(); 
 7			list.add("张三");
 8			list.add("李四");
 9			list.add("张小明");
 10			list.add("张阳");
 11			// 1、创建一个Stream流对象
 12			Stream<String> stream = list.stream();
 13			// 2、对Stream流中的元素分别进行过滤、截取操作
 14		       Stream<String> stream2 = stream.filter(i -> i.startsWith("张"));
 15			Stream<String> stream3 = stream2.limit(2);
 16			// 3、对Stream流中的元素进行终结操作，进行遍历输出
 17			stream3.forEach(j -> System.out.println(j));
 18			System.out.println("=======");
 19	         // 通过链式表达式的形式完成聚合操作
 20			list.stream().filter(i -> i.startsWith("张"))
 21						 .limit(2)
 22						 .forEach(j -> System.out.println(j));
 23		}
 24	}
``` 
   运行结果如下图所示。
![alt](/article_img/lambda/3.jpg)
  上述示例代码中，先创建了一个List集合，然后根据聚合操作的3个步骤实现了集合对象的聚合操作，对集合中的元素使用Stream流的形式进行过滤（filter）、截取（limit），并进行遍历输出。其中第12~17行代码分步骤详细展示了聚合操作，而第20~22行代码是使用了链式表达式（调用有返回值的方法时不获取返回值而是直接再调用另一个方法）实现了聚合操作，该表达式的语法格式更简洁、高效，这种链式调用也被称为操作管道流。

**2. 创建Stream流对象**  
  在上一小节中，介绍了聚合操作的主要使用步骤，其中首要解决的问题就是创建Stream流对象。聚合操作针对的就是可迭代数据进行的操作，如集合、数组等，所以创建Stream流对象其实就是将集合、数组等通过一些方法转换为Stream流对象。  
  在Java中，集合对象有对应的集合类，可以通过集合类提供的静态方法创建Stream流对象，而数组数据却没有对应的数组类，所以必须通过其他方法创建Stream流对象。针对不同的源数据，Java提供了多种创建Stream流对象的方式，分别如下：  
  （1）所有的Collections集合都可以使用stream()静态方法获取Stream流对象；  
  （2）Stream接口的of()静态方法可以获取基本类型包装类数组、引用类型数组和单个元素的Stream流对象；  
  （3）Arrays数组工具类的stream()静态方法也可以获取数组元素的Stream流对象。  
  接下来，通过一个案例来学习聚合操作中如何创建Stream流对象，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example32 {
 4		public static void main(String[] args) {
 5	          // 创建一个数组
 6			Integer[] array = { 9, 8, 3, 5, 2 };       
 7	          // 将数组转换为List集合
 8			List<Integer> list = Arrays.asList(array); 
 9			// 1、使用集合对象的stream()静态方法创建Stream流对象
 10			Stream<Integer> stream = list.stream();
 11			stream.forEach(i -> System.out.print(i+" "));
 12			System.out.println();
 13			// 2、使用Stream接口的of()静态方法创建Stream流对象
 14			Stream<Integer> stream2 = Stream.of(array);
 15			stream2.forEach(i -> System.out.print(i+" "));
 16			System.out.println();
 17			// 3、使用Arrays数组工具类的stream()静态方法创建Stream流对象
 18			Stream<Integer> stream3 = Arrays.stream(array);
 19			stream3.forEach(i -> System.out.print(i+" "));
 20		}
 21	}
```  
  运行结果如下图所示。
![alt](/article_img/lambda/4.jpg)
  上述示例代码中，先创建了一个数组和一个集合，然后通过三种方式实现了Stream流对象的创建，并通过Stream流对象的forEach()方法结合Lambda表达式完成了集合和数组中元素的遍历。  

**小提示：**  
  在JDK 8中，只针对单列集合Collections接口对象提供了stream()静态方法获取Stream流对象，并未对Map集合提供相关方法获取Stream流对象，所以想要用Map集合创建Stream流对象必须先通过Map集合的keySet()、values()、entrySet()等方法将Map集合转换为单列Set集合，然后再使用单列集合的stream()静态方法获取对应键、值集合的Stream流对象。

, 2018-12-02, null, 默认分类, JDK 8,聚合操作, true, null, 36, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20037, rs-50035} Result: [9, 虚拟化容器技术——Docker运行机制介绍,   Docker是一个开源的应用容器引擎，它基于go语言开发，并遵从Apache2.0开源协议。使用Docker可以让开发者封装他们的应用以及依赖包到一个可移植的容器中，然后发布到任意的Linux机器上，也可以实现虚拟化。Docker容器完全使用沙箱机制，相互之间不会有任何接口，这保证了容器之间的安全性。  

**1. Docker的引擎介绍**

  Docker Engine（Docker引擎）是Docker的核心部分，使用的是客户端-服务器（C/S）架构模式，其主要组成部分如下图所示。
![alt](/article_img/docker/1.png)
  从上图可以看出，Docker Engine中包含了三个核心组件（docker CLI、REST API和docker daemon），这三个组件的具体说明如下：  
  ①docker CLI（command line interface）：表示Docker命令行接口，开发者可以在命令行中使用Docker相关指令与Docker守护进程进行交互，从而管理诸如image（镜像）、container（容器）、network（网络）和data volumes（数据卷）等实体。  
  ②REST API：表示应用程序API接口，开发者通过该API接口可以与Docker的守护进程进行交互，从而指示后台进行相关操作。  
  ③docker daemon：表示Docker的服务端组件，他是Docker架构中运行在后台的一个守护进程，可以接收并处理来自命令行接口及API接口的指令，然后进行相应的后台操作。  
  对于开发者而言，既可以使用编写好的脚本文件通过REST API来实现与Docker进程交互，又可以直接使用Docker相关指令通过命令行接口来与Docker进程交互，而其他一些Docker应用则是通过底层的API和CLI进行交互的。

**2. Docker的架构介绍**

  了解了Docker内部引擎及作用后，我们还需要通过Docker的具体架构，来了解Docker的整个运行流程。接下来借助Docker官网的架构图来对Docker架构进行详细说明，如下图所示。
![alt](/article_img/docker/2.jpg)
  从图中可以看出，Docker架构主要包括Client、DOCKER_HOST和Register三部分，关于这三部分的具体说明如下。  
&emsp;&emsp;**（1）Client（客户端）**  
  Client即Docker客户端，也就是上一小节Docker Engine中介绍的docker CLI。开发者通过这个客户端使用Docker的相关指令与Docker守护进程进行交互，从而进行Docker镜像的创建、拉取和运行等操作。  
&emsp;&emsp;**（2）DOCKER_HOST（Docker主机）**  
  DOCKER_HOST即Docker内部引擎运行的主机，主要指Docker daemon（Docker守护进程）。可以通过Docker守护进程与客户端还有Docker的镜像仓库Registry进行交互，从而管理Images（镜像）和Containers（容器）等。  
&emsp;&emsp;**（3）Registry（注册中心）**  
  Registry即Docker注册中心，实质就是Docker镜像仓库，默认使用的是Docker官方远程注册中心Docker Hub，也可以使用开发者搭建的本地仓库。Registry中包含了大量的镜像，这些镜像可以是官网基础镜像，也可以是其他开发者上传的镜像。  
  我们在实际使用Docker时，除了会涉及到图中的三个主要部分外，还会涉及到很多Docker Objects（Docker对象），例如Images（镜像）、Containers（容器）、Networks（网络）、Volumes（数据卷）、Plugins（插件）等。其中常用的两个对象Image和Containers的说明如下。  
  ①Images（镜像）  
  Docker 镜像就是一个只读的模板，包含了一些创建Docker容器的操作指令。通常情况下，一个Docker镜像是基于另一个基础镜像创建的，并且新创建的镜像会额外包含一些功能配置。例如：开发者可以依赖于一个Ubuntu的基础镜像创建一个新镜像，并可以在新镜像中安装Apache等软件或其它应用程序。  
  ②Containers（容器）  
  Docker容器属于镜像的一个可运行实例（镜像与容器的关系其实与Java中的类与对象相似），开发者可以通过API接口或者CLI命令行接口来创建、运行、停止、移动、删除一个容器，也可以将一个容器连接到一个或多个网络中，将数据存储与容器进行关联。



, 2018-12-03, null, 默认分类, 虚拟化容器,Docker,运行机制, true, null, 26, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20037, rs-50035} Result: [10, Docker常用客户端指令介绍,   在使用Docker之前，首先会为对应的项目编写Dockerfile镜像构建文件，然后通过Docker的相关指令进行镜像构建，完成镜像的构建后，就可以使用这些项目镜像进行启动测试了。所以要想知道如何使用Docker来执行这些Dockerfile镜像构建文件，还需要学习Docker客户端的常用指令，本篇文章将对Docker客户端的常用指令进行详细讲解。  

**1.列出镜像**  
  通过docker images指令可以查看本地镜像列表中已有的镜像，具体使用方式如下。
```js
$ docker images
```  
  执行上述指令后，系统会将所有本地镜像都展示出来，如下图所示。
![alt](/article_img/docker/3.png)
  从图中可以看出，系统终端将本地镜像列表中的3个镜像分5列进行了展示，每一列的具体含义如下。  
  ●REPOSITORY：镜像名称。  
  ●TAG：镜像的参数，类似于版本号，默认是latest。  
  ●IMAGE ID：镜像ID，是唯一值。此处看到的是一个长度为12的字符串，实际上它是64位完整镜像ID的缩写形式。  
  ●CREATED：距今创建镜像的时间。  
  ●SIZE：镜像大小。    

**2.搜索镜像**  
  想知道在Docker Hub中包含了哪些镜像，除了可以登录Docker Hub，在官网中心进行查看外，还可以直接在Docker客户端进行查询。例如想要查询Ubuntu镜像，可以使用如下指令。
```js
$ docker search ubuntu
```  
  执行上述指令后，系统终端就会将搜索到的有关Ubuntu的镜像展示出来，如下图所示。
![alt](/article_img/docker/4.png)
  从图所示的结果可以看出，系统终端分5列将搜索到的Ubuntu相关镜像都列举出来了，这5列的具体含义如下。  
  ●NAME：表示镜像的名称，这里有两种格式的名称，其中不带有“/”的表示官方镜像，而带有“/”的表示其他用户的公开镜像。公开镜像“/”前面是用户在Docker Hub上的用户名（唯一），后面是对应的镜像名；官方镜像与用户镜像，除了从镜像名称上可以区分外，还可以通过第4列的OFFICIAL声明中看出（该列下内容为OK表示官方镜像）。  
  ●DESCRIPTION：表示镜像的描述，这里只显示了一小部分。  
  ●STARS：表示该镜像的收藏数，用户可以在Docker Hub上对镜像进行收藏，一般可以通过该数字反应出该镜像的受欢迎程度。  
  ●OFFICIAL：表示是否为官方镜像。  
  ●AUTOMATED：表示是否自动构建镜像。例如，用户可以将自己的Docker Hub绑定到如Github上，当代码提交更新后，可以自动构建镜像。   
 
**3.拉取镜像**  
  通过docker pull指令可以拉取仓库镜像到本地（默认都是拉取Docker Hub仓库镜像，也可以指定“IP+端口”拉取某个Docker机器上的私有仓库镜像），具体使用方式如下。
```js
$ docker pull ubuntu
```  
  执行上述指令后，Docker会自动从Docker Hub上下载最新版本的Ubuntu到本地，当然也可以使用以下指令拉取指定版本的镜像到本地，具体指令如下。
```js
$ docker pull ubuntu:14.04
```  
**4.构建镜像**  
  除了可以通过docker pull指令从仓库拉取镜像外，还可以通过docker build指令构建Docker镜像，通常情况下都是通过Dockerfile文件来构建镜像的。  
  这里假设linux系统home目录下/shitou/workspace/dockerspace文件夹中编写有对应的Dockerfile文件，则构建镜像直立示例如下所示。 
```js
$ docker build -t hellodocker3 /home/shitou/workspace/dockerspace/.
```
**5.删除镜像**  
  当本地存放过多不需要的镜像时，可以通过docker rmi指令将其删除。在删除镜像时，需要指定镜像名称或镜像ID。删除镜像的使用方式如下。
```js
$ docker rmi -f hellodocker2 hellodocker3
```  
  上述指令中，docker rmi表示删除镜像，-f表示进行强制删除，而hellodocker2和hellodocker3分别表示需要删除的镜像名称，这里同时删除两个镜像。除了根据名称删除镜像外，还也可以根据镜像ID来删除镜像，只是这里如果指定了删除ID为23c617a866d4的镜像后，会同时删除hellodocker、hellodocker2和hellodocker3三个镜像。  
  需要特别强调的是，在进行镜像删除操作时，如果是通过镜像ID进行镜像删除，那么由该镜像创建的容器必须提前删除或停止。另外，在通过镜像名称操作镜像时，如果出现镜像重名的情况，必须在镜像名称后面指定镜像标签tag参数来确保唯一性。

**6.创建并启动容器**  
  Docker镜像主要用于创建容器，可以使用docker run指令创建并启动容器，具体使用方式如下。
```js
$ docker run -d -p 5000:80 --name test hellodocker
```  
  上述创建并启动容器的指令略微复杂，具体分析如下。  
  ●docker run：表示创建并启动一个容器，而后面的hellodocker就表示要启动运行的镜像名称；  
  ●-d：表示容器启动时在后台运行；  
  ●-p 5000:80：表示将容器内暴露的80端口映射到宿主机指定的5000端口，也可以将-p 5000:80更改为-P来映射主机的随机端口（注意p字母的大小写）；  
  ●--name test：表示为创建后的容器指定名称为test，如果没有该参数配置，则生成的容器会设置一个随机名称。  
  docker run命令是Docker操作中较为复杂的一个，它可以携带多个参数和参数，我们可以通过docker run --help指令进行查看，其中有些参数如-e、-v和-w等都可以在Dockerfile文件中预先声明。 
 
**7.列出容器**  
  生成容器后，可以通过docker ps指令查看当前运行的所有容器，具体使用方式如下。
```js
$ docker ps
```  
  执行上述命令后，会将所有当前运行的容器都展示出来，具体如下图所示。
![alt](/article_img/docker/5.png)
  从图中可以看出，系统终端通过7列对当前的正在运行的一个容器进行了展示，图中每一列的具体含义如下。  
  ●CONTAINER ID：表示生成的容器ID；  
  ●IMAGE：表示生成该容器的镜像名称；  
  ●COMMAND：表示启动容器时运行的命令，Docker要求在启动容器时必须运行一个命令；  
  ●CREATED：表示容器创建的时间；  
  ●STATUS：表示容器运行状态，例如Up表示运行中，Exited表示已停止；  
  ●PORTS：表示容器内部暴露的端口映射到主机的端口；  
  ●NAMES：表示生成容器的名称，由Docker引擎自动生成，可以像上述示例中使用--name参数指定生成容器的名称。  
  另外，docker ps指令运行过程中可以指定多个参数，还可以通过docker ps --help指令对ps指令的其他信息进行查看。

**8.删除容器**  
  当不需要使用容器时，则可以使用docker rm指令删除已停止的容器，具体使用方式如下。
```js
$ docker rm f0c9a8b6e8c5
```  
  需要注意的是，上述指令只能删除已经停止运行的容器，而不能删除正在运行的容器。如果想要删除正在运行的容器，则需要添加-f参数强制删除，具体使用方式如下。
```js
$ docker rm -f f0c9a8b6e8c5
```  
  当需要删除的容器过多时，如果还一个个的删除就略显麻烦了，此时可以通过如下指令将全部容器删除。
```js
$ docker rm -f $(docker ps -aq)
```  
  上述指令中，首先会通过$(docker ps -aq)获取所有容器的ID，然后通过docker rm -f指令进行强制删除。如果开发者有自己特殊的删除需求，可以根据前面docker ps指令进行组装来获取需要删除的容器ID。  
  Docker提供的操作指令远不止这些，这里就不一一列举了，想要了解更多Docker的操作指令，可以通过docker --help指令进行查看。


, 2018-12-05, null, 默认分类, Docker,客户端指令, true, null, 21, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20037, rs-50035} Result: [11, Docker数据管理介绍,   当我们对容器进行相关操作时，产生的一系列数据都会存储在容器中，而Docker内部又是如果管理这些数据的呢？本篇文章将针对Docker数据管理的一些知识进行介绍。
  
**1. Docker数据存储机制**  
  使用Docker时，我们操作的都是镜像和由镜像生成的容器，所以想要更好的了解Docker内部的数据存储机制，就必须从镜像、容器与数据存储的关系出发。  
  Docker镜像是通过读取Dockerfile文件中的指令构建的，Dockerfile中的每条指令都会创建一个镜像层，并且每层都是只读的，这一系列的镜像层就构成了Docker镜像。接下来以一个Dockerfile文件为例进行说明，具体如下列代码示例所示。
```js
 1	FROM ubuntu:16.04
 2	COPY . /app
 3	RUN make /app
 4	CMD python /app/app.py
```  
   上述文件示例中的Dockerfile包含了4条指令，每条指令都会创建一个镜像层，其中每一层与前一层都有所不同，并且是层层叠加的。通过镜像构建容器时，会在镜像层上增加一个容器层（即可写层），所有对容器的更改都会写入容器层，这也是Docker默认的数据存储方式。  
  下面通过一个效果图进行说明，具体如下图所示。
![alt](/article_img/docker/6.png)
  从图中可以看出，Docker容器和镜像之间的主要区别是顶部的容器层，而所有对容器中数据的添加、修改等操作都会被存储在容器层中。当容器被删除时，容器层也会被删除，其中存储的数据会被一同删除，而下面的镜像层却保持不变。  
  由于所有的容器都是通过镜像构建的，所以每个容器都有各自的容器层，对于容器数据的更改就会保存在各自的容器层中。也就是说，由同一个镜像构建的多个容器，它们会拥有相同的底部镜像层，而拥有不同的容器层，多个容器可以访问相同的镜像层，并且有自己的独立数据状态。具体说明如下图所示。 
![alt](/article_img/docker/7.png)
  从图中可以看出，基于同一个镜像构建的多个容器可以共享该镜像层，但是多个容器想要共享相同的数据，就需要将这些数据存储到容器之外的地方，而这种方式就是下一节要提到的Docker volume数据外部挂载机制。  

**2. Docker数据存储方式**    
  在默认情况下，Docker中的数据都是存放在容器层的，但是这样存储数据却有较多的缺陷，具体表现如下。    
  ●当容器不再运行时，容器中的数据无法持久化保存，如果另一个进程需要这些数据，那么将很难从容器中获取数据；  
  ●容器层与正在运行的主机紧密耦合，不能轻易地移动数据；  
  ●容器层需要一个存储驱动程序来管理文件系统，存储驱动程序提供了一个使用Linux内核的联合文件系统，这种额外的抽象化降低了性能。  
  基于上述种种原因，多数情况下Docker数据管理都不会直接将数据写入容器层，而是使用另一种叫做Docker volume数据外部挂载的机制进行数据管理。  
  针对Docker volume数据外部挂载机制，Docker提供了三种不同的方式将数据从容器映射到Docker宿主机，他们分别为：volumes（数据卷）、bind mounts（绑定挂载）和tmpfs mounts（tmpfs挂载）。这三种数据管理方式的具体选择，需要结合实际情况进行考虑，其中的volumes数据卷是最常用也是官方推荐的数据管理方式。无论选择使用哪种数据管理方式，数据在容器内看起来都一样的，而在容器外则会被被挂载到文件系统中的某个目录或文件中。    
  下面通过一张图来展示数据卷、绑定挂载和tmpfs挂载之间的差异，如下图所示。  
![alt](/article_img/docker/8.png)
  从图中可以看出，Docker提供的三种数据管理方式略有不同，具体分析如下。  
  ●volumes：存储在主机文件系统中（在Linux系统下是存在于/var/lib/Docker/volumes/目录），并由Docker管理，非Docker进程无法修改文件系统的这个部分。  
  ●bind mounts：可以存储在主机系统的任意位置，甚至可能是重要的系统文件或目录，在Docker主机或容器上的非Docker进程可以对他们进行任意修改。  
  ●tmpfs mounts：只存储在主机系统的内存中，并没有写入到主机的文件系统中。


, 2018-12-07, 2021-05-19, 默认分类, Docker,数据管理, true, null, 19, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20037, rs-50035} Result: [6, JDK 8——Lambda表达式介绍,   Lambda表达式是JDK 8中一个重要的新特性，它使用一个清晰简洁的表达式来表达一个接口，同时Lambda表达式也简化了对集合以及数组数据的遍历、过滤和提取等操作。下面，本篇文章就对Lambda表达式进行简要介绍，并进行演示说明。

**1. Lambda表达式入门**  

  匿名内部类存在的一个问题是，如果匿名内部类的实现非常简单，例如只包含一个抽象方法的接口，那么匿名内部类的语法仍然显得比较冗余。为此，JDK 8中新增了一个特性Lambda表达式，这种表达式只针对有一个抽象方法的接口实现，以简洁的表达式形式实现接口功能来作为方法参数。  
  一个Lambda表达式由三个部分组成，分别为参数列表、“->”和表达式主体，其语法格式如下：
```js
 ([数据类型 参数名,数据类型 参数名,...]) -> {表达式主体}
```  
  从上述语法格式上看，Lambda表达式的书写非常简单，下面针对Lambda表达式的组成部分进行简单介绍，具体如下：  
  （1）([数据类型 参数名,数据类型 参数名,...])：用来向表达式主体传递接口方法需要的参数，多个参数名中间必须用英文逗号“,”进行分隔；在编写Lambda表达式时，可以省略参数的数据类型，后面的表达式主体会自动进行校对和匹配；同时，如果只有一个参数，则可以省略括号“()”。  
  （2）->：表示Lambda表达式箭牌，用来指定参数数据指向，不能省略，且必须用英文横线和大于号书写。  
  （3）{表达式主体}：由单个表达式或语句块组成的主体，本质就是接口中抽象方法的具体实现，如果表达式主体只有一条语句，那么可以省略包含主体的大括号；另外，在Lambda表达式主体中允许有返回值，当只有一条return语句时，也可以省略return关键字。  
  了解了Lambda表达式的语法后，接下来编写一个示例文件对Lambda表达式的基本使用进行介绍，具体代码如下所示。
```js
 1	// 定义动物类接口
 2	interface Animal { 
 3		void shout(); // 定义方法shout()
 4	}
 5	public class Example22 {
 6		public static void main(String[] args) {
 7	       String name = "小花"; 
 8	       // 1、匿名内部类作为参数传递给animalShout()方法
 9		  animalShout(new Animal() { 
 10				 public void shout() { 
 11				    System.out.println("匿名内部类输出："+name+"喵喵...");
 12				}
 13		  });
 14		  // 2、使用Lambda表达式作为参数传递给animalShout()方法
 15	       animalShout(()-> System.out.println("Lambda表达式输出："
 16	                                                   +name+"喵喵..."));
 17		}
 18	    // 创建一个animalShout()静态方法，接收接口类型的参数
 19		public static void animalShout(Animal an) {
 20			an.shout();  
 21		}
 22	}
```  
  运行结果下图所示。
![alt](/article_img/lambda/1.jpg)
  上述代码示例中，先定义了只有一个抽象方法的接口Animal，然后分别使用匿名内部类和Lambda表达式的方式实现了接口方法。从图中可以看出，使用匿名内部类和Lambda表达式都能实现接口中方法，但很显然使用Lambda表达式更加简洁和清晰。, 2018-11-27, null, 默认分类, 2018,Lambda表达式, true, null, 18, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20037, rs-50035} Result: [7, 函数式接口, &emsp;&emsp;虽然Lambda表达式可以实现匿名内部类的功能，但在使用时却有一个局限，即接口中有且只有一个抽象方法时才能使用Lamdba表达式代替匿名内部类。这是因为Lamdba表达式是基于函数式接口实现的，所谓函数式接口是指有且仅有一个抽象方法的接口，Lambda表达式就是Java中函数式编程的体现，只有确保接口中有且仅有一个抽象方法，Lambda表达式才能顺利地推导出所实现的这个接口中的方法。  
&emsp;&emsp;在JDK 8中，专门为函数式接口引入了一个@FunctionalInterface注解，该注解只是显示的标注了接口是一个函数式接口，并强制编辑器进行更严格的检查，确保该接口是函数式接口，如果不是函数式接口，那么编译器就会报错，而对程序运行并没有实质上的影响。  
&emsp;&emsp;接下来通过一个案例来演示函数式接口的定义与使用，示例代码如下所示。
```js
 1	// 定义无参、无返回值的函数式接口
 2	@FunctionalInterface
 3	interface Animal {
 4		void shout();
 5	}
 6	// 定义有参、有返回值的函数式接口
 7	interface Calculate {
 8		int sum(int a, int b);
 9	}
 10	public class Example23 {
 11		public static void main(String[] args) {
 12		   // 分别两个函数式接口进行测试
 13		   animalShout(() -> System.out.println("无参、无返回值的函数式接口调用"));
 14		   showSum(10, 20, (x, y) -> x + y);
 15		}
 16		// 创建一个动物叫的方法，并传入接口对象Animal作为参数
 17		private static void animalShout(Animal animal) {
 18			animal.shout();
 19		}
 20		// 创建一个求和的方法，并传入两个int类型以及接口Calculate类型的参数
 21		private static void showSum(int x, int y, Calculate calculate) {
 22		   System.out.println(x + "+" + y + "的和为：" + calculate.sum(x, y));
 23		}
 24	}
```  
&emsp;&emsp;运行结果如下图所示。

![alt](/article_img/lambda/2.jpg)
&emsp;&emsp;上述代码示例中，先定义了两个函数式接口Animal和Calculate，然后在测试类中分别编写了两个静态方法，并将这两个函数式接口以参数的形式传入，最后在main()方法中分别调用这两个静态方法，并将所需要的函数式接口参数以Lambda表达式的形式传入。从图中可以看出，程序中函数式接口的定义和使用完全正确。
, 2018-12-01, null, 默认分类, 接口,函数式接口, true, null, 12, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20037, rs-50035} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20037, rs-50035} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20037, rs-50035} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20037, rs-50035} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20037, rs-50035} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20037} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20038} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20038} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20038} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20038} executed. 0.894 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20038, rs-50036} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20038, rs-50036} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20038, rs-50036} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20038, rs-50036} Result: [12, Spring Boot 2 权威发布,   如果这两天登录 [https://start.spring.io/ ](https://start.spring.io/ )就会发现，Spring Boot 默认版本已经升到了 2.1.0。这是因为 Spring Boot 刚刚发布了 2.1.0 版本，我们来看下 Spring Boot 2 发布以来第一个子版本都发布了哪些内容？  

**2.1 中的新特性**     
  ●将spring-boot-starter-oauth2-oidc-client重命名为spring-boot-starter-oauth2-client命名更简洁  
  ●添加 OAuth2 资源服务 starter，OAuth2 一个用于认证的组件  
  ●支持 ConditionalOnBean 和 ConditionalOnMissingBean 下的参数化容器  
  ●自动配置 applicationTaskExecutor bean 的延迟加载来避免不必要的日志记录  
  ●将 DatabaseDriver＃SAP 重命名为 DatabaseDriver  
  ●跳过重启器不仅适用于 JUnit4，也适用于 JUnit5  
  ●在 Jest HealthIndicator 中使用集群端点  
  ●当 DevTools 禁用重启时添加日志输出  
  ●添加注解：@ConditionalOnMissingServletFilter提高 Servlet Filters 的自动装配。
  
**2.1 中的组件升级**  
  ●升级 Hibernate 5.3，Hibernate 的支持升级到了 5.3  
  ●升级 Tomcat 9 ，支持最新的 tomcat 9  
  ●支持 Java 11，Java 现在更新越来越快，Spring 快赶不上了    
  ●升级 Thymeleaf Extras Springsecurity 到 3.0.4.RELEASE ，thymeleaf-extras-springsecurity 是 Thymeleaf 提供集成 Spring Security 的组件  
  ●升级 Joda Time 2.10.1，Joda-Time， 面向 Java 应用程序的日期/时间库的替代选择，Joda-Time 令时间和日期值变得易于管理、操作和理解。  
  ●升级 Lettuce 5.1.2.RELEASE ，Lettuce 前面说过，传说中 Redis 最快的客户端。  
  ●升级 Reactor Californium-SR2 ，Californium 是物联网云服务的 Java COAP 实现。因此，它更专注的是可扩展性和可用性而不是像嵌入式设备那样关注资源效率。不过，Californium 也适合嵌入式的 JVM。  
  ●升级 Maven Failsafe Plugin 2.22.1 ，Maven 中的测试插件。  
  ●升级 Flyway 5.2.1 ， Flyway是一款开源的数据库版本管理工具  
  ●升级 Aspectj 1.9.2 ，AspectJ 是 Java 中流行的 AOP（Aspect-oriented Programming）编程扩展框架，是 Eclipse 托管给 Apache 基金会的一个开源项目。  
  ●升级 Mysql 8.0.13 ，Mysql 支持到 8。  
  ●...  
  更多的详细内容可以参考这里：[Spring Boot 2.1 Release Notes](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.1-Release-Notes)
, 2018-12-12, 2021-05-21, 默认分类, Spring Boot 2, true, null, 62, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20038, rs-50036} Result: [8, JDK 8——聚合操作, &emsp;&emsp;在Java8版本中，JDK包含许多聚合操作（如平均值，总和，最小，最大，和计数），返回一个计算流stream的聚合结果。这些聚合操作被称为聚合操作。JDK除返回单个值的聚合操作外，还有很多聚合操作返回一个collection集合实例。很多的reduce操作执行特定的任务，如求平均值或按类别分组元素。  

**1. 聚合操作简介**

  在开发中，多数情况下会涉及到对集合、数组中元素的操作，在JDK 8之前都是通过普通的循环遍历出每一个元素，然后还会穿插一些if条件语句选择性的对元素进行查找、过滤、修改等操作，这种原始的操作方法虽然可行，但是代码量较大并且执行效率较低。  
  为此，JDK 8中新增了一个Stream接口，该接口可以将集合、数组的中的元素转换为Stream流的形式，并结合Lambda表达式的优势来进一步简化集合、数组中元素的查找、过滤、转换等操作，这一新功能就是JDK 8中的聚合操作。  
  在程序中，使用聚合操作没有绝对的语法规范，根据实际操作流程，主要可以分为以下3个步骤：  
  （1）将原始集合或者数组对象转换为Stream流对象；  
  （2）对Stream流对象中的元素进行一系列的过滤、查找等中间操作（Intermediate Operations），然后仍然返回一个Stream流对象；  
  （3）对Stream流进行遍历、统计、收集等终结操作（Terminal Operation），获取想要的结果。  
  接下来，就根据上面聚合操作的3个步骤，通过一个案例来演示聚合操作的基本用法，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example31 {
 4		public static void main(String[] args) {
 5	          // 创建一个List集合对象
 6			List<String> list = new ArrayList<>(); 
 7			list.add("张三");
 8			list.add("李四");
 9			list.add("张小明");
 10			list.add("张阳");
 11			// 1、创建一个Stream流对象
 12			Stream<String> stream = list.stream();
 13			// 2、对Stream流中的元素分别进行过滤、截取操作
 14		       Stream<String> stream2 = stream.filter(i -> i.startsWith("张"));
 15			Stream<String> stream3 = stream2.limit(2);
 16			// 3、对Stream流中的元素进行终结操作，进行遍历输出
 17			stream3.forEach(j -> System.out.println(j));
 18			System.out.println("=======");
 19	         // 通过链式表达式的形式完成聚合操作
 20			list.stream().filter(i -> i.startsWith("张"))
 21						 .limit(2)
 22						 .forEach(j -> System.out.println(j));
 23		}
 24	}
``` 
   运行结果如下图所示。
![alt](/article_img/lambda/3.jpg)
  上述示例代码中，先创建了一个List集合，然后根据聚合操作的3个步骤实现了集合对象的聚合操作，对集合中的元素使用Stream流的形式进行过滤（filter）、截取（limit），并进行遍历输出。其中第12~17行代码分步骤详细展示了聚合操作，而第20~22行代码是使用了链式表达式（调用有返回值的方法时不获取返回值而是直接再调用另一个方法）实现了聚合操作，该表达式的语法格式更简洁、高效，这种链式调用也被称为操作管道流。

**2. 创建Stream流对象**  
  在上一小节中，介绍了聚合操作的主要使用步骤，其中首要解决的问题就是创建Stream流对象。聚合操作针对的就是可迭代数据进行的操作，如集合、数组等，所以创建Stream流对象其实就是将集合、数组等通过一些方法转换为Stream流对象。  
  在Java中，集合对象有对应的集合类，可以通过集合类提供的静态方法创建Stream流对象，而数组数据却没有对应的数组类，所以必须通过其他方法创建Stream流对象。针对不同的源数据，Java提供了多种创建Stream流对象的方式，分别如下：  
  （1）所有的Collections集合都可以使用stream()静态方法获取Stream流对象；  
  （2）Stream接口的of()静态方法可以获取基本类型包装类数组、引用类型数组和单个元素的Stream流对象；  
  （3）Arrays数组工具类的stream()静态方法也可以获取数组元素的Stream流对象。  
  接下来，通过一个案例来学习聚合操作中如何创建Stream流对象，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example32 {
 4		public static void main(String[] args) {
 5	          // 创建一个数组
 6			Integer[] array = { 9, 8, 3, 5, 2 };       
 7	          // 将数组转换为List集合
 8			List<Integer> list = Arrays.asList(array); 
 9			// 1、使用集合对象的stream()静态方法创建Stream流对象
 10			Stream<Integer> stream = list.stream();
 11			stream.forEach(i -> System.out.print(i+" "));
 12			System.out.println();
 13			// 2、使用Stream接口的of()静态方法创建Stream流对象
 14			Stream<Integer> stream2 = Stream.of(array);
 15			stream2.forEach(i -> System.out.print(i+" "));
 16			System.out.println();
 17			// 3、使用Arrays数组工具类的stream()静态方法创建Stream流对象
 18			Stream<Integer> stream3 = Arrays.stream(array);
 19			stream3.forEach(i -> System.out.print(i+" "));
 20		}
 21	}
```  
  运行结果如下图所示。
![alt](/article_img/lambda/4.jpg)
  上述示例代码中，先创建了一个数组和一个集合，然后通过三种方式实现了Stream流对象的创建，并通过Stream流对象的forEach()方法结合Lambda表达式完成了集合和数组中元素的遍历。  

**小提示：**  
  在JDK 8中，只针对单列集合Collections接口对象提供了stream()静态方法获取Stream流对象，并未对Map集合提供相关方法获取Stream流对象，所以想要用Map集合创建Stream流对象必须先通过Map集合的keySet()、values()、entrySet()等方法将Map集合转换为单列Set集合，然后再使用单列集合的stream()静态方法获取对应键、值集合的Stream流对象。

, 2018-12-02, null, 默认分类, JDK 8,聚合操作, true, null, 36, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20038, rs-50036} Result: [9, 虚拟化容器技术——Docker运行机制介绍,   Docker是一个开源的应用容器引擎，它基于go语言开发，并遵从Apache2.0开源协议。使用Docker可以让开发者封装他们的应用以及依赖包到一个可移植的容器中，然后发布到任意的Linux机器上，也可以实现虚拟化。Docker容器完全使用沙箱机制，相互之间不会有任何接口，这保证了容器之间的安全性。  

**1. Docker的引擎介绍**

  Docker Engine（Docker引擎）是Docker的核心部分，使用的是客户端-服务器（C/S）架构模式，其主要组成部分如下图所示。
![alt](/article_img/docker/1.png)
  从上图可以看出，Docker Engine中包含了三个核心组件（docker CLI、REST API和docker daemon），这三个组件的具体说明如下：  
  ①docker CLI（command line interface）：表示Docker命令行接口，开发者可以在命令行中使用Docker相关指令与Docker守护进程进行交互，从而管理诸如image（镜像）、container（容器）、network（网络）和data volumes（数据卷）等实体。  
  ②REST API：表示应用程序API接口，开发者通过该API接口可以与Docker的守护进程进行交互，从而指示后台进行相关操作。  
  ③docker daemon：表示Docker的服务端组件，他是Docker架构中运行在后台的一个守护进程，可以接收并处理来自命令行接口及API接口的指令，然后进行相应的后台操作。  
  对于开发者而言，既可以使用编写好的脚本文件通过REST API来实现与Docker进程交互，又可以直接使用Docker相关指令通过命令行接口来与Docker进程交互，而其他一些Docker应用则是通过底层的API和CLI进行交互的。

**2. Docker的架构介绍**

  了解了Docker内部引擎及作用后，我们还需要通过Docker的具体架构，来了解Docker的整个运行流程。接下来借助Docker官网的架构图来对Docker架构进行详细说明，如下图所示。
![alt](/article_img/docker/2.jpg)
  从图中可以看出，Docker架构主要包括Client、DOCKER_HOST和Register三部分，关于这三部分的具体说明如下。  
&emsp;&emsp;**（1）Client（客户端）**  
  Client即Docker客户端，也就是上一小节Docker Engine中介绍的docker CLI。开发者通过这个客户端使用Docker的相关指令与Docker守护进程进行交互，从而进行Docker镜像的创建、拉取和运行等操作。  
&emsp;&emsp;**（2）DOCKER_HOST（Docker主机）**  
  DOCKER_HOST即Docker内部引擎运行的主机，主要指Docker daemon（Docker守护进程）。可以通过Docker守护进程与客户端还有Docker的镜像仓库Registry进行交互，从而管理Images（镜像）和Containers（容器）等。  
&emsp;&emsp;**（3）Registry（注册中心）**  
  Registry即Docker注册中心，实质就是Docker镜像仓库，默认使用的是Docker官方远程注册中心Docker Hub，也可以使用开发者搭建的本地仓库。Registry中包含了大量的镜像，这些镜像可以是官网基础镜像，也可以是其他开发者上传的镜像。  
  我们在实际使用Docker时，除了会涉及到图中的三个主要部分外，还会涉及到很多Docker Objects（Docker对象），例如Images（镜像）、Containers（容器）、Networks（网络）、Volumes（数据卷）、Plugins（插件）等。其中常用的两个对象Image和Containers的说明如下。  
  ①Images（镜像）  
  Docker 镜像就是一个只读的模板，包含了一些创建Docker容器的操作指令。通常情况下，一个Docker镜像是基于另一个基础镜像创建的，并且新创建的镜像会额外包含一些功能配置。例如：开发者可以依赖于一个Ubuntu的基础镜像创建一个新镜像，并可以在新镜像中安装Apache等软件或其它应用程序。  
  ②Containers（容器）  
  Docker容器属于镜像的一个可运行实例（镜像与容器的关系其实与Java中的类与对象相似），开发者可以通过API接口或者CLI命令行接口来创建、运行、停止、移动、删除一个容器，也可以将一个容器连接到一个或多个网络中，将数据存储与容器进行关联。



, 2018-12-03, null, 默认分类, 虚拟化容器,Docker,运行机制, true, null, 26, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20038, rs-50036} Result: [10, Docker常用客户端指令介绍,   在使用Docker之前，首先会为对应的项目编写Dockerfile镜像构建文件，然后通过Docker的相关指令进行镜像构建，完成镜像的构建后，就可以使用这些项目镜像进行启动测试了。所以要想知道如何使用Docker来执行这些Dockerfile镜像构建文件，还需要学习Docker客户端的常用指令，本篇文章将对Docker客户端的常用指令进行详细讲解。  

**1.列出镜像**  
  通过docker images指令可以查看本地镜像列表中已有的镜像，具体使用方式如下。
```js
$ docker images
```  
  执行上述指令后，系统会将所有本地镜像都展示出来，如下图所示。
![alt](/article_img/docker/3.png)
  从图中可以看出，系统终端将本地镜像列表中的3个镜像分5列进行了展示，每一列的具体含义如下。  
  ●REPOSITORY：镜像名称。  
  ●TAG：镜像的参数，类似于版本号，默认是latest。  
  ●IMAGE ID：镜像ID，是唯一值。此处看到的是一个长度为12的字符串，实际上它是64位完整镜像ID的缩写形式。  
  ●CREATED：距今创建镜像的时间。  
  ●SIZE：镜像大小。    

**2.搜索镜像**  
  想知道在Docker Hub中包含了哪些镜像，除了可以登录Docker Hub，在官网中心进行查看外，还可以直接在Docker客户端进行查询。例如想要查询Ubuntu镜像，可以使用如下指令。
```js
$ docker search ubuntu
```  
  执行上述指令后，系统终端就会将搜索到的有关Ubuntu的镜像展示出来，如下图所示。
![alt](/article_img/docker/4.png)
  从图所示的结果可以看出，系统终端分5列将搜索到的Ubuntu相关镜像都列举出来了，这5列的具体含义如下。  
  ●NAME：表示镜像的名称，这里有两种格式的名称，其中不带有“/”的表示官方镜像，而带有“/”的表示其他用户的公开镜像。公开镜像“/”前面是用户在Docker Hub上的用户名（唯一），后面是对应的镜像名；官方镜像与用户镜像，除了从镜像名称上可以区分外，还可以通过第4列的OFFICIAL声明中看出（该列下内容为OK表示官方镜像）。  
  ●DESCRIPTION：表示镜像的描述，这里只显示了一小部分。  
  ●STARS：表示该镜像的收藏数，用户可以在Docker Hub上对镜像进行收藏，一般可以通过该数字反应出该镜像的受欢迎程度。  
  ●OFFICIAL：表示是否为官方镜像。  
  ●AUTOMATED：表示是否自动构建镜像。例如，用户可以将自己的Docker Hub绑定到如Github上，当代码提交更新后，可以自动构建镜像。   
 
**3.拉取镜像**  
  通过docker pull指令可以拉取仓库镜像到本地（默认都是拉取Docker Hub仓库镜像，也可以指定“IP+端口”拉取某个Docker机器上的私有仓库镜像），具体使用方式如下。
```js
$ docker pull ubuntu
```  
  执行上述指令后，Docker会自动从Docker Hub上下载最新版本的Ubuntu到本地，当然也可以使用以下指令拉取指定版本的镜像到本地，具体指令如下。
```js
$ docker pull ubuntu:14.04
```  
**4.构建镜像**  
  除了可以通过docker pull指令从仓库拉取镜像外，还可以通过docker build指令构建Docker镜像，通常情况下都是通过Dockerfile文件来构建镜像的。  
  这里假设linux系统home目录下/shitou/workspace/dockerspace文件夹中编写有对应的Dockerfile文件，则构建镜像直立示例如下所示。 
```js
$ docker build -t hellodocker3 /home/shitou/workspace/dockerspace/.
```
**5.删除镜像**  
  当本地存放过多不需要的镜像时，可以通过docker rmi指令将其删除。在删除镜像时，需要指定镜像名称或镜像ID。删除镜像的使用方式如下。
```js
$ docker rmi -f hellodocker2 hellodocker3
```  
  上述指令中，docker rmi表示删除镜像，-f表示进行强制删除，而hellodocker2和hellodocker3分别表示需要删除的镜像名称，这里同时删除两个镜像。除了根据名称删除镜像外，还也可以根据镜像ID来删除镜像，只是这里如果指定了删除ID为23c617a866d4的镜像后，会同时删除hellodocker、hellodocker2和hellodocker3三个镜像。  
  需要特别强调的是，在进行镜像删除操作时，如果是通过镜像ID进行镜像删除，那么由该镜像创建的容器必须提前删除或停止。另外，在通过镜像名称操作镜像时，如果出现镜像重名的情况，必须在镜像名称后面指定镜像标签tag参数来确保唯一性。

**6.创建并启动容器**  
  Docker镜像主要用于创建容器，可以使用docker run指令创建并启动容器，具体使用方式如下。
```js
$ docker run -d -p 5000:80 --name test hellodocker
```  
  上述创建并启动容器的指令略微复杂，具体分析如下。  
  ●docker run：表示创建并启动一个容器，而后面的hellodocker就表示要启动运行的镜像名称；  
  ●-d：表示容器启动时在后台运行；  
  ●-p 5000:80：表示将容器内暴露的80端口映射到宿主机指定的5000端口，也可以将-p 5000:80更改为-P来映射主机的随机端口（注意p字母的大小写）；  
  ●--name test：表示为创建后的容器指定名称为test，如果没有该参数配置，则生成的容器会设置一个随机名称。  
  docker run命令是Docker操作中较为复杂的一个，它可以携带多个参数和参数，我们可以通过docker run --help指令进行查看，其中有些参数如-e、-v和-w等都可以在Dockerfile文件中预先声明。 
 
**7.列出容器**  
  生成容器后，可以通过docker ps指令查看当前运行的所有容器，具体使用方式如下。
```js
$ docker ps
```  
  执行上述命令后，会将所有当前运行的容器都展示出来，具体如下图所示。
![alt](/article_img/docker/5.png)
  从图中可以看出，系统终端通过7列对当前的正在运行的一个容器进行了展示，图中每一列的具体含义如下。  
  ●CONTAINER ID：表示生成的容器ID；  
  ●IMAGE：表示生成该容器的镜像名称；  
  ●COMMAND：表示启动容器时运行的命令，Docker要求在启动容器时必须运行一个命令；  
  ●CREATED：表示容器创建的时间；  
  ●STATUS：表示容器运行状态，例如Up表示运行中，Exited表示已停止；  
  ●PORTS：表示容器内部暴露的端口映射到主机的端口；  
  ●NAMES：表示生成容器的名称，由Docker引擎自动生成，可以像上述示例中使用--name参数指定生成容器的名称。  
  另外，docker ps指令运行过程中可以指定多个参数，还可以通过docker ps --help指令对ps指令的其他信息进行查看。

**8.删除容器**  
  当不需要使用容器时，则可以使用docker rm指令删除已停止的容器，具体使用方式如下。
```js
$ docker rm f0c9a8b6e8c5
```  
  需要注意的是，上述指令只能删除已经停止运行的容器，而不能删除正在运行的容器。如果想要删除正在运行的容器，则需要添加-f参数强制删除，具体使用方式如下。
```js
$ docker rm -f f0c9a8b6e8c5
```  
  当需要删除的容器过多时，如果还一个个的删除就略显麻烦了，此时可以通过如下指令将全部容器删除。
```js
$ docker rm -f $(docker ps -aq)
```  
  上述指令中，首先会通过$(docker ps -aq)获取所有容器的ID，然后通过docker rm -f指令进行强制删除。如果开发者有自己特殊的删除需求，可以根据前面docker ps指令进行组装来获取需要删除的容器ID。  
  Docker提供的操作指令远不止这些，这里就不一一列举了，想要了解更多Docker的操作指令，可以通过docker --help指令进行查看。


, 2018-12-05, null, 默认分类, Docker,客户端指令, true, null, 21, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20038, rs-50036} Result: [11, Docker数据管理介绍,   当我们对容器进行相关操作时，产生的一系列数据都会存储在容器中，而Docker内部又是如果管理这些数据的呢？本篇文章将针对Docker数据管理的一些知识进行介绍。
  
**1. Docker数据存储机制**  
  使用Docker时，我们操作的都是镜像和由镜像生成的容器，所以想要更好的了解Docker内部的数据存储机制，就必须从镜像、容器与数据存储的关系出发。  
  Docker镜像是通过读取Dockerfile文件中的指令构建的，Dockerfile中的每条指令都会创建一个镜像层，并且每层都是只读的，这一系列的镜像层就构成了Docker镜像。接下来以一个Dockerfile文件为例进行说明，具体如下列代码示例所示。
```js
 1	FROM ubuntu:16.04
 2	COPY . /app
 3	RUN make /app
 4	CMD python /app/app.py
```  
   上述文件示例中的Dockerfile包含了4条指令，每条指令都会创建一个镜像层，其中每一层与前一层都有所不同，并且是层层叠加的。通过镜像构建容器时，会在镜像层上增加一个容器层（即可写层），所有对容器的更改都会写入容器层，这也是Docker默认的数据存储方式。  
  下面通过一个效果图进行说明，具体如下图所示。
![alt](/article_img/docker/6.png)
  从图中可以看出，Docker容器和镜像之间的主要区别是顶部的容器层，而所有对容器中数据的添加、修改等操作都会被存储在容器层中。当容器被删除时，容器层也会被删除，其中存储的数据会被一同删除，而下面的镜像层却保持不变。  
  由于所有的容器都是通过镜像构建的，所以每个容器都有各自的容器层，对于容器数据的更改就会保存在各自的容器层中。也就是说，由同一个镜像构建的多个容器，它们会拥有相同的底部镜像层，而拥有不同的容器层，多个容器可以访问相同的镜像层，并且有自己的独立数据状态。具体说明如下图所示。 
![alt](/article_img/docker/7.png)
  从图中可以看出，基于同一个镜像构建的多个容器可以共享该镜像层，但是多个容器想要共享相同的数据，就需要将这些数据存储到容器之外的地方，而这种方式就是下一节要提到的Docker volume数据外部挂载机制。  

**2. Docker数据存储方式**    
  在默认情况下，Docker中的数据都是存放在容器层的，但是这样存储数据却有较多的缺陷，具体表现如下。    
  ●当容器不再运行时，容器中的数据无法持久化保存，如果另一个进程需要这些数据，那么将很难从容器中获取数据；  
  ●容器层与正在运行的主机紧密耦合，不能轻易地移动数据；  
  ●容器层需要一个存储驱动程序来管理文件系统，存储驱动程序提供了一个使用Linux内核的联合文件系统，这种额外的抽象化降低了性能。  
  基于上述种种原因，多数情况下Docker数据管理都不会直接将数据写入容器层，而是使用另一种叫做Docker volume数据外部挂载的机制进行数据管理。  
  针对Docker volume数据外部挂载机制，Docker提供了三种不同的方式将数据从容器映射到Docker宿主机，他们分别为：volumes（数据卷）、bind mounts（绑定挂载）和tmpfs mounts（tmpfs挂载）。这三种数据管理方式的具体选择，需要结合实际情况进行考虑，其中的volumes数据卷是最常用也是官方推荐的数据管理方式。无论选择使用哪种数据管理方式，数据在容器内看起来都一样的，而在容器外则会被被挂载到文件系统中的某个目录或文件中。    
  下面通过一张图来展示数据卷、绑定挂载和tmpfs挂载之间的差异，如下图所示。  
![alt](/article_img/docker/8.png)
  从图中可以看出，Docker提供的三种数据管理方式略有不同，具体分析如下。  
  ●volumes：存储在主机文件系统中（在Linux系统下是存在于/var/lib/Docker/volumes/目录），并由Docker管理，非Docker进程无法修改文件系统的这个部分。  
  ●bind mounts：可以存储在主机系统的任意位置，甚至可能是重要的系统文件或目录，在Docker主机或容器上的非Docker进程可以对他们进行任意修改。  
  ●tmpfs mounts：只存储在主机系统的内存中，并没有写入到主机的文件系统中。


, 2018-12-07, 2021-05-19, 默认分类, Docker,数据管理, true, null, 19, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20038, rs-50036} Result: [6, JDK 8——Lambda表达式介绍,   Lambda表达式是JDK 8中一个重要的新特性，它使用一个清晰简洁的表达式来表达一个接口，同时Lambda表达式也简化了对集合以及数组数据的遍历、过滤和提取等操作。下面，本篇文章就对Lambda表达式进行简要介绍，并进行演示说明。

**1. Lambda表达式入门**  

  匿名内部类存在的一个问题是，如果匿名内部类的实现非常简单，例如只包含一个抽象方法的接口，那么匿名内部类的语法仍然显得比较冗余。为此，JDK 8中新增了一个特性Lambda表达式，这种表达式只针对有一个抽象方法的接口实现，以简洁的表达式形式实现接口功能来作为方法参数。  
  一个Lambda表达式由三个部分组成，分别为参数列表、“->”和表达式主体，其语法格式如下：
```js
 ([数据类型 参数名,数据类型 参数名,...]) -> {表达式主体}
```  
  从上述语法格式上看，Lambda表达式的书写非常简单，下面针对Lambda表达式的组成部分进行简单介绍，具体如下：  
  （1）([数据类型 参数名,数据类型 参数名,...])：用来向表达式主体传递接口方法需要的参数，多个参数名中间必须用英文逗号“,”进行分隔；在编写Lambda表达式时，可以省略参数的数据类型，后面的表达式主体会自动进行校对和匹配；同时，如果只有一个参数，则可以省略括号“()”。  
  （2）->：表示Lambda表达式箭牌，用来指定参数数据指向，不能省略，且必须用英文横线和大于号书写。  
  （3）{表达式主体}：由单个表达式或语句块组成的主体，本质就是接口中抽象方法的具体实现，如果表达式主体只有一条语句，那么可以省略包含主体的大括号；另外，在Lambda表达式主体中允许有返回值，当只有一条return语句时，也可以省略return关键字。  
  了解了Lambda表达式的语法后，接下来编写一个示例文件对Lambda表达式的基本使用进行介绍，具体代码如下所示。
```js
 1	// 定义动物类接口
 2	interface Animal { 
 3		void shout(); // 定义方法shout()
 4	}
 5	public class Example22 {
 6		public static void main(String[] args) {
 7	       String name = "小花"; 
 8	       // 1、匿名内部类作为参数传递给animalShout()方法
 9		  animalShout(new Animal() { 
 10				 public void shout() { 
 11				    System.out.println("匿名内部类输出："+name+"喵喵...");
 12				}
 13		  });
 14		  // 2、使用Lambda表达式作为参数传递给animalShout()方法
 15	       animalShout(()-> System.out.println("Lambda表达式输出："
 16	                                                   +name+"喵喵..."));
 17		}
 18	    // 创建一个animalShout()静态方法，接收接口类型的参数
 19		public static void animalShout(Animal an) {
 20			an.shout();  
 21		}
 22	}
```  
  运行结果下图所示。
![alt](/article_img/lambda/1.jpg)
  上述代码示例中，先定义了只有一个抽象方法的接口Animal，然后分别使用匿名内部类和Lambda表达式的方式实现了接口方法。从图中可以看出，使用匿名内部类和Lambda表达式都能实现接口中方法，但很显然使用Lambda表达式更加简洁和清晰。, 2018-11-27, null, 默认分类, 2018,Lambda表达式, true, null, 18, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20038, rs-50036} Result: [7, 函数式接口, &emsp;&emsp;虽然Lambda表达式可以实现匿名内部类的功能，但在使用时却有一个局限，即接口中有且只有一个抽象方法时才能使用Lamdba表达式代替匿名内部类。这是因为Lamdba表达式是基于函数式接口实现的，所谓函数式接口是指有且仅有一个抽象方法的接口，Lambda表达式就是Java中函数式编程的体现，只有确保接口中有且仅有一个抽象方法，Lambda表达式才能顺利地推导出所实现的这个接口中的方法。  
&emsp;&emsp;在JDK 8中，专门为函数式接口引入了一个@FunctionalInterface注解，该注解只是显示的标注了接口是一个函数式接口，并强制编辑器进行更严格的检查，确保该接口是函数式接口，如果不是函数式接口，那么编译器就会报错，而对程序运行并没有实质上的影响。  
&emsp;&emsp;接下来通过一个案例来演示函数式接口的定义与使用，示例代码如下所示。
```js
 1	// 定义无参、无返回值的函数式接口
 2	@FunctionalInterface
 3	interface Animal {
 4		void shout();
 5	}
 6	// 定义有参、有返回值的函数式接口
 7	interface Calculate {
 8		int sum(int a, int b);
 9	}
 10	public class Example23 {
 11		public static void main(String[] args) {
 12		   // 分别两个函数式接口进行测试
 13		   animalShout(() -> System.out.println("无参、无返回值的函数式接口调用"));
 14		   showSum(10, 20, (x, y) -> x + y);
 15		}
 16		// 创建一个动物叫的方法，并传入接口对象Animal作为参数
 17		private static void animalShout(Animal animal) {
 18			animal.shout();
 19		}
 20		// 创建一个求和的方法，并传入两个int类型以及接口Calculate类型的参数
 21		private static void showSum(int x, int y, Calculate calculate) {
 22		   System.out.println(x + "+" + y + "的和为：" + calculate.sum(x, y));
 23		}
 24	}
```  
&emsp;&emsp;运行结果如下图所示。

![alt](/article_img/lambda/2.jpg)
&emsp;&emsp;上述代码示例中，先定义了两个函数式接口Animal和Calculate，然后在测试类中分别编写了两个静态方法，并将这两个函数式接口以参数的形式传入，最后在main()方法中分别调用这两个静态方法，并将所需要的函数式接口参数以Lambda表达式的形式传入。从图中可以看出，程序中函数式接口的定义和使用完全正确。
, 2018-12-01, null, 默认分类, 接口,函数式接口, true, null, 12, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20038, rs-50036} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20038, rs-50036} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20038, rs-50036} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20038, rs-50036} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20038, rs-50036} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20038} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20039} created. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20039} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20039} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20039} executed. 0.5886 millis. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20039, rs-50037} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20039, rs-50037} Header: [count(0)]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20039, rs-50037} Result: [12]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20039, rs-50037} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20039} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20040} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20040} Parameters : [5]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20040} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20040} executed. 0.6562 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20040, rs-50038} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20040, rs-50038} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20040, rs-50038} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20040, rs-50038} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20040, rs-50038} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20040, rs-50038} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20040, rs-50038} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20040, rs-50038} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20040} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20041} created. select username,password,valid from t_user where username = ?
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20041} Parameters : [admin]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20041} Types : [VARCHAR]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20041, rs-50039} query executed. 8.718 millis. select username,password,valid from t_user where username = ?
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20041, rs-50039} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20041, rs-50039} Header: [username, password, valid]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20041, rs-50039} Result: [admin, $2a$10$5ooQI8dir8jv0/gCa1Six.GpzAdIPf6pMqdminZ/3ijYzivCyPlfK, true]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20041, rs-50039} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20041} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20042} created. select u.username,a.authority from t_user u,t_authority a,t_user_authority ua where ua.user_id=u.id and ua.authority_id=a.id and u.username =?
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20042} Parameters : [admin]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20042} Types : [VARCHAR]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20042, rs-50040} query executed. 5.0335 millis. select u.username,a.authority from t_user u,t_authority a,t_user_authority ua where ua.user_id=u.id and ua.authority_id=a.id and u.username =?
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20042, rs-50040} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20042, rs-50040} Header: [username, authority]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20042, rs-50040} Result: [admin, ROLE_admin]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20042, rs-50040} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20042} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][com.boot.controller.adminController]2021-05-22 22:03:50   用户名：admin进入admim后台
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20043} created. SELECT count(0) FROM t_article, t_comment WHERE t_article.id = t_comment.article_id
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20043} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20043} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20043} executed. 0.5292 millis. SELECT count(0) FROM t_article, t_comment WHERE t_article.id = t_comment.article_id
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20043, rs-50041} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20043, rs-50041} Header: [count(0)]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20043, rs-50041} Result: [12]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20043, rs-50041} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20043} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20044} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_comment.article_id,
	t_comment.c_content,
	t_comment.created,
	t_comment.author,
	t_comment.ip,
	t_comment.status
    FROM
    t_article,
	t_comment
    WHERE
	t_article.id = t_comment.article_id
	order by t_article.created desc LIMIT ? 
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20044} Parameters : [5]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20044} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20044} executed. 14.9835 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_comment.article_id,
	t_comment.c_content,
	t_comment.created,
	t_comment.author,
	t_comment.ip,
	t_comment.status
    FROM
    t_article,
	t_comment
    WHERE
	t_article.id = t_comment.article_id
	order by t_article.created desc LIMIT ? 
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20044, rs-50042} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20044, rs-50042} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, article_id, c_content, created, author, ip, status]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20044, rs-50042} Result: [12, Spring Boot 2 权威发布,   如果这两天登录 [https://start.spring.io/ ](https://start.spring.io/ )就会发现，Spring Boot 默认版本已经升到了 2.1.0。这是因为 Spring Boot 刚刚发布了 2.1.0 版本，我们来看下 Spring Boot 2 发布以来第一个子版本都发布了哪些内容？  

**2.1 中的新特性**     
  ●将spring-boot-starter-oauth2-oidc-client重命名为spring-boot-starter-oauth2-client命名更简洁  
  ●添加 OAuth2 资源服务 starter，OAuth2 一个用于认证的组件  
  ●支持 ConditionalOnBean 和 ConditionalOnMissingBean 下的参数化容器  
  ●自动配置 applicationTaskExecutor bean 的延迟加载来避免不必要的日志记录  
  ●将 DatabaseDriver＃SAP 重命名为 DatabaseDriver  
  ●跳过重启器不仅适用于 JUnit4，也适用于 JUnit5  
  ●在 Jest HealthIndicator 中使用集群端点  
  ●当 DevTools 禁用重启时添加日志输出  
  ●添加注解：@ConditionalOnMissingServletFilter提高 Servlet Filters 的自动装配。
  
**2.1 中的组件升级**  
  ●升级 Hibernate 5.3，Hibernate 的支持升级到了 5.3  
  ●升级 Tomcat 9 ，支持最新的 tomcat 9  
  ●支持 Java 11，Java 现在更新越来越快，Spring 快赶不上了    
  ●升级 Thymeleaf Extras Springsecurity 到 3.0.4.RELEASE ，thymeleaf-extras-springsecurity 是 Thymeleaf 提供集成 Spring Security 的组件  
  ●升级 Joda Time 2.10.1，Joda-Time， 面向 Java 应用程序的日期/时间库的替代选择，Joda-Time 令时间和日期值变得易于管理、操作和理解。  
  ●升级 Lettuce 5.1.2.RELEASE ，Lettuce 前面说过，传说中 Redis 最快的客户端。  
  ●升级 Reactor Californium-SR2 ，Californium 是物联网云服务的 Java COAP 实现。因此，它更专注的是可扩展性和可用性而不是像嵌入式设备那样关注资源效率。不过，Californium 也适合嵌入式的 JVM。  
  ●升级 Maven Failsafe Plugin 2.22.1 ，Maven 中的测试插件。  
  ●升级 Flyway 5.2.1 ， Flyway是一款开源的数据库版本管理工具  
  ●升级 Aspectj 1.9.2 ，AspectJ 是 Java 中流行的 AOP（Aspect-oriented Programming）编程扩展框架，是 Eclipse 托管给 Apache 基金会的一个开源项目。  
  ●升级 Mysql 8.0.13 ，Mysql 支持到 8。  
  ●...  
  更多的详细内容可以参考这里：[Spring Boot 2.1 Release Notes](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.1-Release-Notes)
, 2018-12-12, 2021-05-21, 默认分类, Spring Boot 2, true, null, 12, 很不错，不过这文章排版不太好看啊, 2018-12-13, 李四, 0:0:0:0:0:0:0:1, approved]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20044, rs-50042} Result: [12, Spring Boot 2 权威发布,   如果这两天登录 [https://start.spring.io/ ](https://start.spring.io/ )就会发现，Spring Boot 默认版本已经升到了 2.1.0。这是因为 Spring Boot 刚刚发布了 2.1.0 版本，我们来看下 Spring Boot 2 发布以来第一个子版本都发布了哪些内容？  

**2.1 中的新特性**     
  ●将spring-boot-starter-oauth2-oidc-client重命名为spring-boot-starter-oauth2-client命名更简洁  
  ●添加 OAuth2 资源服务 starter，OAuth2 一个用于认证的组件  
  ●支持 ConditionalOnBean 和 ConditionalOnMissingBean 下的参数化容器  
  ●自动配置 applicationTaskExecutor bean 的延迟加载来避免不必要的日志记录  
  ●将 DatabaseDriver＃SAP 重命名为 DatabaseDriver  
  ●跳过重启器不仅适用于 JUnit4，也适用于 JUnit5  
  ●在 Jest HealthIndicator 中使用集群端点  
  ●当 DevTools 禁用重启时添加日志输出  
  ●添加注解：@ConditionalOnMissingServletFilter提高 Servlet Filters 的自动装配。
  
**2.1 中的组件升级**  
  ●升级 Hibernate 5.3，Hibernate 的支持升级到了 5.3  
  ●升级 Tomcat 9 ，支持最新的 tomcat 9  
  ●支持 Java 11，Java 现在更新越来越快，Spring 快赶不上了    
  ●升级 Thymeleaf Extras Springsecurity 到 3.0.4.RELEASE ，thymeleaf-extras-springsecurity 是 Thymeleaf 提供集成 Spring Security 的组件  
  ●升级 Joda Time 2.10.1，Joda-Time， 面向 Java 应用程序的日期/时间库的替代选择，Joda-Time 令时间和日期值变得易于管理、操作和理解。  
  ●升级 Lettuce 5.1.2.RELEASE ，Lettuce 前面说过，传说中 Redis 最快的客户端。  
  ●升级 Reactor Californium-SR2 ，Californium 是物联网云服务的 Java COAP 实现。因此，它更专注的是可扩展性和可用性而不是像嵌入式设备那样关注资源效率。不过，Californium 也适合嵌入式的 JVM。  
  ●升级 Maven Failsafe Plugin 2.22.1 ，Maven 中的测试插件。  
  ●升级 Flyway 5.2.1 ， Flyway是一款开源的数据库版本管理工具  
  ●升级 Aspectj 1.9.2 ，AspectJ 是 Java 中流行的 AOP（Aspect-oriented Programming）编程扩展框架，是 Eclipse 托管给 Apache 基金会的一个开源项目。  
  ●升级 Mysql 8.0.13 ，Mysql 支持到 8。  
  ●...  
  更多的详细内容可以参考这里：[Spring Boot 2.1 Release Notes](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.1-Release-Notes)
, 2018-12-12, 2021-05-21, 默认分类, Spring Boot 2, true, null, 12, 000111, 2021-05-21, admin, 0:0:0:0:0:0:0:1, approved]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20044, rs-50042} Result: [11, Docker数据管理介绍,   当我们对容器进行相关操作时，产生的一系列数据都会存储在容器中，而Docker内部又是如果管理这些数据的呢？本篇文章将针对Docker数据管理的一些知识进行介绍。
  
**1. Docker数据存储机制**  
  使用Docker时，我们操作的都是镜像和由镜像生成的容器，所以想要更好的了解Docker内部的数据存储机制，就必须从镜像、容器与数据存储的关系出发。  
  Docker镜像是通过读取Dockerfile文件中的指令构建的，Dockerfile中的每条指令都会创建一个镜像层，并且每层都是只读的，这一系列的镜像层就构成了Docker镜像。接下来以一个Dockerfile文件为例进行说明，具体如下列代码示例所示。
```js
 1	FROM ubuntu:16.04
 2	COPY . /app
 3	RUN make /app
 4	CMD python /app/app.py
```  
   上述文件示例中的Dockerfile包含了4条指令，每条指令都会创建一个镜像层，其中每一层与前一层都有所不同，并且是层层叠加的。通过镜像构建容器时，会在镜像层上增加一个容器层（即可写层），所有对容器的更改都会写入容器层，这也是Docker默认的数据存储方式。  
  下面通过一个效果图进行说明，具体如下图所示。
![alt](/article_img/docker/6.png)
  从图中可以看出，Docker容器和镜像之间的主要区别是顶部的容器层，而所有对容器中数据的添加、修改等操作都会被存储在容器层中。当容器被删除时，容器层也会被删除，其中存储的数据会被一同删除，而下面的镜像层却保持不变。  
  由于所有的容器都是通过镜像构建的，所以每个容器都有各自的容器层，对于容器数据的更改就会保存在各自的容器层中。也就是说，由同一个镜像构建的多个容器，它们会拥有相同的底部镜像层，而拥有不同的容器层，多个容器可以访问相同的镜像层，并且有自己的独立数据状态。具体说明如下图所示。 
![alt](/article_img/docker/7.png)
  从图中可以看出，基于同一个镜像构建的多个容器可以共享该镜像层，但是多个容器想要共享相同的数据，就需要将这些数据存储到容器之外的地方，而这种方式就是下一节要提到的Docker volume数据外部挂载机制。  

**2. Docker数据存储方式**    
  在默认情况下，Docker中的数据都是存放在容器层的，但是这样存储数据却有较多的缺陷，具体表现如下。    
  ●当容器不再运行时，容器中的数据无法持久化保存，如果另一个进程需要这些数据，那么将很难从容器中获取数据；  
  ●容器层与正在运行的主机紧密耦合，不能轻易地移动数据；  
  ●容器层需要一个存储驱动程序来管理文件系统，存储驱动程序提供了一个使用Linux内核的联合文件系统，这种额外的抽象化降低了性能。  
  基于上述种种原因，多数情况下Docker数据管理都不会直接将数据写入容器层，而是使用另一种叫做Docker volume数据外部挂载的机制进行数据管理。  
  针对Docker volume数据外部挂载机制，Docker提供了三种不同的方式将数据从容器映射到Docker宿主机，他们分别为：volumes（数据卷）、bind mounts（绑定挂载）和tmpfs mounts（tmpfs挂载）。这三种数据管理方式的具体选择，需要结合实际情况进行考虑，其中的volumes数据卷是最常用也是官方推荐的数据管理方式。无论选择使用哪种数据管理方式，数据在容器内看起来都一样的，而在容器外则会被被挂载到文件系统中的某个目录或文件中。    
  下面通过一张图来展示数据卷、绑定挂载和tmpfs挂载之间的差异，如下图所示。  
![alt](/article_img/docker/8.png)
  从图中可以看出，Docker提供的三种数据管理方式略有不同，具体分析如下。  
  ●volumes：存储在主机文件系统中（在Linux系统下是存在于/var/lib/Docker/volumes/目录），并由Docker管理，非Docker进程无法修改文件系统的这个部分。  
  ●bind mounts：可以存储在主机系统的任意位置，甚至可能是重要的系统文件或目录，在Docker主机或容器上的非Docker进程可以对他们进行任意修改。  
  ●tmpfs mounts：只存储在主机系统的内存中，并没有写入到主机的文件系统中。


, 2018-12-07, 2021-05-19, 默认分类, Docker,数据管理, true, null, 11, 很不错的原理分析，受用了！, 2018-12-13, 李四, 0:0:0:0:0:0:0:1, approved]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20044, rs-50042} Result: [10, Docker常用客户端指令介绍,   在使用Docker之前，首先会为对应的项目编写Dockerfile镜像构建文件，然后通过Docker的相关指令进行镜像构建，完成镜像的构建后，就可以使用这些项目镜像进行启动测试了。所以要想知道如何使用Docker来执行这些Dockerfile镜像构建文件，还需要学习Docker客户端的常用指令，本篇文章将对Docker客户端的常用指令进行详细讲解。  

**1.列出镜像**  
  通过docker images指令可以查看本地镜像列表中已有的镜像，具体使用方式如下。
```js
$ docker images
```  
  执行上述指令后，系统会将所有本地镜像都展示出来，如下图所示。
![alt](/article_img/docker/3.png)
  从图中可以看出，系统终端将本地镜像列表中的3个镜像分5列进行了展示，每一列的具体含义如下。  
  ●REPOSITORY：镜像名称。  
  ●TAG：镜像的参数，类似于版本号，默认是latest。  
  ●IMAGE ID：镜像ID，是唯一值。此处看到的是一个长度为12的字符串，实际上它是64位完整镜像ID的缩写形式。  
  ●CREATED：距今创建镜像的时间。  
  ●SIZE：镜像大小。    

**2.搜索镜像**  
  想知道在Docker Hub中包含了哪些镜像，除了可以登录Docker Hub，在官网中心进行查看外，还可以直接在Docker客户端进行查询。例如想要查询Ubuntu镜像，可以使用如下指令。
```js
$ docker search ubuntu
```  
  执行上述指令后，系统终端就会将搜索到的有关Ubuntu的镜像展示出来，如下图所示。
![alt](/article_img/docker/4.png)
  从图所示的结果可以看出，系统终端分5列将搜索到的Ubuntu相关镜像都列举出来了，这5列的具体含义如下。  
  ●NAME：表示镜像的名称，这里有两种格式的名称，其中不带有“/”的表示官方镜像，而带有“/”的表示其他用户的公开镜像。公开镜像“/”前面是用户在Docker Hub上的用户名（唯一），后面是对应的镜像名；官方镜像与用户镜像，除了从镜像名称上可以区分外，还可以通过第4列的OFFICIAL声明中看出（该列下内容为OK表示官方镜像）。  
  ●DESCRIPTION：表示镜像的描述，这里只显示了一小部分。  
  ●STARS：表示该镜像的收藏数，用户可以在Docker Hub上对镜像进行收藏，一般可以通过该数字反应出该镜像的受欢迎程度。  
  ●OFFICIAL：表示是否为官方镜像。  
  ●AUTOMATED：表示是否自动构建镜像。例如，用户可以将自己的Docker Hub绑定到如Github上，当代码提交更新后，可以自动构建镜像。   
 
**3.拉取镜像**  
  通过docker pull指令可以拉取仓库镜像到本地（默认都是拉取Docker Hub仓库镜像，也可以指定“IP+端口”拉取某个Docker机器上的私有仓库镜像），具体使用方式如下。
```js
$ docker pull ubuntu
```  
  执行上述指令后，Docker会自动从Docker Hub上下载最新版本的Ubuntu到本地，当然也可以使用以下指令拉取指定版本的镜像到本地，具体指令如下。
```js
$ docker pull ubuntu:14.04
```  
**4.构建镜像**  
  除了可以通过docker pull指令从仓库拉取镜像外，还可以通过docker build指令构建Docker镜像，通常情况下都是通过Dockerfile文件来构建镜像的。  
  这里假设linux系统home目录下/shitou/workspace/dockerspace文件夹中编写有对应的Dockerfile文件，则构建镜像直立示例如下所示。 
```js
$ docker build -t hellodocker3 /home/shitou/workspace/dockerspace/.
```
**5.删除镜像**  
  当本地存放过多不需要的镜像时，可以通过docker rmi指令将其删除。在删除镜像时，需要指定镜像名称或镜像ID。删除镜像的使用方式如下。
```js
$ docker rmi -f hellodocker2 hellodocker3
```  
  上述指令中，docker rmi表示删除镜像，-f表示进行强制删除，而hellodocker2和hellodocker3分别表示需要删除的镜像名称，这里同时删除两个镜像。除了根据名称删除镜像外，还也可以根据镜像ID来删除镜像，只是这里如果指定了删除ID为23c617a866d4的镜像后，会同时删除hellodocker、hellodocker2和hellodocker3三个镜像。  
  需要特别强调的是，在进行镜像删除操作时，如果是通过镜像ID进行镜像删除，那么由该镜像创建的容器必须提前删除或停止。另外，在通过镜像名称操作镜像时，如果出现镜像重名的情况，必须在镜像名称后面指定镜像标签tag参数来确保唯一性。

**6.创建并启动容器**  
  Docker镜像主要用于创建容器，可以使用docker run指令创建并启动容器，具体使用方式如下。
```js
$ docker run -d -p 5000:80 --name test hellodocker
```  
  上述创建并启动容器的指令略微复杂，具体分析如下。  
  ●docker run：表示创建并启动一个容器，而后面的hellodocker就表示要启动运行的镜像名称；  
  ●-d：表示容器启动时在后台运行；  
  ●-p 5000:80：表示将容器内暴露的80端口映射到宿主机指定的5000端口，也可以将-p 5000:80更改为-P来映射主机的随机端口（注意p字母的大小写）；  
  ●--name test：表示为创建后的容器指定名称为test，如果没有该参数配置，则生成的容器会设置一个随机名称。  
  docker run命令是Docker操作中较为复杂的一个，它可以携带多个参数和参数，我们可以通过docker run --help指令进行查看，其中有些参数如-e、-v和-w等都可以在Dockerfile文件中预先声明。 
 
**7.列出容器**  
  生成容器后，可以通过docker ps指令查看当前运行的所有容器，具体使用方式如下。
```js
$ docker ps
```  
  执行上述命令后，会将所有当前运行的容器都展示出来，具体如下图所示。
![alt](/article_img/docker/5.png)
  从图中可以看出，系统终端通过7列对当前的正在运行的一个容器进行了展示，图中每一列的具体含义如下。  
  ●CONTAINER ID：表示生成的容器ID；  
  ●IMAGE：表示生成该容器的镜像名称；  
  ●COMMAND：表示启动容器时运行的命令，Docker要求在启动容器时必须运行一个命令；  
  ●CREATED：表示容器创建的时间；  
  ●STATUS：表示容器运行状态，例如Up表示运行中，Exited表示已停止；  
  ●PORTS：表示容器内部暴露的端口映射到主机的端口；  
  ●NAMES：表示生成容器的名称，由Docker引擎自动生成，可以像上述示例中使用--name参数指定生成容器的名称。  
  另外，docker ps指令运行过程中可以指定多个参数，还可以通过docker ps --help指令对ps指令的其他信息进行查看。

**8.删除容器**  
  当不需要使用容器时，则可以使用docker rm指令删除已停止的容器，具体使用方式如下。
```js
$ docker rm f0c9a8b6e8c5
```  
  需要注意的是，上述指令只能删除已经停止运行的容器，而不能删除正在运行的容器。如果想要删除正在运行的容器，则需要添加-f参数强制删除，具体使用方式如下。
```js
$ docker rm -f f0c9a8b6e8c5
```  
  当需要删除的容器过多时，如果还一个个的删除就略显麻烦了，此时可以通过如下指令将全部容器删除。
```js
$ docker rm -f $(docker ps -aq)
```  
  上述指令中，首先会通过$(docker ps -aq)获取所有容器的ID，然后通过docker rm -f指令进行强制删除。如果开发者有自己特殊的删除需求，可以根据前面docker ps指令进行组装来获取需要删除的容器ID。  
  Docker提供的操作指令远不止这些，这里就不一一列举了，想要了解更多Docker的操作指令，可以通过docker --help指令进行查看。


, 2018-12-05, null, 默认分类, Docker,客户端指令, true, null, 10, 关于Docker虚拟容器的讲解挺好的额，学习中, 2018-12-13, 李四, 0:0:0:0:0:0:0:1, approved]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20044, rs-50042} Result: [9, 虚拟化容器技术——Docker运行机制介绍,   Docker是一个开源的应用容器引擎，它基于go语言开发，并遵从Apache2.0开源协议。使用Docker可以让开发者封装他们的应用以及依赖包到一个可移植的容器中，然后发布到任意的Linux机器上，也可以实现虚拟化。Docker容器完全使用沙箱机制，相互之间不会有任何接口，这保证了容器之间的安全性。  

**1. Docker的引擎介绍**

  Docker Engine（Docker引擎）是Docker的核心部分，使用的是客户端-服务器（C/S）架构模式，其主要组成部分如下图所示。
![alt](/article_img/docker/1.png)
  从上图可以看出，Docker Engine中包含了三个核心组件（docker CLI、REST API和docker daemon），这三个组件的具体说明如下：  
  ①docker CLI（command line interface）：表示Docker命令行接口，开发者可以在命令行中使用Docker相关指令与Docker守护进程进行交互，从而管理诸如image（镜像）、container（容器）、network（网络）和data volumes（数据卷）等实体。  
  ②REST API：表示应用程序API接口，开发者通过该API接口可以与Docker的守护进程进行交互，从而指示后台进行相关操作。  
  ③docker daemon：表示Docker的服务端组件，他是Docker架构中运行在后台的一个守护进程，可以接收并处理来自命令行接口及API接口的指令，然后进行相应的后台操作。  
  对于开发者而言，既可以使用编写好的脚本文件通过REST API来实现与Docker进程交互，又可以直接使用Docker相关指令通过命令行接口来与Docker进程交互，而其他一些Docker应用则是通过底层的API和CLI进行交互的。

**2. Docker的架构介绍**

  了解了Docker内部引擎及作用后，我们还需要通过Docker的具体架构，来了解Docker的整个运行流程。接下来借助Docker官网的架构图来对Docker架构进行详细说明，如下图所示。
![alt](/article_img/docker/2.jpg)
  从图中可以看出，Docker架构主要包括Client、DOCKER_HOST和Register三部分，关于这三部分的具体说明如下。  
&emsp;&emsp;**（1）Client（客户端）**  
  Client即Docker客户端，也就是上一小节Docker Engine中介绍的docker CLI。开发者通过这个客户端使用Docker的相关指令与Docker守护进程进行交互，从而进行Docker镜像的创建、拉取和运行等操作。  
&emsp;&emsp;**（2）DOCKER_HOST（Docker主机）**  
  DOCKER_HOST即Docker内部引擎运行的主机，主要指Docker daemon（Docker守护进程）。可以通过Docker守护进程与客户端还有Docker的镜像仓库Registry进行交互，从而管理Images（镜像）和Containers（容器）等。  
&emsp;&emsp;**（3）Registry（注册中心）**  
  Registry即Docker注册中心，实质就是Docker镜像仓库，默认使用的是Docker官方远程注册中心Docker Hub，也可以使用开发者搭建的本地仓库。Registry中包含了大量的镜像，这些镜像可以是官网基础镜像，也可以是其他开发者上传的镜像。  
  我们在实际使用Docker时，除了会涉及到图中的三个主要部分外，还会涉及到很多Docker Objects（Docker对象），例如Images（镜像）、Containers（容器）、Networks（网络）、Volumes（数据卷）、Plugins（插件）等。其中常用的两个对象Image和Containers的说明如下。  
  ①Images（镜像）  
  Docker 镜像就是一个只读的模板，包含了一些创建Docker容器的操作指令。通常情况下，一个Docker镜像是基于另一个基础镜像创建的，并且新创建的镜像会额外包含一些功能配置。例如：开发者可以依赖于一个Ubuntu的基础镜像创建一个新镜像，并可以在新镜像中安装Apache等软件或其它应用程序。  
  ②Containers（容器）  
  Docker容器属于镜像的一个可运行实例（镜像与容器的关系其实与Java中的类与对象相似），开发者可以通过API接口或者CLI命令行接口来创建、运行、停止、移动、删除一个容器，也可以将一个容器连接到一个或多个网络中，将数据存储与容器进行关联。



, 2018-12-03, null, 默认分类, 虚拟化容器,Docker,运行机制, true, null, 9, asdaa阿斯顿, 2019-03-30, tom, 0:0:0:0:0:0:0:1, approved]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20044, rs-50042} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20044} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20045} created. SELECT count(0) FROM t_comment
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20045} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20045} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20045} executed. 0.7903 millis. SELECT count(0) FROM t_comment
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20045, rs-50043} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20045, rs-50043} Header: [count(0)]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20045, rs-50043} Result: [12]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20045, rs-50043} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20045} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20046} created. select * from t_comment order by created desc LIMIT ? 
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20046} Parameters : [5]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20046} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20046} executed. 0.3966 millis. select * from t_comment order by created desc LIMIT ? 
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20046, rs-50044} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20046, rs-50044} Header: [id, article_id, created, ip, c_content, status, author]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20046, rs-50044} Result: [18, 12, 2021-05-21, 0:0:0:0:0:0:0:1, 000111, approved, admin]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20046, rs-50044} Result: [17, 2, 2021-05-20, 0:0:0:0:0:0:0:1, 111222, approved, tom]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20046, rs-50044} Result: [15, 9, 2019-03-30, 0:0:0:0:0:0:0:1, asdaa阿斯顿, approved, tom]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20046, rs-50044} Result: [1, 12, 2018-12-13, 0:0:0:0:0:0:0:1, 很不错，不过这文章排版不太好看啊, approved, 李四]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20046, rs-50044} Result: [2, 11, 2018-12-13, 0:0:0:0:0:0:0:1, 很不错的原理分析，受用了！, approved, 李四]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20046, rs-50044} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20046} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20047} created. select count('article_id') from t_article;
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20047} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20047} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20047} executed. 0.9516 millis. select count('article_id') from t_article;
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20047, rs-50045} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20047, rs-50045} Header: [count('article_id')]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20047, rs-50045} Result: [12]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20047, rs-50045} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20047} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20048} created. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20048} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20048} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20048} executed. 0.6458 millis. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20048, rs-50046} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20048, rs-50046} Header: [count(0)]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20048, rs-50046} Result: [12]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20048, rs-50046} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20048} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20049} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20049} Parameters : [5]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20049} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20049} executed. 0.3788 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20049, rs-50047} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20049, rs-50047} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20049, rs-50047} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20049, rs-50047} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20049, rs-50047} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20049, rs-50047} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20049, rs-50047} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20049, rs-50047} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20049} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20050} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20050} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20050} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20050} executed. 0.6831 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20050, rs-50048} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20050, rs-50048} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20050, rs-50048} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20050, rs-50048} Result: [12, Spring Boot 2 权威发布,   如果这两天登录 [https://start.spring.io/ ](https://start.spring.io/ )就会发现，Spring Boot 默认版本已经升到了 2.1.0。这是因为 Spring Boot 刚刚发布了 2.1.0 版本，我们来看下 Spring Boot 2 发布以来第一个子版本都发布了哪些内容？  

**2.1 中的新特性**     
  ●将spring-boot-starter-oauth2-oidc-client重命名为spring-boot-starter-oauth2-client命名更简洁  
  ●添加 OAuth2 资源服务 starter，OAuth2 一个用于认证的组件  
  ●支持 ConditionalOnBean 和 ConditionalOnMissingBean 下的参数化容器  
  ●自动配置 applicationTaskExecutor bean 的延迟加载来避免不必要的日志记录  
  ●将 DatabaseDriver＃SAP 重命名为 DatabaseDriver  
  ●跳过重启器不仅适用于 JUnit4，也适用于 JUnit5  
  ●在 Jest HealthIndicator 中使用集群端点  
  ●当 DevTools 禁用重启时添加日志输出  
  ●添加注解：@ConditionalOnMissingServletFilter提高 Servlet Filters 的自动装配。
  
**2.1 中的组件升级**  
  ●升级 Hibernate 5.3，Hibernate 的支持升级到了 5.3  
  ●升级 Tomcat 9 ，支持最新的 tomcat 9  
  ●支持 Java 11，Java 现在更新越来越快，Spring 快赶不上了    
  ●升级 Thymeleaf Extras Springsecurity 到 3.0.4.RELEASE ，thymeleaf-extras-springsecurity 是 Thymeleaf 提供集成 Spring Security 的组件  
  ●升级 Joda Time 2.10.1，Joda-Time， 面向 Java 应用程序的日期/时间库的替代选择，Joda-Time 令时间和日期值变得易于管理、操作和理解。  
  ●升级 Lettuce 5.1.2.RELEASE ，Lettuce 前面说过，传说中 Redis 最快的客户端。  
  ●升级 Reactor Californium-SR2 ，Californium 是物联网云服务的 Java COAP 实现。因此，它更专注的是可扩展性和可用性而不是像嵌入式设备那样关注资源效率。不过，Californium 也适合嵌入式的 JVM。  
  ●升级 Maven Failsafe Plugin 2.22.1 ，Maven 中的测试插件。  
  ●升级 Flyway 5.2.1 ， Flyway是一款开源的数据库版本管理工具  
  ●升级 Aspectj 1.9.2 ，AspectJ 是 Java 中流行的 AOP（Aspect-oriented Programming）编程扩展框架，是 Eclipse 托管给 Apache 基金会的一个开源项目。  
  ●升级 Mysql 8.0.13 ，Mysql 支持到 8。  
  ●...  
  更多的详细内容可以参考这里：[Spring Boot 2.1 Release Notes](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.1-Release-Notes)
, 2018-12-12, 2021-05-21, 默认分类, Spring Boot 2, true, null, 62, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20050, rs-50048} Result: [8, JDK 8——聚合操作, &emsp;&emsp;在Java8版本中，JDK包含许多聚合操作（如平均值，总和，最小，最大，和计数），返回一个计算流stream的聚合结果。这些聚合操作被称为聚合操作。JDK除返回单个值的聚合操作外，还有很多聚合操作返回一个collection集合实例。很多的reduce操作执行特定的任务，如求平均值或按类别分组元素。  

**1. 聚合操作简介**

  在开发中，多数情况下会涉及到对集合、数组中元素的操作，在JDK 8之前都是通过普通的循环遍历出每一个元素，然后还会穿插一些if条件语句选择性的对元素进行查找、过滤、修改等操作，这种原始的操作方法虽然可行，但是代码量较大并且执行效率较低。  
  为此，JDK 8中新增了一个Stream接口，该接口可以将集合、数组的中的元素转换为Stream流的形式，并结合Lambda表达式的优势来进一步简化集合、数组中元素的查找、过滤、转换等操作，这一新功能就是JDK 8中的聚合操作。  
  在程序中，使用聚合操作没有绝对的语法规范，根据实际操作流程，主要可以分为以下3个步骤：  
  （1）将原始集合或者数组对象转换为Stream流对象；  
  （2）对Stream流对象中的元素进行一系列的过滤、查找等中间操作（Intermediate Operations），然后仍然返回一个Stream流对象；  
  （3）对Stream流进行遍历、统计、收集等终结操作（Terminal Operation），获取想要的结果。  
  接下来，就根据上面聚合操作的3个步骤，通过一个案例来演示聚合操作的基本用法，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example31 {
 4		public static void main(String[] args) {
 5	          // 创建一个List集合对象
 6			List<String> list = new ArrayList<>(); 
 7			list.add("张三");
 8			list.add("李四");
 9			list.add("张小明");
 10			list.add("张阳");
 11			// 1、创建一个Stream流对象
 12			Stream<String> stream = list.stream();
 13			// 2、对Stream流中的元素分别进行过滤、截取操作
 14		       Stream<String> stream2 = stream.filter(i -> i.startsWith("张"));
 15			Stream<String> stream3 = stream2.limit(2);
 16			// 3、对Stream流中的元素进行终结操作，进行遍历输出
 17			stream3.forEach(j -> System.out.println(j));
 18			System.out.println("=======");
 19	         // 通过链式表达式的形式完成聚合操作
 20			list.stream().filter(i -> i.startsWith("张"))
 21						 .limit(2)
 22						 .forEach(j -> System.out.println(j));
 23		}
 24	}
``` 
   运行结果如下图所示。
![alt](/article_img/lambda/3.jpg)
  上述示例代码中，先创建了一个List集合，然后根据聚合操作的3个步骤实现了集合对象的聚合操作，对集合中的元素使用Stream流的形式进行过滤（filter）、截取（limit），并进行遍历输出。其中第12~17行代码分步骤详细展示了聚合操作，而第20~22行代码是使用了链式表达式（调用有返回值的方法时不获取返回值而是直接再调用另一个方法）实现了聚合操作，该表达式的语法格式更简洁、高效，这种链式调用也被称为操作管道流。

**2. 创建Stream流对象**  
  在上一小节中，介绍了聚合操作的主要使用步骤，其中首要解决的问题就是创建Stream流对象。聚合操作针对的就是可迭代数据进行的操作，如集合、数组等，所以创建Stream流对象其实就是将集合、数组等通过一些方法转换为Stream流对象。  
  在Java中，集合对象有对应的集合类，可以通过集合类提供的静态方法创建Stream流对象，而数组数据却没有对应的数组类，所以必须通过其他方法创建Stream流对象。针对不同的源数据，Java提供了多种创建Stream流对象的方式，分别如下：  
  （1）所有的Collections集合都可以使用stream()静态方法获取Stream流对象；  
  （2）Stream接口的of()静态方法可以获取基本类型包装类数组、引用类型数组和单个元素的Stream流对象；  
  （3）Arrays数组工具类的stream()静态方法也可以获取数组元素的Stream流对象。  
  接下来，通过一个案例来学习聚合操作中如何创建Stream流对象，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example32 {
 4		public static void main(String[] args) {
 5	          // 创建一个数组
 6			Integer[] array = { 9, 8, 3, 5, 2 };       
 7	          // 将数组转换为List集合
 8			List<Integer> list = Arrays.asList(array); 
 9			// 1、使用集合对象的stream()静态方法创建Stream流对象
 10			Stream<Integer> stream = list.stream();
 11			stream.forEach(i -> System.out.print(i+" "));
 12			System.out.println();
 13			// 2、使用Stream接口的of()静态方法创建Stream流对象
 14			Stream<Integer> stream2 = Stream.of(array);
 15			stream2.forEach(i -> System.out.print(i+" "));
 16			System.out.println();
 17			// 3、使用Arrays数组工具类的stream()静态方法创建Stream流对象
 18			Stream<Integer> stream3 = Arrays.stream(array);
 19			stream3.forEach(i -> System.out.print(i+" "));
 20		}
 21	}
```  
  运行结果如下图所示。
![alt](/article_img/lambda/4.jpg)
  上述示例代码中，先创建了一个数组和一个集合，然后通过三种方式实现了Stream流对象的创建，并通过Stream流对象的forEach()方法结合Lambda表达式完成了集合和数组中元素的遍历。  

**小提示：**  
  在JDK 8中，只针对单列集合Collections接口对象提供了stream()静态方法获取Stream流对象，并未对Map集合提供相关方法获取Stream流对象，所以想要用Map集合创建Stream流对象必须先通过Map集合的keySet()、values()、entrySet()等方法将Map集合转换为单列Set集合，然后再使用单列集合的stream()静态方法获取对应键、值集合的Stream流对象。

, 2018-12-02, null, 默认分类, JDK 8,聚合操作, true, null, 36, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20050, rs-50048} Result: [9, 虚拟化容器技术——Docker运行机制介绍,   Docker是一个开源的应用容器引擎，它基于go语言开发，并遵从Apache2.0开源协议。使用Docker可以让开发者封装他们的应用以及依赖包到一个可移植的容器中，然后发布到任意的Linux机器上，也可以实现虚拟化。Docker容器完全使用沙箱机制，相互之间不会有任何接口，这保证了容器之间的安全性。  

**1. Docker的引擎介绍**

  Docker Engine（Docker引擎）是Docker的核心部分，使用的是客户端-服务器（C/S）架构模式，其主要组成部分如下图所示。
![alt](/article_img/docker/1.png)
  从上图可以看出，Docker Engine中包含了三个核心组件（docker CLI、REST API和docker daemon），这三个组件的具体说明如下：  
  ①docker CLI（command line interface）：表示Docker命令行接口，开发者可以在命令行中使用Docker相关指令与Docker守护进程进行交互，从而管理诸如image（镜像）、container（容器）、network（网络）和data volumes（数据卷）等实体。  
  ②REST API：表示应用程序API接口，开发者通过该API接口可以与Docker的守护进程进行交互，从而指示后台进行相关操作。  
  ③docker daemon：表示Docker的服务端组件，他是Docker架构中运行在后台的一个守护进程，可以接收并处理来自命令行接口及API接口的指令，然后进行相应的后台操作。  
  对于开发者而言，既可以使用编写好的脚本文件通过REST API来实现与Docker进程交互，又可以直接使用Docker相关指令通过命令行接口来与Docker进程交互，而其他一些Docker应用则是通过底层的API和CLI进行交互的。

**2. Docker的架构介绍**

  了解了Docker内部引擎及作用后，我们还需要通过Docker的具体架构，来了解Docker的整个运行流程。接下来借助Docker官网的架构图来对Docker架构进行详细说明，如下图所示。
![alt](/article_img/docker/2.jpg)
  从图中可以看出，Docker架构主要包括Client、DOCKER_HOST和Register三部分，关于这三部分的具体说明如下。  
&emsp;&emsp;**（1）Client（客户端）**  
  Client即Docker客户端，也就是上一小节Docker Engine中介绍的docker CLI。开发者通过这个客户端使用Docker的相关指令与Docker守护进程进行交互，从而进行Docker镜像的创建、拉取和运行等操作。  
&emsp;&emsp;**（2）DOCKER_HOST（Docker主机）**  
  DOCKER_HOST即Docker内部引擎运行的主机，主要指Docker daemon（Docker守护进程）。可以通过Docker守护进程与客户端还有Docker的镜像仓库Registry进行交互，从而管理Images（镜像）和Containers（容器）等。  
&emsp;&emsp;**（3）Registry（注册中心）**  
  Registry即Docker注册中心，实质就是Docker镜像仓库，默认使用的是Docker官方远程注册中心Docker Hub，也可以使用开发者搭建的本地仓库。Registry中包含了大量的镜像，这些镜像可以是官网基础镜像，也可以是其他开发者上传的镜像。  
  我们在实际使用Docker时，除了会涉及到图中的三个主要部分外，还会涉及到很多Docker Objects（Docker对象），例如Images（镜像）、Containers（容器）、Networks（网络）、Volumes（数据卷）、Plugins（插件）等。其中常用的两个对象Image和Containers的说明如下。  
  ①Images（镜像）  
  Docker 镜像就是一个只读的模板，包含了一些创建Docker容器的操作指令。通常情况下，一个Docker镜像是基于另一个基础镜像创建的，并且新创建的镜像会额外包含一些功能配置。例如：开发者可以依赖于一个Ubuntu的基础镜像创建一个新镜像，并可以在新镜像中安装Apache等软件或其它应用程序。  
  ②Containers（容器）  
  Docker容器属于镜像的一个可运行实例（镜像与容器的关系其实与Java中的类与对象相似），开发者可以通过API接口或者CLI命令行接口来创建、运行、停止、移动、删除一个容器，也可以将一个容器连接到一个或多个网络中，将数据存储与容器进行关联。



, 2018-12-03, null, 默认分类, 虚拟化容器,Docker,运行机制, true, null, 26, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20050, rs-50048} Result: [10, Docker常用客户端指令介绍,   在使用Docker之前，首先会为对应的项目编写Dockerfile镜像构建文件，然后通过Docker的相关指令进行镜像构建，完成镜像的构建后，就可以使用这些项目镜像进行启动测试了。所以要想知道如何使用Docker来执行这些Dockerfile镜像构建文件，还需要学习Docker客户端的常用指令，本篇文章将对Docker客户端的常用指令进行详细讲解。  

**1.列出镜像**  
  通过docker images指令可以查看本地镜像列表中已有的镜像，具体使用方式如下。
```js
$ docker images
```  
  执行上述指令后，系统会将所有本地镜像都展示出来，如下图所示。
![alt](/article_img/docker/3.png)
  从图中可以看出，系统终端将本地镜像列表中的3个镜像分5列进行了展示，每一列的具体含义如下。  
  ●REPOSITORY：镜像名称。  
  ●TAG：镜像的参数，类似于版本号，默认是latest。  
  ●IMAGE ID：镜像ID，是唯一值。此处看到的是一个长度为12的字符串，实际上它是64位完整镜像ID的缩写形式。  
  ●CREATED：距今创建镜像的时间。  
  ●SIZE：镜像大小。    

**2.搜索镜像**  
  想知道在Docker Hub中包含了哪些镜像，除了可以登录Docker Hub，在官网中心进行查看外，还可以直接在Docker客户端进行查询。例如想要查询Ubuntu镜像，可以使用如下指令。
```js
$ docker search ubuntu
```  
  执行上述指令后，系统终端就会将搜索到的有关Ubuntu的镜像展示出来，如下图所示。
![alt](/article_img/docker/4.png)
  从图所示的结果可以看出，系统终端分5列将搜索到的Ubuntu相关镜像都列举出来了，这5列的具体含义如下。  
  ●NAME：表示镜像的名称，这里有两种格式的名称，其中不带有“/”的表示官方镜像，而带有“/”的表示其他用户的公开镜像。公开镜像“/”前面是用户在Docker Hub上的用户名（唯一），后面是对应的镜像名；官方镜像与用户镜像，除了从镜像名称上可以区分外，还可以通过第4列的OFFICIAL声明中看出（该列下内容为OK表示官方镜像）。  
  ●DESCRIPTION：表示镜像的描述，这里只显示了一小部分。  
  ●STARS：表示该镜像的收藏数，用户可以在Docker Hub上对镜像进行收藏，一般可以通过该数字反应出该镜像的受欢迎程度。  
  ●OFFICIAL：表示是否为官方镜像。  
  ●AUTOMATED：表示是否自动构建镜像。例如，用户可以将自己的Docker Hub绑定到如Github上，当代码提交更新后，可以自动构建镜像。   
 
**3.拉取镜像**  
  通过docker pull指令可以拉取仓库镜像到本地（默认都是拉取Docker Hub仓库镜像，也可以指定“IP+端口”拉取某个Docker机器上的私有仓库镜像），具体使用方式如下。
```js
$ docker pull ubuntu
```  
  执行上述指令后，Docker会自动从Docker Hub上下载最新版本的Ubuntu到本地，当然也可以使用以下指令拉取指定版本的镜像到本地，具体指令如下。
```js
$ docker pull ubuntu:14.04
```  
**4.构建镜像**  
  除了可以通过docker pull指令从仓库拉取镜像外，还可以通过docker build指令构建Docker镜像，通常情况下都是通过Dockerfile文件来构建镜像的。  
  这里假设linux系统home目录下/shitou/workspace/dockerspace文件夹中编写有对应的Dockerfile文件，则构建镜像直立示例如下所示。 
```js
$ docker build -t hellodocker3 /home/shitou/workspace/dockerspace/.
```
**5.删除镜像**  
  当本地存放过多不需要的镜像时，可以通过docker rmi指令将其删除。在删除镜像时，需要指定镜像名称或镜像ID。删除镜像的使用方式如下。
```js
$ docker rmi -f hellodocker2 hellodocker3
```  
  上述指令中，docker rmi表示删除镜像，-f表示进行强制删除，而hellodocker2和hellodocker3分别表示需要删除的镜像名称，这里同时删除两个镜像。除了根据名称删除镜像外，还也可以根据镜像ID来删除镜像，只是这里如果指定了删除ID为23c617a866d4的镜像后，会同时删除hellodocker、hellodocker2和hellodocker3三个镜像。  
  需要特别强调的是，在进行镜像删除操作时，如果是通过镜像ID进行镜像删除，那么由该镜像创建的容器必须提前删除或停止。另外，在通过镜像名称操作镜像时，如果出现镜像重名的情况，必须在镜像名称后面指定镜像标签tag参数来确保唯一性。

**6.创建并启动容器**  
  Docker镜像主要用于创建容器，可以使用docker run指令创建并启动容器，具体使用方式如下。
```js
$ docker run -d -p 5000:80 --name test hellodocker
```  
  上述创建并启动容器的指令略微复杂，具体分析如下。  
  ●docker run：表示创建并启动一个容器，而后面的hellodocker就表示要启动运行的镜像名称；  
  ●-d：表示容器启动时在后台运行；  
  ●-p 5000:80：表示将容器内暴露的80端口映射到宿主机指定的5000端口，也可以将-p 5000:80更改为-P来映射主机的随机端口（注意p字母的大小写）；  
  ●--name test：表示为创建后的容器指定名称为test，如果没有该参数配置，则生成的容器会设置一个随机名称。  
  docker run命令是Docker操作中较为复杂的一个，它可以携带多个参数和参数，我们可以通过docker run --help指令进行查看，其中有些参数如-e、-v和-w等都可以在Dockerfile文件中预先声明。 
 
**7.列出容器**  
  生成容器后，可以通过docker ps指令查看当前运行的所有容器，具体使用方式如下。
```js
$ docker ps
```  
  执行上述命令后，会将所有当前运行的容器都展示出来，具体如下图所示。
![alt](/article_img/docker/5.png)
  从图中可以看出，系统终端通过7列对当前的正在运行的一个容器进行了展示，图中每一列的具体含义如下。  
  ●CONTAINER ID：表示生成的容器ID；  
  ●IMAGE：表示生成该容器的镜像名称；  
  ●COMMAND：表示启动容器时运行的命令，Docker要求在启动容器时必须运行一个命令；  
  ●CREATED：表示容器创建的时间；  
  ●STATUS：表示容器运行状态，例如Up表示运行中，Exited表示已停止；  
  ●PORTS：表示容器内部暴露的端口映射到主机的端口；  
  ●NAMES：表示生成容器的名称，由Docker引擎自动生成，可以像上述示例中使用--name参数指定生成容器的名称。  
  另外，docker ps指令运行过程中可以指定多个参数，还可以通过docker ps --help指令对ps指令的其他信息进行查看。

**8.删除容器**  
  当不需要使用容器时，则可以使用docker rm指令删除已停止的容器，具体使用方式如下。
```js
$ docker rm f0c9a8b6e8c5
```  
  需要注意的是，上述指令只能删除已经停止运行的容器，而不能删除正在运行的容器。如果想要删除正在运行的容器，则需要添加-f参数强制删除，具体使用方式如下。
```js
$ docker rm -f f0c9a8b6e8c5
```  
  当需要删除的容器过多时，如果还一个个的删除就略显麻烦了，此时可以通过如下指令将全部容器删除。
```js
$ docker rm -f $(docker ps -aq)
```  
  上述指令中，首先会通过$(docker ps -aq)获取所有容器的ID，然后通过docker rm -f指令进行强制删除。如果开发者有自己特殊的删除需求，可以根据前面docker ps指令进行组装来获取需要删除的容器ID。  
  Docker提供的操作指令远不止这些，这里就不一一列举了，想要了解更多Docker的操作指令，可以通过docker --help指令进行查看。


, 2018-12-05, null, 默认分类, Docker,客户端指令, true, null, 21, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20050, rs-50048} Result: [11, Docker数据管理介绍,   当我们对容器进行相关操作时，产生的一系列数据都会存储在容器中，而Docker内部又是如果管理这些数据的呢？本篇文章将针对Docker数据管理的一些知识进行介绍。
  
**1. Docker数据存储机制**  
  使用Docker时，我们操作的都是镜像和由镜像生成的容器，所以想要更好的了解Docker内部的数据存储机制，就必须从镜像、容器与数据存储的关系出发。  
  Docker镜像是通过读取Dockerfile文件中的指令构建的，Dockerfile中的每条指令都会创建一个镜像层，并且每层都是只读的，这一系列的镜像层就构成了Docker镜像。接下来以一个Dockerfile文件为例进行说明，具体如下列代码示例所示。
```js
 1	FROM ubuntu:16.04
 2	COPY . /app
 3	RUN make /app
 4	CMD python /app/app.py
```  
   上述文件示例中的Dockerfile包含了4条指令，每条指令都会创建一个镜像层，其中每一层与前一层都有所不同，并且是层层叠加的。通过镜像构建容器时，会在镜像层上增加一个容器层（即可写层），所有对容器的更改都会写入容器层，这也是Docker默认的数据存储方式。  
  下面通过一个效果图进行说明，具体如下图所示。
![alt](/article_img/docker/6.png)
  从图中可以看出，Docker容器和镜像之间的主要区别是顶部的容器层，而所有对容器中数据的添加、修改等操作都会被存储在容器层中。当容器被删除时，容器层也会被删除，其中存储的数据会被一同删除，而下面的镜像层却保持不变。  
  由于所有的容器都是通过镜像构建的，所以每个容器都有各自的容器层，对于容器数据的更改就会保存在各自的容器层中。也就是说，由同一个镜像构建的多个容器，它们会拥有相同的底部镜像层，而拥有不同的容器层，多个容器可以访问相同的镜像层，并且有自己的独立数据状态。具体说明如下图所示。 
![alt](/article_img/docker/7.png)
  从图中可以看出，基于同一个镜像构建的多个容器可以共享该镜像层，但是多个容器想要共享相同的数据，就需要将这些数据存储到容器之外的地方，而这种方式就是下一节要提到的Docker volume数据外部挂载机制。  

**2. Docker数据存储方式**    
  在默认情况下，Docker中的数据都是存放在容器层的，但是这样存储数据却有较多的缺陷，具体表现如下。    
  ●当容器不再运行时，容器中的数据无法持久化保存，如果另一个进程需要这些数据，那么将很难从容器中获取数据；  
  ●容器层与正在运行的主机紧密耦合，不能轻易地移动数据；  
  ●容器层需要一个存储驱动程序来管理文件系统，存储驱动程序提供了一个使用Linux内核的联合文件系统，这种额外的抽象化降低了性能。  
  基于上述种种原因，多数情况下Docker数据管理都不会直接将数据写入容器层，而是使用另一种叫做Docker volume数据外部挂载的机制进行数据管理。  
  针对Docker volume数据外部挂载机制，Docker提供了三种不同的方式将数据从容器映射到Docker宿主机，他们分别为：volumes（数据卷）、bind mounts（绑定挂载）和tmpfs mounts（tmpfs挂载）。这三种数据管理方式的具体选择，需要结合实际情况进行考虑，其中的volumes数据卷是最常用也是官方推荐的数据管理方式。无论选择使用哪种数据管理方式，数据在容器内看起来都一样的，而在容器外则会被被挂载到文件系统中的某个目录或文件中。    
  下面通过一张图来展示数据卷、绑定挂载和tmpfs挂载之间的差异，如下图所示。  
![alt](/article_img/docker/8.png)
  从图中可以看出，Docker提供的三种数据管理方式略有不同，具体分析如下。  
  ●volumes：存储在主机文件系统中（在Linux系统下是存在于/var/lib/Docker/volumes/目录），并由Docker管理，非Docker进程无法修改文件系统的这个部分。  
  ●bind mounts：可以存储在主机系统的任意位置，甚至可能是重要的系统文件或目录，在Docker主机或容器上的非Docker进程可以对他们进行任意修改。  
  ●tmpfs mounts：只存储在主机系统的内存中，并没有写入到主机的文件系统中。


, 2018-12-07, 2021-05-19, 默认分类, Docker,数据管理, true, null, 19, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20050, rs-50048} Result: [6, JDK 8——Lambda表达式介绍,   Lambda表达式是JDK 8中一个重要的新特性，它使用一个清晰简洁的表达式来表达一个接口，同时Lambda表达式也简化了对集合以及数组数据的遍历、过滤和提取等操作。下面，本篇文章就对Lambda表达式进行简要介绍，并进行演示说明。

**1. Lambda表达式入门**  

  匿名内部类存在的一个问题是，如果匿名内部类的实现非常简单，例如只包含一个抽象方法的接口，那么匿名内部类的语法仍然显得比较冗余。为此，JDK 8中新增了一个特性Lambda表达式，这种表达式只针对有一个抽象方法的接口实现，以简洁的表达式形式实现接口功能来作为方法参数。  
  一个Lambda表达式由三个部分组成，分别为参数列表、“->”和表达式主体，其语法格式如下：
```js
 ([数据类型 参数名,数据类型 参数名,...]) -> {表达式主体}
```  
  从上述语法格式上看，Lambda表达式的书写非常简单，下面针对Lambda表达式的组成部分进行简单介绍，具体如下：  
  （1）([数据类型 参数名,数据类型 参数名,...])：用来向表达式主体传递接口方法需要的参数，多个参数名中间必须用英文逗号“,”进行分隔；在编写Lambda表达式时，可以省略参数的数据类型，后面的表达式主体会自动进行校对和匹配；同时，如果只有一个参数，则可以省略括号“()”。  
  （2）->：表示Lambda表达式箭牌，用来指定参数数据指向，不能省略，且必须用英文横线和大于号书写。  
  （3）{表达式主体}：由单个表达式或语句块组成的主体，本质就是接口中抽象方法的具体实现，如果表达式主体只有一条语句，那么可以省略包含主体的大括号；另外，在Lambda表达式主体中允许有返回值，当只有一条return语句时，也可以省略return关键字。  
  了解了Lambda表达式的语法后，接下来编写一个示例文件对Lambda表达式的基本使用进行介绍，具体代码如下所示。
```js
 1	// 定义动物类接口
 2	interface Animal { 
 3		void shout(); // 定义方法shout()
 4	}
 5	public class Example22 {
 6		public static void main(String[] args) {
 7	       String name = "小花"; 
 8	       // 1、匿名内部类作为参数传递给animalShout()方法
 9		  animalShout(new Animal() { 
 10				 public void shout() { 
 11				    System.out.println("匿名内部类输出："+name+"喵喵...");
 12				}
 13		  });
 14		  // 2、使用Lambda表达式作为参数传递给animalShout()方法
 15	       animalShout(()-> System.out.println("Lambda表达式输出："
 16	                                                   +name+"喵喵..."));
 17		}
 18	    // 创建一个animalShout()静态方法，接收接口类型的参数
 19		public static void animalShout(Animal an) {
 20			an.shout();  
 21		}
 22	}
```  
  运行结果下图所示。
![alt](/article_img/lambda/1.jpg)
  上述代码示例中，先定义了只有一个抽象方法的接口Animal，然后分别使用匿名内部类和Lambda表达式的方式实现了接口方法。从图中可以看出，使用匿名内部类和Lambda表达式都能实现接口中方法，但很显然使用Lambda表达式更加简洁和清晰。, 2018-11-27, null, 默认分类, 2018,Lambda表达式, true, null, 18, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20050, rs-50048} Result: [7, 函数式接口, &emsp;&emsp;虽然Lambda表达式可以实现匿名内部类的功能，但在使用时却有一个局限，即接口中有且只有一个抽象方法时才能使用Lamdba表达式代替匿名内部类。这是因为Lamdba表达式是基于函数式接口实现的，所谓函数式接口是指有且仅有一个抽象方法的接口，Lambda表达式就是Java中函数式编程的体现，只有确保接口中有且仅有一个抽象方法，Lambda表达式才能顺利地推导出所实现的这个接口中的方法。  
&emsp;&emsp;在JDK 8中，专门为函数式接口引入了一个@FunctionalInterface注解，该注解只是显示的标注了接口是一个函数式接口，并强制编辑器进行更严格的检查，确保该接口是函数式接口，如果不是函数式接口，那么编译器就会报错，而对程序运行并没有实质上的影响。  
&emsp;&emsp;接下来通过一个案例来演示函数式接口的定义与使用，示例代码如下所示。
```js
 1	// 定义无参、无返回值的函数式接口
 2	@FunctionalInterface
 3	interface Animal {
 4		void shout();
 5	}
 6	// 定义有参、有返回值的函数式接口
 7	interface Calculate {
 8		int sum(int a, int b);
 9	}
 10	public class Example23 {
 11		public static void main(String[] args) {
 12		   // 分别两个函数式接口进行测试
 13		   animalShout(() -> System.out.println("无参、无返回值的函数式接口调用"));
 14		   showSum(10, 20, (x, y) -> x + y);
 15		}
 16		// 创建一个动物叫的方法，并传入接口对象Animal作为参数
 17		private static void animalShout(Animal animal) {
 18			animal.shout();
 19		}
 20		// 创建一个求和的方法，并传入两个int类型以及接口Calculate类型的参数
 21		private static void showSum(int x, int y, Calculate calculate) {
 22		   System.out.println(x + "+" + y + "的和为：" + calculate.sum(x, y));
 23		}
 24	}
```  
&emsp;&emsp;运行结果如下图所示。

![alt](/article_img/lambda/2.jpg)
&emsp;&emsp;上述代码示例中，先定义了两个函数式接口Animal和Calculate，然后在测试类中分别编写了两个静态方法，并将这两个函数式接口以参数的形式传入，最后在main()方法中分别调用这两个静态方法，并将所需要的函数式接口参数以Lambda表达式的形式传入。从图中可以看出，程序中函数式接口的定义和使用完全正确。
, 2018-12-01, null, 默认分类, 接口,函数式接口, true, null, 12, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20050, rs-50048} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20050, rs-50048} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20050, rs-50048} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20050, rs-50048} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20050, rs-50048} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20050} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20051} created. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20051} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20051} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20051} executed. 0.5777 millis. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20051, rs-50049} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20051, rs-50049} Header: [count(0)]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20051, rs-50049} Result: [12]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20051, rs-50049} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20051} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20052} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20052} Parameters : [5]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20052} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20052} executed. 0.4988 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20052, rs-50050} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20052, rs-50050} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20052, rs-50050} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20052, rs-50050} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20052, rs-50050} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20052, rs-50050} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20052, rs-50050} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20052, rs-50050} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20052} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} connected
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} created. select username,password,valid from t_user where username = ?
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} Parameters : [11]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} Types : [VARCHAR]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000, rs-50000} query executed. 10.799 millis. select username,password,valid from t_user where username = ?
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Header: [username, password, valid]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} created. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} executed. 4.5826 millis. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Header: [count(0)]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [12]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} Parameters : [5]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} executed. 1.2023 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20003} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20003} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20003} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20003} executed. 0.7362 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20003, rs-50003} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20003, rs-50003} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20003, rs-50003} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20003, rs-50003} Result: [12, Spring Boot 2 权威发布,   如果这两天登录 [https://start.spring.io/ ](https://start.spring.io/ )就会发现，Spring Boot 默认版本已经升到了 2.1.0。这是因为 Spring Boot 刚刚发布了 2.1.0 版本，我们来看下 Spring Boot 2 发布以来第一个子版本都发布了哪些内容？  

**2.1 中的新特性**     
  ●将spring-boot-starter-oauth2-oidc-client重命名为spring-boot-starter-oauth2-client命名更简洁  
  ●添加 OAuth2 资源服务 starter，OAuth2 一个用于认证的组件  
  ●支持 ConditionalOnBean 和 ConditionalOnMissingBean 下的参数化容器  
  ●自动配置 applicationTaskExecutor bean 的延迟加载来避免不必要的日志记录  
  ●将 DatabaseDriver＃SAP 重命名为 DatabaseDriver  
  ●跳过重启器不仅适用于 JUnit4，也适用于 JUnit5  
  ●在 Jest HealthIndicator 中使用集群端点  
  ●当 DevTools 禁用重启时添加日志输出  
  ●添加注解：@ConditionalOnMissingServletFilter提高 Servlet Filters 的自动装配。
  
**2.1 中的组件升级**  
  ●升级 Hibernate 5.3，Hibernate 的支持升级到了 5.3  
  ●升级 Tomcat 9 ，支持最新的 tomcat 9  
  ●支持 Java 11，Java 现在更新越来越快，Spring 快赶不上了    
  ●升级 Thymeleaf Extras Springsecurity 到 3.0.4.RELEASE ，thymeleaf-extras-springsecurity 是 Thymeleaf 提供集成 Spring Security 的组件  
  ●升级 Joda Time 2.10.1，Joda-Time， 面向 Java 应用程序的日期/时间库的替代选择，Joda-Time 令时间和日期值变得易于管理、操作和理解。  
  ●升级 Lettuce 5.1.2.RELEASE ，Lettuce 前面说过，传说中 Redis 最快的客户端。  
  ●升级 Reactor Californium-SR2 ，Californium 是物联网云服务的 Java COAP 实现。因此，它更专注的是可扩展性和可用性而不是像嵌入式设备那样关注资源效率。不过，Californium 也适合嵌入式的 JVM。  
  ●升级 Maven Failsafe Plugin 2.22.1 ，Maven 中的测试插件。  
  ●升级 Flyway 5.2.1 ， Flyway是一款开源的数据库版本管理工具  
  ●升级 Aspectj 1.9.2 ，AspectJ 是 Java 中流行的 AOP（Aspect-oriented Programming）编程扩展框架，是 Eclipse 托管给 Apache 基金会的一个开源项目。  
  ●升级 Mysql 8.0.13 ，Mysql 支持到 8。  
  ●...  
  更多的详细内容可以参考这里：[Spring Boot 2.1 Release Notes](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.1-Release-Notes)
, 2018-12-12, 2021-05-21, 默认分类, Spring Boot 2, true, null, 62, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20003, rs-50003} Result: [8, JDK 8——聚合操作, &emsp;&emsp;在Java8版本中，JDK包含许多聚合操作（如平均值，总和，最小，最大，和计数），返回一个计算流stream的聚合结果。这些聚合操作被称为聚合操作。JDK除返回单个值的聚合操作外，还有很多聚合操作返回一个collection集合实例。很多的reduce操作执行特定的任务，如求平均值或按类别分组元素。  

**1. 聚合操作简介**

  在开发中，多数情况下会涉及到对集合、数组中元素的操作，在JDK 8之前都是通过普通的循环遍历出每一个元素，然后还会穿插一些if条件语句选择性的对元素进行查找、过滤、修改等操作，这种原始的操作方法虽然可行，但是代码量较大并且执行效率较低。  
  为此，JDK 8中新增了一个Stream接口，该接口可以将集合、数组的中的元素转换为Stream流的形式，并结合Lambda表达式的优势来进一步简化集合、数组中元素的查找、过滤、转换等操作，这一新功能就是JDK 8中的聚合操作。  
  在程序中，使用聚合操作没有绝对的语法规范，根据实际操作流程，主要可以分为以下3个步骤：  
  （1）将原始集合或者数组对象转换为Stream流对象；  
  （2）对Stream流对象中的元素进行一系列的过滤、查找等中间操作（Intermediate Operations），然后仍然返回一个Stream流对象；  
  （3）对Stream流进行遍历、统计、收集等终结操作（Terminal Operation），获取想要的结果。  
  接下来，就根据上面聚合操作的3个步骤，通过一个案例来演示聚合操作的基本用法，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example31 {
 4		public static void main(String[] args) {
 5	          // 创建一个List集合对象
 6			List<String> list = new ArrayList<>(); 
 7			list.add("张三");
 8			list.add("李四");
 9			list.add("张小明");
 10			list.add("张阳");
 11			// 1、创建一个Stream流对象
 12			Stream<String> stream = list.stream();
 13			// 2、对Stream流中的元素分别进行过滤、截取操作
 14		       Stream<String> stream2 = stream.filter(i -> i.startsWith("张"));
 15			Stream<String> stream3 = stream2.limit(2);
 16			// 3、对Stream流中的元素进行终结操作，进行遍历输出
 17			stream3.forEach(j -> System.out.println(j));
 18			System.out.println("=======");
 19	         // 通过链式表达式的形式完成聚合操作
 20			list.stream().filter(i -> i.startsWith("张"))
 21						 .limit(2)
 22						 .forEach(j -> System.out.println(j));
 23		}
 24	}
``` 
   运行结果如下图所示。
![alt](/article_img/lambda/3.jpg)
  上述示例代码中，先创建了一个List集合，然后根据聚合操作的3个步骤实现了集合对象的聚合操作，对集合中的元素使用Stream流的形式进行过滤（filter）、截取（limit），并进行遍历输出。其中第12~17行代码分步骤详细展示了聚合操作，而第20~22行代码是使用了链式表达式（调用有返回值的方法时不获取返回值而是直接再调用另一个方法）实现了聚合操作，该表达式的语法格式更简洁、高效，这种链式调用也被称为操作管道流。

**2. 创建Stream流对象**  
  在上一小节中，介绍了聚合操作的主要使用步骤，其中首要解决的问题就是创建Stream流对象。聚合操作针对的就是可迭代数据进行的操作，如集合、数组等，所以创建Stream流对象其实就是将集合、数组等通过一些方法转换为Stream流对象。  
  在Java中，集合对象有对应的集合类，可以通过集合类提供的静态方法创建Stream流对象，而数组数据却没有对应的数组类，所以必须通过其他方法创建Stream流对象。针对不同的源数据，Java提供了多种创建Stream流对象的方式，分别如下：  
  （1）所有的Collections集合都可以使用stream()静态方法获取Stream流对象；  
  （2）Stream接口的of()静态方法可以获取基本类型包装类数组、引用类型数组和单个元素的Stream流对象；  
  （3）Arrays数组工具类的stream()静态方法也可以获取数组元素的Stream流对象。  
  接下来，通过一个案例来学习聚合操作中如何创建Stream流对象，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example32 {
 4		public static void main(String[] args) {
 5	          // 创建一个数组
 6			Integer[] array = { 9, 8, 3, 5, 2 };       
 7	          // 将数组转换为List集合
 8			List<Integer> list = Arrays.asList(array); 
 9			// 1、使用集合对象的stream()静态方法创建Stream流对象
 10			Stream<Integer> stream = list.stream();
 11			stream.forEach(i -> System.out.print(i+" "));
 12			System.out.println();
 13			// 2、使用Stream接口的of()静态方法创建Stream流对象
 14			Stream<Integer> stream2 = Stream.of(array);
 15			stream2.forEach(i -> System.out.print(i+" "));
 16			System.out.println();
 17			// 3、使用Arrays数组工具类的stream()静态方法创建Stream流对象
 18			Stream<Integer> stream3 = Arrays.stream(array);
 19			stream3.forEach(i -> System.out.print(i+" "));
 20		}
 21	}
```  
  运行结果如下图所示。
![alt](/article_img/lambda/4.jpg)
  上述示例代码中，先创建了一个数组和一个集合，然后通过三种方式实现了Stream流对象的创建，并通过Stream流对象的forEach()方法结合Lambda表达式完成了集合和数组中元素的遍历。  

**小提示：**  
  在JDK 8中，只针对单列集合Collections接口对象提供了stream()静态方法获取Stream流对象，并未对Map集合提供相关方法获取Stream流对象，所以想要用Map集合创建Stream流对象必须先通过Map集合的keySet()、values()、entrySet()等方法将Map集合转换为单列Set集合，然后再使用单列集合的stream()静态方法获取对应键、值集合的Stream流对象。

, 2018-12-02, null, 默认分类, JDK 8,聚合操作, true, null, 36, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20003, rs-50003} Result: [9, 虚拟化容器技术——Docker运行机制介绍,   Docker是一个开源的应用容器引擎，它基于go语言开发，并遵从Apache2.0开源协议。使用Docker可以让开发者封装他们的应用以及依赖包到一个可移植的容器中，然后发布到任意的Linux机器上，也可以实现虚拟化。Docker容器完全使用沙箱机制，相互之间不会有任何接口，这保证了容器之间的安全性。  

**1. Docker的引擎介绍**

  Docker Engine（Docker引擎）是Docker的核心部分，使用的是客户端-服务器（C/S）架构模式，其主要组成部分如下图所示。
![alt](/article_img/docker/1.png)
  从上图可以看出，Docker Engine中包含了三个核心组件（docker CLI、REST API和docker daemon），这三个组件的具体说明如下：  
  ①docker CLI（command line interface）：表示Docker命令行接口，开发者可以在命令行中使用Docker相关指令与Docker守护进程进行交互，从而管理诸如image（镜像）、container（容器）、network（网络）和data volumes（数据卷）等实体。  
  ②REST API：表示应用程序API接口，开发者通过该API接口可以与Docker的守护进程进行交互，从而指示后台进行相关操作。  
  ③docker daemon：表示Docker的服务端组件，他是Docker架构中运行在后台的一个守护进程，可以接收并处理来自命令行接口及API接口的指令，然后进行相应的后台操作。  
  对于开发者而言，既可以使用编写好的脚本文件通过REST API来实现与Docker进程交互，又可以直接使用Docker相关指令通过命令行接口来与Docker进程交互，而其他一些Docker应用则是通过底层的API和CLI进行交互的。

**2. Docker的架构介绍**

  了解了Docker内部引擎及作用后，我们还需要通过Docker的具体架构，来了解Docker的整个运行流程。接下来借助Docker官网的架构图来对Docker架构进行详细说明，如下图所示。
![alt](/article_img/docker/2.jpg)
  从图中可以看出，Docker架构主要包括Client、DOCKER_HOST和Register三部分，关于这三部分的具体说明如下。  
&emsp;&emsp;**（1）Client（客户端）**  
  Client即Docker客户端，也就是上一小节Docker Engine中介绍的docker CLI。开发者通过这个客户端使用Docker的相关指令与Docker守护进程进行交互，从而进行Docker镜像的创建、拉取和运行等操作。  
&emsp;&emsp;**（2）DOCKER_HOST（Docker主机）**  
  DOCKER_HOST即Docker内部引擎运行的主机，主要指Docker daemon（Docker守护进程）。可以通过Docker守护进程与客户端还有Docker的镜像仓库Registry进行交互，从而管理Images（镜像）和Containers（容器）等。  
&emsp;&emsp;**（3）Registry（注册中心）**  
  Registry即Docker注册中心，实质就是Docker镜像仓库，默认使用的是Docker官方远程注册中心Docker Hub，也可以使用开发者搭建的本地仓库。Registry中包含了大量的镜像，这些镜像可以是官网基础镜像，也可以是其他开发者上传的镜像。  
  我们在实际使用Docker时，除了会涉及到图中的三个主要部分外，还会涉及到很多Docker Objects（Docker对象），例如Images（镜像）、Containers（容器）、Networks（网络）、Volumes（数据卷）、Plugins（插件）等。其中常用的两个对象Image和Containers的说明如下。  
  ①Images（镜像）  
  Docker 镜像就是一个只读的模板，包含了一些创建Docker容器的操作指令。通常情况下，一个Docker镜像是基于另一个基础镜像创建的，并且新创建的镜像会额外包含一些功能配置。例如：开发者可以依赖于一个Ubuntu的基础镜像创建一个新镜像，并可以在新镜像中安装Apache等软件或其它应用程序。  
  ②Containers（容器）  
  Docker容器属于镜像的一个可运行实例（镜像与容器的关系其实与Java中的类与对象相似），开发者可以通过API接口或者CLI命令行接口来创建、运行、停止、移动、删除一个容器，也可以将一个容器连接到一个或多个网络中，将数据存储与容器进行关联。



, 2018-12-03, null, 默认分类, 虚拟化容器,Docker,运行机制, true, null, 26, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20003, rs-50003} Result: [10, Docker常用客户端指令介绍,   在使用Docker之前，首先会为对应的项目编写Dockerfile镜像构建文件，然后通过Docker的相关指令进行镜像构建，完成镜像的构建后，就可以使用这些项目镜像进行启动测试了。所以要想知道如何使用Docker来执行这些Dockerfile镜像构建文件，还需要学习Docker客户端的常用指令，本篇文章将对Docker客户端的常用指令进行详细讲解。  

**1.列出镜像**  
  通过docker images指令可以查看本地镜像列表中已有的镜像，具体使用方式如下。
```js
$ docker images
```  
  执行上述指令后，系统会将所有本地镜像都展示出来，如下图所示。
![alt](/article_img/docker/3.png)
  从图中可以看出，系统终端将本地镜像列表中的3个镜像分5列进行了展示，每一列的具体含义如下。  
  ●REPOSITORY：镜像名称。  
  ●TAG：镜像的参数，类似于版本号，默认是latest。  
  ●IMAGE ID：镜像ID，是唯一值。此处看到的是一个长度为12的字符串，实际上它是64位完整镜像ID的缩写形式。  
  ●CREATED：距今创建镜像的时间。  
  ●SIZE：镜像大小。    

**2.搜索镜像**  
  想知道在Docker Hub中包含了哪些镜像，除了可以登录Docker Hub，在官网中心进行查看外，还可以直接在Docker客户端进行查询。例如想要查询Ubuntu镜像，可以使用如下指令。
```js
$ docker search ubuntu
```  
  执行上述指令后，系统终端就会将搜索到的有关Ubuntu的镜像展示出来，如下图所示。
![alt](/article_img/docker/4.png)
  从图所示的结果可以看出，系统终端分5列将搜索到的Ubuntu相关镜像都列举出来了，这5列的具体含义如下。  
  ●NAME：表示镜像的名称，这里有两种格式的名称，其中不带有“/”的表示官方镜像，而带有“/”的表示其他用户的公开镜像。公开镜像“/”前面是用户在Docker Hub上的用户名（唯一），后面是对应的镜像名；官方镜像与用户镜像，除了从镜像名称上可以区分外，还可以通过第4列的OFFICIAL声明中看出（该列下内容为OK表示官方镜像）。  
  ●DESCRIPTION：表示镜像的描述，这里只显示了一小部分。  
  ●STARS：表示该镜像的收藏数，用户可以在Docker Hub上对镜像进行收藏，一般可以通过该数字反应出该镜像的受欢迎程度。  
  ●OFFICIAL：表示是否为官方镜像。  
  ●AUTOMATED：表示是否自动构建镜像。例如，用户可以将自己的Docker Hub绑定到如Github上，当代码提交更新后，可以自动构建镜像。   
 
**3.拉取镜像**  
  通过docker pull指令可以拉取仓库镜像到本地（默认都是拉取Docker Hub仓库镜像，也可以指定“IP+端口”拉取某个Docker机器上的私有仓库镜像），具体使用方式如下。
```js
$ docker pull ubuntu
```  
  执行上述指令后，Docker会自动从Docker Hub上下载最新版本的Ubuntu到本地，当然也可以使用以下指令拉取指定版本的镜像到本地，具体指令如下。
```js
$ docker pull ubuntu:14.04
```  
**4.构建镜像**  
  除了可以通过docker pull指令从仓库拉取镜像外，还可以通过docker build指令构建Docker镜像，通常情况下都是通过Dockerfile文件来构建镜像的。  
  这里假设linux系统home目录下/shitou/workspace/dockerspace文件夹中编写有对应的Dockerfile文件，则构建镜像直立示例如下所示。 
```js
$ docker build -t hellodocker3 /home/shitou/workspace/dockerspace/.
```
**5.删除镜像**  
  当本地存放过多不需要的镜像时，可以通过docker rmi指令将其删除。在删除镜像时，需要指定镜像名称或镜像ID。删除镜像的使用方式如下。
```js
$ docker rmi -f hellodocker2 hellodocker3
```  
  上述指令中，docker rmi表示删除镜像，-f表示进行强制删除，而hellodocker2和hellodocker3分别表示需要删除的镜像名称，这里同时删除两个镜像。除了根据名称删除镜像外，还也可以根据镜像ID来删除镜像，只是这里如果指定了删除ID为23c617a866d4的镜像后，会同时删除hellodocker、hellodocker2和hellodocker3三个镜像。  
  需要特别强调的是，在进行镜像删除操作时，如果是通过镜像ID进行镜像删除，那么由该镜像创建的容器必须提前删除或停止。另外，在通过镜像名称操作镜像时，如果出现镜像重名的情况，必须在镜像名称后面指定镜像标签tag参数来确保唯一性。

**6.创建并启动容器**  
  Docker镜像主要用于创建容器，可以使用docker run指令创建并启动容器，具体使用方式如下。
```js
$ docker run -d -p 5000:80 --name test hellodocker
```  
  上述创建并启动容器的指令略微复杂，具体分析如下。  
  ●docker run：表示创建并启动一个容器，而后面的hellodocker就表示要启动运行的镜像名称；  
  ●-d：表示容器启动时在后台运行；  
  ●-p 5000:80：表示将容器内暴露的80端口映射到宿主机指定的5000端口，也可以将-p 5000:80更改为-P来映射主机的随机端口（注意p字母的大小写）；  
  ●--name test：表示为创建后的容器指定名称为test，如果没有该参数配置，则生成的容器会设置一个随机名称。  
  docker run命令是Docker操作中较为复杂的一个，它可以携带多个参数和参数，我们可以通过docker run --help指令进行查看，其中有些参数如-e、-v和-w等都可以在Dockerfile文件中预先声明。 
 
**7.列出容器**  
  生成容器后，可以通过docker ps指令查看当前运行的所有容器，具体使用方式如下。
```js
$ docker ps
```  
  执行上述命令后，会将所有当前运行的容器都展示出来，具体如下图所示。
![alt](/article_img/docker/5.png)
  从图中可以看出，系统终端通过7列对当前的正在运行的一个容器进行了展示，图中每一列的具体含义如下。  
  ●CONTAINER ID：表示生成的容器ID；  
  ●IMAGE：表示生成该容器的镜像名称；  
  ●COMMAND：表示启动容器时运行的命令，Docker要求在启动容器时必须运行一个命令；  
  ●CREATED：表示容器创建的时间；  
  ●STATUS：表示容器运行状态，例如Up表示运行中，Exited表示已停止；  
  ●PORTS：表示容器内部暴露的端口映射到主机的端口；  
  ●NAMES：表示生成容器的名称，由Docker引擎自动生成，可以像上述示例中使用--name参数指定生成容器的名称。  
  另外，docker ps指令运行过程中可以指定多个参数，还可以通过docker ps --help指令对ps指令的其他信息进行查看。

**8.删除容器**  
  当不需要使用容器时，则可以使用docker rm指令删除已停止的容器，具体使用方式如下。
```js
$ docker rm f0c9a8b6e8c5
```  
  需要注意的是，上述指令只能删除已经停止运行的容器，而不能删除正在运行的容器。如果想要删除正在运行的容器，则需要添加-f参数强制删除，具体使用方式如下。
```js
$ docker rm -f f0c9a8b6e8c5
```  
  当需要删除的容器过多时，如果还一个个的删除就略显麻烦了，此时可以通过如下指令将全部容器删除。
```js
$ docker rm -f $(docker ps -aq)
```  
  上述指令中，首先会通过$(docker ps -aq)获取所有容器的ID，然后通过docker rm -f指令进行强制删除。如果开发者有自己特殊的删除需求，可以根据前面docker ps指令进行组装来获取需要删除的容器ID。  
  Docker提供的操作指令远不止这些，这里就不一一列举了，想要了解更多Docker的操作指令，可以通过docker --help指令进行查看。


, 2018-12-05, null, 默认分类, Docker,客户端指令, true, null, 21, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20003, rs-50003} Result: [11, Docker数据管理介绍,   当我们对容器进行相关操作时，产生的一系列数据都会存储在容器中，而Docker内部又是如果管理这些数据的呢？本篇文章将针对Docker数据管理的一些知识进行介绍。
  
**1. Docker数据存储机制**  
  使用Docker时，我们操作的都是镜像和由镜像生成的容器，所以想要更好的了解Docker内部的数据存储机制，就必须从镜像、容器与数据存储的关系出发。  
  Docker镜像是通过读取Dockerfile文件中的指令构建的，Dockerfile中的每条指令都会创建一个镜像层，并且每层都是只读的，这一系列的镜像层就构成了Docker镜像。接下来以一个Dockerfile文件为例进行说明，具体如下列代码示例所示。
```js
 1	FROM ubuntu:16.04
 2	COPY . /app
 3	RUN make /app
 4	CMD python /app/app.py
```  
   上述文件示例中的Dockerfile包含了4条指令，每条指令都会创建一个镜像层，其中每一层与前一层都有所不同，并且是层层叠加的。通过镜像构建容器时，会在镜像层上增加一个容器层（即可写层），所有对容器的更改都会写入容器层，这也是Docker默认的数据存储方式。  
  下面通过一个效果图进行说明，具体如下图所示。
![alt](/article_img/docker/6.png)
  从图中可以看出，Docker容器和镜像之间的主要区别是顶部的容器层，而所有对容器中数据的添加、修改等操作都会被存储在容器层中。当容器被删除时，容器层也会被删除，其中存储的数据会被一同删除，而下面的镜像层却保持不变。  
  由于所有的容器都是通过镜像构建的，所以每个容器都有各自的容器层，对于容器数据的更改就会保存在各自的容器层中。也就是说，由同一个镜像构建的多个容器，它们会拥有相同的底部镜像层，而拥有不同的容器层，多个容器可以访问相同的镜像层，并且有自己的独立数据状态。具体说明如下图所示。 
![alt](/article_img/docker/7.png)
  从图中可以看出，基于同一个镜像构建的多个容器可以共享该镜像层，但是多个容器想要共享相同的数据，就需要将这些数据存储到容器之外的地方，而这种方式就是下一节要提到的Docker volume数据外部挂载机制。  

**2. Docker数据存储方式**    
  在默认情况下，Docker中的数据都是存放在容器层的，但是这样存储数据却有较多的缺陷，具体表现如下。    
  ●当容器不再运行时，容器中的数据无法持久化保存，如果另一个进程需要这些数据，那么将很难从容器中获取数据；  
  ●容器层与正在运行的主机紧密耦合，不能轻易地移动数据；  
  ●容器层需要一个存储驱动程序来管理文件系统，存储驱动程序提供了一个使用Linux内核的联合文件系统，这种额外的抽象化降低了性能。  
  基于上述种种原因，多数情况下Docker数据管理都不会直接将数据写入容器层，而是使用另一种叫做Docker volume数据外部挂载的机制进行数据管理。  
  针对Docker volume数据外部挂载机制，Docker提供了三种不同的方式将数据从容器映射到Docker宿主机，他们分别为：volumes（数据卷）、bind mounts（绑定挂载）和tmpfs mounts（tmpfs挂载）。这三种数据管理方式的具体选择，需要结合实际情况进行考虑，其中的volumes数据卷是最常用也是官方推荐的数据管理方式。无论选择使用哪种数据管理方式，数据在容器内看起来都一样的，而在容器外则会被被挂载到文件系统中的某个目录或文件中。    
  下面通过一张图来展示数据卷、绑定挂载和tmpfs挂载之间的差异，如下图所示。  
![alt](/article_img/docker/8.png)
  从图中可以看出，Docker提供的三种数据管理方式略有不同，具体分析如下。  
  ●volumes：存储在主机文件系统中（在Linux系统下是存在于/var/lib/Docker/volumes/目录），并由Docker管理，非Docker进程无法修改文件系统的这个部分。  
  ●bind mounts：可以存储在主机系统的任意位置，甚至可能是重要的系统文件或目录，在Docker主机或容器上的非Docker进程可以对他们进行任意修改。  
  ●tmpfs mounts：只存储在主机系统的内存中，并没有写入到主机的文件系统中。


, 2018-12-07, 2021-05-19, 默认分类, Docker,数据管理, true, null, 19, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20003, rs-50003} Result: [6, JDK 8——Lambda表达式介绍,   Lambda表达式是JDK 8中一个重要的新特性，它使用一个清晰简洁的表达式来表达一个接口，同时Lambda表达式也简化了对集合以及数组数据的遍历、过滤和提取等操作。下面，本篇文章就对Lambda表达式进行简要介绍，并进行演示说明。

**1. Lambda表达式入门**  

  匿名内部类存在的一个问题是，如果匿名内部类的实现非常简单，例如只包含一个抽象方法的接口，那么匿名内部类的语法仍然显得比较冗余。为此，JDK 8中新增了一个特性Lambda表达式，这种表达式只针对有一个抽象方法的接口实现，以简洁的表达式形式实现接口功能来作为方法参数。  
  一个Lambda表达式由三个部分组成，分别为参数列表、“->”和表达式主体，其语法格式如下：
```js
 ([数据类型 参数名,数据类型 参数名,...]) -> {表达式主体}
```  
  从上述语法格式上看，Lambda表达式的书写非常简单，下面针对Lambda表达式的组成部分进行简单介绍，具体如下：  
  （1）([数据类型 参数名,数据类型 参数名,...])：用来向表达式主体传递接口方法需要的参数，多个参数名中间必须用英文逗号“,”进行分隔；在编写Lambda表达式时，可以省略参数的数据类型，后面的表达式主体会自动进行校对和匹配；同时，如果只有一个参数，则可以省略括号“()”。  
  （2）->：表示Lambda表达式箭牌，用来指定参数数据指向，不能省略，且必须用英文横线和大于号书写。  
  （3）{表达式主体}：由单个表达式或语句块组成的主体，本质就是接口中抽象方法的具体实现，如果表达式主体只有一条语句，那么可以省略包含主体的大括号；另外，在Lambda表达式主体中允许有返回值，当只有一条return语句时，也可以省略return关键字。  
  了解了Lambda表达式的语法后，接下来编写一个示例文件对Lambda表达式的基本使用进行介绍，具体代码如下所示。
```js
 1	// 定义动物类接口
 2	interface Animal { 
 3		void shout(); // 定义方法shout()
 4	}
 5	public class Example22 {
 6		public static void main(String[] args) {
 7	       String name = "小花"; 
 8	       // 1、匿名内部类作为参数传递给animalShout()方法
 9		  animalShout(new Animal() { 
 10				 public void shout() { 
 11				    System.out.println("匿名内部类输出："+name+"喵喵...");
 12				}
 13		  });
 14		  // 2、使用Lambda表达式作为参数传递给animalShout()方法
 15	       animalShout(()-> System.out.println("Lambda表达式输出："
 16	                                                   +name+"喵喵..."));
 17		}
 18	    // 创建一个animalShout()静态方法，接收接口类型的参数
 19		public static void animalShout(Animal an) {
 20			an.shout();  
 21		}
 22	}
```  
  运行结果下图所示。
![alt](/article_img/lambda/1.jpg)
  上述代码示例中，先定义了只有一个抽象方法的接口Animal，然后分别使用匿名内部类和Lambda表达式的方式实现了接口方法。从图中可以看出，使用匿名内部类和Lambda表达式都能实现接口中方法，但很显然使用Lambda表达式更加简洁和清晰。, 2018-11-27, null, 默认分类, 2018,Lambda表达式, true, null, 18, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20003, rs-50003} Result: [7, 函数式接口, &emsp;&emsp;虽然Lambda表达式可以实现匿名内部类的功能，但在使用时却有一个局限，即接口中有且只有一个抽象方法时才能使用Lamdba表达式代替匿名内部类。这是因为Lamdba表达式是基于函数式接口实现的，所谓函数式接口是指有且仅有一个抽象方法的接口，Lambda表达式就是Java中函数式编程的体现，只有确保接口中有且仅有一个抽象方法，Lambda表达式才能顺利地推导出所实现的这个接口中的方法。  
&emsp;&emsp;在JDK 8中，专门为函数式接口引入了一个@FunctionalInterface注解，该注解只是显示的标注了接口是一个函数式接口，并强制编辑器进行更严格的检查，确保该接口是函数式接口，如果不是函数式接口，那么编译器就会报错，而对程序运行并没有实质上的影响。  
&emsp;&emsp;接下来通过一个案例来演示函数式接口的定义与使用，示例代码如下所示。
```js
 1	// 定义无参、无返回值的函数式接口
 2	@FunctionalInterface
 3	interface Animal {
 4		void shout();
 5	}
 6	// 定义有参、有返回值的函数式接口
 7	interface Calculate {
 8		int sum(int a, int b);
 9	}
 10	public class Example23 {
 11		public static void main(String[] args) {
 12		   // 分别两个函数式接口进行测试
 13		   animalShout(() -> System.out.println("无参、无返回值的函数式接口调用"));
 14		   showSum(10, 20, (x, y) -> x + y);
 15		}
 16		// 创建一个动物叫的方法，并传入接口对象Animal作为参数
 17		private static void animalShout(Animal animal) {
 18			animal.shout();
 19		}
 20		// 创建一个求和的方法，并传入两个int类型以及接口Calculate类型的参数
 21		private static void showSum(int x, int y, Calculate calculate) {
 22		   System.out.println(x + "+" + y + "的和为：" + calculate.sum(x, y));
 23		}
 24	}
```  
&emsp;&emsp;运行结果如下图所示。

![alt](/article_img/lambda/2.jpg)
&emsp;&emsp;上述代码示例中，先定义了两个函数式接口Animal和Calculate，然后在测试类中分别编写了两个静态方法，并将这两个函数式接口以参数的形式传入，最后在main()方法中分别调用这两个静态方法，并将所需要的函数式接口参数以Lambda表达式的形式传入。从图中可以看出，程序中函数式接口的定义和使用完全正确。
, 2018-12-01, null, 默认分类, 接口,函数式接口, true, null, 12, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20003, rs-50003} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20003, rs-50003} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20003, rs-50003} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20003, rs-50003} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20003, rs-50003} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20003} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20004} created. select username,password,valid from t_user where username = ?
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20004} Parameters : [111]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20004} Types : [VARCHAR]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20004, rs-50004} query executed. 0.5556 millis. select username,password,valid from t_user where username = ?
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} Header: [username, password, valid]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20004} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20005} created. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20005} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20005} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20005} executed. 0.5498 millis. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20005, rs-50005} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20005, rs-50005} Header: [count(0)]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20005, rs-50005} Result: [12]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20005, rs-50005} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20005} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20006} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20006} Parameters : [5]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20006} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20006} executed. 0.6628 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20006, rs-50006} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20006, rs-50006} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20006, rs-50006} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20006, rs-50006} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20006, rs-50006} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20006, rs-50006} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20006, rs-50006} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20006, rs-50006} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20006} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20007} created. select username,password,valid from t_user where username = ?
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20007} Parameters : [admin]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20007} Types : [VARCHAR]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20007, rs-50007} query executed. 0.5648 millis. select username,password,valid from t_user where username = ?
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20007, rs-50007} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20007, rs-50007} Header: [username, password, valid]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20007, rs-50007} Result: [admin, $2a$10$5ooQI8dir8jv0/gCa1Six.GpzAdIPf6pMqdminZ/3ijYzivCyPlfK, true]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20007, rs-50007} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20007} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20008} created. select u.username,a.authority from t_user u,t_authority a,t_user_authority ua where ua.user_id=u.id and ua.authority_id=a.id and u.username =?
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20008} Parameters : [admin]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20008} Types : [VARCHAR]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20008, rs-50008} query executed. 3.0572 millis. select u.username,a.authority from t_user u,t_authority a,t_user_authority ua where ua.user_id=u.id and ua.authority_id=a.id and u.username =?
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20008, rs-50008} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20008, rs-50008} Header: [username, authority]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20008, rs-50008} Result: [admin, ROLE_admin]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20008, rs-50008} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20008} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20009} created. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20009} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20009} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20009} executed. 0.5321 millis. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20009, rs-50009} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20009, rs-50009} Header: [count(0)]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20009, rs-50009} Result: [12]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20009, rs-50009} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20009} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20010} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20010} Parameters : [5]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20010} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20010} executed. 0.8682 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20010, rs-50010} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20010, rs-50010} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20010, rs-50010} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20010, rs-50010} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20010, rs-50010} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20010, rs-50010} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20010, rs-50010} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20010, rs-50010} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20010} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20011} created. select username,password,valid from t_user where username = ?
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20011} Parameters : [admin]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20011} Types : [VARCHAR]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20011, rs-50011} query executed. 0.5752 millis. select username,password,valid from t_user where username = ?
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20011, rs-50011} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20011, rs-50011} Header: [username, password, valid]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20011, rs-50011} Result: [admin, $2a$10$5ooQI8dir8jv0/gCa1Six.GpzAdIPf6pMqdminZ/3ijYzivCyPlfK, true]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20011, rs-50011} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20011} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20012} created. select u.username,a.authority from t_user u,t_authority a,t_user_authority ua where ua.user_id=u.id and ua.authority_id=a.id and u.username =?
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20012} Parameters : [admin]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20012} Types : [VARCHAR]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20012, rs-50012} query executed. 0.5332 millis. select u.username,a.authority from t_user u,t_authority a,t_user_authority ua where ua.user_id=u.id and ua.authority_id=a.id and u.username =?
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20012, rs-50012} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20012, rs-50012} Header: [username, authority]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20012, rs-50012} Result: [admin, ROLE_admin]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20012, rs-50012} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20012} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20013} created. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20013} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20013} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20013} executed. 0.5706 millis. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20013, rs-50013} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20013, rs-50013} Header: [count(0)]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20013, rs-50013} Result: [12]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20013, rs-50013} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20013} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20014} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20014} Parameters : [5]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20014} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20014} executed. 0.4916 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20014, rs-50014} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20014, rs-50014} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20014, rs-50014} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20014, rs-50014} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20014, rs-50014} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20014, rs-50014} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20014, rs-50014} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20014, rs-50014} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20014} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} connected
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} created. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} executed. 10.3717 millis. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Header: [count(0)]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [12]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} Parameters : [5]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} executed. 1.894 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} executed. 0.8497 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [12, Spring Boot 2 权威发布,   如果这两天登录 [https://start.spring.io/ ](https://start.spring.io/ )就会发现，Spring Boot 默认版本已经升到了 2.1.0。这是因为 Spring Boot 刚刚发布了 2.1.0 版本，我们来看下 Spring Boot 2 发布以来第一个子版本都发布了哪些内容？  

**2.1 中的新特性**     
  ●将spring-boot-starter-oauth2-oidc-client重命名为spring-boot-starter-oauth2-client命名更简洁  
  ●添加 OAuth2 资源服务 starter，OAuth2 一个用于认证的组件  
  ●支持 ConditionalOnBean 和 ConditionalOnMissingBean 下的参数化容器  
  ●自动配置 applicationTaskExecutor bean 的延迟加载来避免不必要的日志记录  
  ●将 DatabaseDriver＃SAP 重命名为 DatabaseDriver  
  ●跳过重启器不仅适用于 JUnit4，也适用于 JUnit5  
  ●在 Jest HealthIndicator 中使用集群端点  
  ●当 DevTools 禁用重启时添加日志输出  
  ●添加注解：@ConditionalOnMissingServletFilter提高 Servlet Filters 的自动装配。
  
**2.1 中的组件升级**  
  ●升级 Hibernate 5.3，Hibernate 的支持升级到了 5.3  
  ●升级 Tomcat 9 ，支持最新的 tomcat 9  
  ●支持 Java 11，Java 现在更新越来越快，Spring 快赶不上了    
  ●升级 Thymeleaf Extras Springsecurity 到 3.0.4.RELEASE ，thymeleaf-extras-springsecurity 是 Thymeleaf 提供集成 Spring Security 的组件  
  ●升级 Joda Time 2.10.1，Joda-Time， 面向 Java 应用程序的日期/时间库的替代选择，Joda-Time 令时间和日期值变得易于管理、操作和理解。  
  ●升级 Lettuce 5.1.2.RELEASE ，Lettuce 前面说过，传说中 Redis 最快的客户端。  
  ●升级 Reactor Californium-SR2 ，Californium 是物联网云服务的 Java COAP 实现。因此，它更专注的是可扩展性和可用性而不是像嵌入式设备那样关注资源效率。不过，Californium 也适合嵌入式的 JVM。  
  ●升级 Maven Failsafe Plugin 2.22.1 ，Maven 中的测试插件。  
  ●升级 Flyway 5.2.1 ， Flyway是一款开源的数据库版本管理工具  
  ●升级 Aspectj 1.9.2 ，AspectJ 是 Java 中流行的 AOP（Aspect-oriented Programming）编程扩展框架，是 Eclipse 托管给 Apache 基金会的一个开源项目。  
  ●升级 Mysql 8.0.13 ，Mysql 支持到 8。  
  ●...  
  更多的详细内容可以参考这里：[Spring Boot 2.1 Release Notes](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.1-Release-Notes)
, 2018-12-12, 2021-05-21, 默认分类, Spring Boot 2, true, null, 62, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [8, JDK 8——聚合操作, &emsp;&emsp;在Java8版本中，JDK包含许多聚合操作（如平均值，总和，最小，最大，和计数），返回一个计算流stream的聚合结果。这些聚合操作被称为聚合操作。JDK除返回单个值的聚合操作外，还有很多聚合操作返回一个collection集合实例。很多的reduce操作执行特定的任务，如求平均值或按类别分组元素。  

**1. 聚合操作简介**

  在开发中，多数情况下会涉及到对集合、数组中元素的操作，在JDK 8之前都是通过普通的循环遍历出每一个元素，然后还会穿插一些if条件语句选择性的对元素进行查找、过滤、修改等操作，这种原始的操作方法虽然可行，但是代码量较大并且执行效率较低。  
  为此，JDK 8中新增了一个Stream接口，该接口可以将集合、数组的中的元素转换为Stream流的形式，并结合Lambda表达式的优势来进一步简化集合、数组中元素的查找、过滤、转换等操作，这一新功能就是JDK 8中的聚合操作。  
  在程序中，使用聚合操作没有绝对的语法规范，根据实际操作流程，主要可以分为以下3个步骤：  
  （1）将原始集合或者数组对象转换为Stream流对象；  
  （2）对Stream流对象中的元素进行一系列的过滤、查找等中间操作（Intermediate Operations），然后仍然返回一个Stream流对象；  
  （3）对Stream流进行遍历、统计、收集等终结操作（Terminal Operation），获取想要的结果。  
  接下来，就根据上面聚合操作的3个步骤，通过一个案例来演示聚合操作的基本用法，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example31 {
 4		public static void main(String[] args) {
 5	          // 创建一个List集合对象
 6			List<String> list = new ArrayList<>(); 
 7			list.add("张三");
 8			list.add("李四");
 9			list.add("张小明");
 10			list.add("张阳");
 11			// 1、创建一个Stream流对象
 12			Stream<String> stream = list.stream();
 13			// 2、对Stream流中的元素分别进行过滤、截取操作
 14		       Stream<String> stream2 = stream.filter(i -> i.startsWith("张"));
 15			Stream<String> stream3 = stream2.limit(2);
 16			// 3、对Stream流中的元素进行终结操作，进行遍历输出
 17			stream3.forEach(j -> System.out.println(j));
 18			System.out.println("=======");
 19	         // 通过链式表达式的形式完成聚合操作
 20			list.stream().filter(i -> i.startsWith("张"))
 21						 .limit(2)
 22						 .forEach(j -> System.out.println(j));
 23		}
 24	}
``` 
   运行结果如下图所示。
![alt](/article_img/lambda/3.jpg)
  上述示例代码中，先创建了一个List集合，然后根据聚合操作的3个步骤实现了集合对象的聚合操作，对集合中的元素使用Stream流的形式进行过滤（filter）、截取（limit），并进行遍历输出。其中第12~17行代码分步骤详细展示了聚合操作，而第20~22行代码是使用了链式表达式（调用有返回值的方法时不获取返回值而是直接再调用另一个方法）实现了聚合操作，该表达式的语法格式更简洁、高效，这种链式调用也被称为操作管道流。

**2. 创建Stream流对象**  
  在上一小节中，介绍了聚合操作的主要使用步骤，其中首要解决的问题就是创建Stream流对象。聚合操作针对的就是可迭代数据进行的操作，如集合、数组等，所以创建Stream流对象其实就是将集合、数组等通过一些方法转换为Stream流对象。  
  在Java中，集合对象有对应的集合类，可以通过集合类提供的静态方法创建Stream流对象，而数组数据却没有对应的数组类，所以必须通过其他方法创建Stream流对象。针对不同的源数据，Java提供了多种创建Stream流对象的方式，分别如下：  
  （1）所有的Collections集合都可以使用stream()静态方法获取Stream流对象；  
  （2）Stream接口的of()静态方法可以获取基本类型包装类数组、引用类型数组和单个元素的Stream流对象；  
  （3）Arrays数组工具类的stream()静态方法也可以获取数组元素的Stream流对象。  
  接下来，通过一个案例来学习聚合操作中如何创建Stream流对象，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example32 {
 4		public static void main(String[] args) {
 5	          // 创建一个数组
 6			Integer[] array = { 9, 8, 3, 5, 2 };       
 7	          // 将数组转换为List集合
 8			List<Integer> list = Arrays.asList(array); 
 9			// 1、使用集合对象的stream()静态方法创建Stream流对象
 10			Stream<Integer> stream = list.stream();
 11			stream.forEach(i -> System.out.print(i+" "));
 12			System.out.println();
 13			// 2、使用Stream接口的of()静态方法创建Stream流对象
 14			Stream<Integer> stream2 = Stream.of(array);
 15			stream2.forEach(i -> System.out.print(i+" "));
 16			System.out.println();
 17			// 3、使用Arrays数组工具类的stream()静态方法创建Stream流对象
 18			Stream<Integer> stream3 = Arrays.stream(array);
 19			stream3.forEach(i -> System.out.print(i+" "));
 20		}
 21	}
```  
  运行结果如下图所示。
![alt](/article_img/lambda/4.jpg)
  上述示例代码中，先创建了一个数组和一个集合，然后通过三种方式实现了Stream流对象的创建，并通过Stream流对象的forEach()方法结合Lambda表达式完成了集合和数组中元素的遍历。  

**小提示：**  
  在JDK 8中，只针对单列集合Collections接口对象提供了stream()静态方法获取Stream流对象，并未对Map集合提供相关方法获取Stream流对象，所以想要用Map集合创建Stream流对象必须先通过Map集合的keySet()、values()、entrySet()等方法将Map集合转换为单列Set集合，然后再使用单列集合的stream()静态方法获取对应键、值集合的Stream流对象。

, 2018-12-02, null, 默认分类, JDK 8,聚合操作, true, null, 36, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [9, 虚拟化容器技术——Docker运行机制介绍,   Docker是一个开源的应用容器引擎，它基于go语言开发，并遵从Apache2.0开源协议。使用Docker可以让开发者封装他们的应用以及依赖包到一个可移植的容器中，然后发布到任意的Linux机器上，也可以实现虚拟化。Docker容器完全使用沙箱机制，相互之间不会有任何接口，这保证了容器之间的安全性。  

**1. Docker的引擎介绍**

  Docker Engine（Docker引擎）是Docker的核心部分，使用的是客户端-服务器（C/S）架构模式，其主要组成部分如下图所示。
![alt](/article_img/docker/1.png)
  从上图可以看出，Docker Engine中包含了三个核心组件（docker CLI、REST API和docker daemon），这三个组件的具体说明如下：  
  ①docker CLI（command line interface）：表示Docker命令行接口，开发者可以在命令行中使用Docker相关指令与Docker守护进程进行交互，从而管理诸如image（镜像）、container（容器）、network（网络）和data volumes（数据卷）等实体。  
  ②REST API：表示应用程序API接口，开发者通过该API接口可以与Docker的守护进程进行交互，从而指示后台进行相关操作。  
  ③docker daemon：表示Docker的服务端组件，他是Docker架构中运行在后台的一个守护进程，可以接收并处理来自命令行接口及API接口的指令，然后进行相应的后台操作。  
  对于开发者而言，既可以使用编写好的脚本文件通过REST API来实现与Docker进程交互，又可以直接使用Docker相关指令通过命令行接口来与Docker进程交互，而其他一些Docker应用则是通过底层的API和CLI进行交互的。

**2. Docker的架构介绍**

  了解了Docker内部引擎及作用后，我们还需要通过Docker的具体架构，来了解Docker的整个运行流程。接下来借助Docker官网的架构图来对Docker架构进行详细说明，如下图所示。
![alt](/article_img/docker/2.jpg)
  从图中可以看出，Docker架构主要包括Client、DOCKER_HOST和Register三部分，关于这三部分的具体说明如下。  
&emsp;&emsp;**（1）Client（客户端）**  
  Client即Docker客户端，也就是上一小节Docker Engine中介绍的docker CLI。开发者通过这个客户端使用Docker的相关指令与Docker守护进程进行交互，从而进行Docker镜像的创建、拉取和运行等操作。  
&emsp;&emsp;**（2）DOCKER_HOST（Docker主机）**  
  DOCKER_HOST即Docker内部引擎运行的主机，主要指Docker daemon（Docker守护进程）。可以通过Docker守护进程与客户端还有Docker的镜像仓库Registry进行交互，从而管理Images（镜像）和Containers（容器）等。  
&emsp;&emsp;**（3）Registry（注册中心）**  
  Registry即Docker注册中心，实质就是Docker镜像仓库，默认使用的是Docker官方远程注册中心Docker Hub，也可以使用开发者搭建的本地仓库。Registry中包含了大量的镜像，这些镜像可以是官网基础镜像，也可以是其他开发者上传的镜像。  
  我们在实际使用Docker时，除了会涉及到图中的三个主要部分外，还会涉及到很多Docker Objects（Docker对象），例如Images（镜像）、Containers（容器）、Networks（网络）、Volumes（数据卷）、Plugins（插件）等。其中常用的两个对象Image和Containers的说明如下。  
  ①Images（镜像）  
  Docker 镜像就是一个只读的模板，包含了一些创建Docker容器的操作指令。通常情况下，一个Docker镜像是基于另一个基础镜像创建的，并且新创建的镜像会额外包含一些功能配置。例如：开发者可以依赖于一个Ubuntu的基础镜像创建一个新镜像，并可以在新镜像中安装Apache等软件或其它应用程序。  
  ②Containers（容器）  
  Docker容器属于镜像的一个可运行实例（镜像与容器的关系其实与Java中的类与对象相似），开发者可以通过API接口或者CLI命令行接口来创建、运行、停止、移动、删除一个容器，也可以将一个容器连接到一个或多个网络中，将数据存储与容器进行关联。



, 2018-12-03, null, 默认分类, 虚拟化容器,Docker,运行机制, true, null, 26, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [10, Docker常用客户端指令介绍,   在使用Docker之前，首先会为对应的项目编写Dockerfile镜像构建文件，然后通过Docker的相关指令进行镜像构建，完成镜像的构建后，就可以使用这些项目镜像进行启动测试了。所以要想知道如何使用Docker来执行这些Dockerfile镜像构建文件，还需要学习Docker客户端的常用指令，本篇文章将对Docker客户端的常用指令进行详细讲解。  

**1.列出镜像**  
  通过docker images指令可以查看本地镜像列表中已有的镜像，具体使用方式如下。
```js
$ docker images
```  
  执行上述指令后，系统会将所有本地镜像都展示出来，如下图所示。
![alt](/article_img/docker/3.png)
  从图中可以看出，系统终端将本地镜像列表中的3个镜像分5列进行了展示，每一列的具体含义如下。  
  ●REPOSITORY：镜像名称。  
  ●TAG：镜像的参数，类似于版本号，默认是latest。  
  ●IMAGE ID：镜像ID，是唯一值。此处看到的是一个长度为12的字符串，实际上它是64位完整镜像ID的缩写形式。  
  ●CREATED：距今创建镜像的时间。  
  ●SIZE：镜像大小。    

**2.搜索镜像**  
  想知道在Docker Hub中包含了哪些镜像，除了可以登录Docker Hub，在官网中心进行查看外，还可以直接在Docker客户端进行查询。例如想要查询Ubuntu镜像，可以使用如下指令。
```js
$ docker search ubuntu
```  
  执行上述指令后，系统终端就会将搜索到的有关Ubuntu的镜像展示出来，如下图所示。
![alt](/article_img/docker/4.png)
  从图所示的结果可以看出，系统终端分5列将搜索到的Ubuntu相关镜像都列举出来了，这5列的具体含义如下。  
  ●NAME：表示镜像的名称，这里有两种格式的名称，其中不带有“/”的表示官方镜像，而带有“/”的表示其他用户的公开镜像。公开镜像“/”前面是用户在Docker Hub上的用户名（唯一），后面是对应的镜像名；官方镜像与用户镜像，除了从镜像名称上可以区分外，还可以通过第4列的OFFICIAL声明中看出（该列下内容为OK表示官方镜像）。  
  ●DESCRIPTION：表示镜像的描述，这里只显示了一小部分。  
  ●STARS：表示该镜像的收藏数，用户可以在Docker Hub上对镜像进行收藏，一般可以通过该数字反应出该镜像的受欢迎程度。  
  ●OFFICIAL：表示是否为官方镜像。  
  ●AUTOMATED：表示是否自动构建镜像。例如，用户可以将自己的Docker Hub绑定到如Github上，当代码提交更新后，可以自动构建镜像。   
 
**3.拉取镜像**  
  通过docker pull指令可以拉取仓库镜像到本地（默认都是拉取Docker Hub仓库镜像，也可以指定“IP+端口”拉取某个Docker机器上的私有仓库镜像），具体使用方式如下。
```js
$ docker pull ubuntu
```  
  执行上述指令后，Docker会自动从Docker Hub上下载最新版本的Ubuntu到本地，当然也可以使用以下指令拉取指定版本的镜像到本地，具体指令如下。
```js
$ docker pull ubuntu:14.04
```  
**4.构建镜像**  
  除了可以通过docker pull指令从仓库拉取镜像外，还可以通过docker build指令构建Docker镜像，通常情况下都是通过Dockerfile文件来构建镜像的。  
  这里假设linux系统home目录下/shitou/workspace/dockerspace文件夹中编写有对应的Dockerfile文件，则构建镜像直立示例如下所示。 
```js
$ docker build -t hellodocker3 /home/shitou/workspace/dockerspace/.
```
**5.删除镜像**  
  当本地存放过多不需要的镜像时，可以通过docker rmi指令将其删除。在删除镜像时，需要指定镜像名称或镜像ID。删除镜像的使用方式如下。
```js
$ docker rmi -f hellodocker2 hellodocker3
```  
  上述指令中，docker rmi表示删除镜像，-f表示进行强制删除，而hellodocker2和hellodocker3分别表示需要删除的镜像名称，这里同时删除两个镜像。除了根据名称删除镜像外，还也可以根据镜像ID来删除镜像，只是这里如果指定了删除ID为23c617a866d4的镜像后，会同时删除hellodocker、hellodocker2和hellodocker3三个镜像。  
  需要特别强调的是，在进行镜像删除操作时，如果是通过镜像ID进行镜像删除，那么由该镜像创建的容器必须提前删除或停止。另外，在通过镜像名称操作镜像时，如果出现镜像重名的情况，必须在镜像名称后面指定镜像标签tag参数来确保唯一性。

**6.创建并启动容器**  
  Docker镜像主要用于创建容器，可以使用docker run指令创建并启动容器，具体使用方式如下。
```js
$ docker run -d -p 5000:80 --name test hellodocker
```  
  上述创建并启动容器的指令略微复杂，具体分析如下。  
  ●docker run：表示创建并启动一个容器，而后面的hellodocker就表示要启动运行的镜像名称；  
  ●-d：表示容器启动时在后台运行；  
  ●-p 5000:80：表示将容器内暴露的80端口映射到宿主机指定的5000端口，也可以将-p 5000:80更改为-P来映射主机的随机端口（注意p字母的大小写）；  
  ●--name test：表示为创建后的容器指定名称为test，如果没有该参数配置，则生成的容器会设置一个随机名称。  
  docker run命令是Docker操作中较为复杂的一个，它可以携带多个参数和参数，我们可以通过docker run --help指令进行查看，其中有些参数如-e、-v和-w等都可以在Dockerfile文件中预先声明。 
 
**7.列出容器**  
  生成容器后，可以通过docker ps指令查看当前运行的所有容器，具体使用方式如下。
```js
$ docker ps
```  
  执行上述命令后，会将所有当前运行的容器都展示出来，具体如下图所示。
![alt](/article_img/docker/5.png)
  从图中可以看出，系统终端通过7列对当前的正在运行的一个容器进行了展示，图中每一列的具体含义如下。  
  ●CONTAINER ID：表示生成的容器ID；  
  ●IMAGE：表示生成该容器的镜像名称；  
  ●COMMAND：表示启动容器时运行的命令，Docker要求在启动容器时必须运行一个命令；  
  ●CREATED：表示容器创建的时间；  
  ●STATUS：表示容器运行状态，例如Up表示运行中，Exited表示已停止；  
  ●PORTS：表示容器内部暴露的端口映射到主机的端口；  
  ●NAMES：表示生成容器的名称，由Docker引擎自动生成，可以像上述示例中使用--name参数指定生成容器的名称。  
  另外，docker ps指令运行过程中可以指定多个参数，还可以通过docker ps --help指令对ps指令的其他信息进行查看。

**8.删除容器**  
  当不需要使用容器时，则可以使用docker rm指令删除已停止的容器，具体使用方式如下。
```js
$ docker rm f0c9a8b6e8c5
```  
  需要注意的是，上述指令只能删除已经停止运行的容器，而不能删除正在运行的容器。如果想要删除正在运行的容器，则需要添加-f参数强制删除，具体使用方式如下。
```js
$ docker rm -f f0c9a8b6e8c5
```  
  当需要删除的容器过多时，如果还一个个的删除就略显麻烦了，此时可以通过如下指令将全部容器删除。
```js
$ docker rm -f $(docker ps -aq)
```  
  上述指令中，首先会通过$(docker ps -aq)获取所有容器的ID，然后通过docker rm -f指令进行强制删除。如果开发者有自己特殊的删除需求，可以根据前面docker ps指令进行组装来获取需要删除的容器ID。  
  Docker提供的操作指令远不止这些，这里就不一一列举了，想要了解更多Docker的操作指令，可以通过docker --help指令进行查看。


, 2018-12-05, null, 默认分类, Docker,客户端指令, true, null, 21, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [11, Docker数据管理介绍,   当我们对容器进行相关操作时，产生的一系列数据都会存储在容器中，而Docker内部又是如果管理这些数据的呢？本篇文章将针对Docker数据管理的一些知识进行介绍。
  
**1. Docker数据存储机制**  
  使用Docker时，我们操作的都是镜像和由镜像生成的容器，所以想要更好的了解Docker内部的数据存储机制，就必须从镜像、容器与数据存储的关系出发。  
  Docker镜像是通过读取Dockerfile文件中的指令构建的，Dockerfile中的每条指令都会创建一个镜像层，并且每层都是只读的，这一系列的镜像层就构成了Docker镜像。接下来以一个Dockerfile文件为例进行说明，具体如下列代码示例所示。
```js
 1	FROM ubuntu:16.04
 2	COPY . /app
 3	RUN make /app
 4	CMD python /app/app.py
```  
   上述文件示例中的Dockerfile包含了4条指令，每条指令都会创建一个镜像层，其中每一层与前一层都有所不同，并且是层层叠加的。通过镜像构建容器时，会在镜像层上增加一个容器层（即可写层），所有对容器的更改都会写入容器层，这也是Docker默认的数据存储方式。  
  下面通过一个效果图进行说明，具体如下图所示。
![alt](/article_img/docker/6.png)
  从图中可以看出，Docker容器和镜像之间的主要区别是顶部的容器层，而所有对容器中数据的添加、修改等操作都会被存储在容器层中。当容器被删除时，容器层也会被删除，其中存储的数据会被一同删除，而下面的镜像层却保持不变。  
  由于所有的容器都是通过镜像构建的，所以每个容器都有各自的容器层，对于容器数据的更改就会保存在各自的容器层中。也就是说，由同一个镜像构建的多个容器，它们会拥有相同的底部镜像层，而拥有不同的容器层，多个容器可以访问相同的镜像层，并且有自己的独立数据状态。具体说明如下图所示。 
![alt](/article_img/docker/7.png)
  从图中可以看出，基于同一个镜像构建的多个容器可以共享该镜像层，但是多个容器想要共享相同的数据，就需要将这些数据存储到容器之外的地方，而这种方式就是下一节要提到的Docker volume数据外部挂载机制。  

**2. Docker数据存储方式**    
  在默认情况下，Docker中的数据都是存放在容器层的，但是这样存储数据却有较多的缺陷，具体表现如下。    
  ●当容器不再运行时，容器中的数据无法持久化保存，如果另一个进程需要这些数据，那么将很难从容器中获取数据；  
  ●容器层与正在运行的主机紧密耦合，不能轻易地移动数据；  
  ●容器层需要一个存储驱动程序来管理文件系统，存储驱动程序提供了一个使用Linux内核的联合文件系统，这种额外的抽象化降低了性能。  
  基于上述种种原因，多数情况下Docker数据管理都不会直接将数据写入容器层，而是使用另一种叫做Docker volume数据外部挂载的机制进行数据管理。  
  针对Docker volume数据外部挂载机制，Docker提供了三种不同的方式将数据从容器映射到Docker宿主机，他们分别为：volumes（数据卷）、bind mounts（绑定挂载）和tmpfs mounts（tmpfs挂载）。这三种数据管理方式的具体选择，需要结合实际情况进行考虑，其中的volumes数据卷是最常用也是官方推荐的数据管理方式。无论选择使用哪种数据管理方式，数据在容器内看起来都一样的，而在容器外则会被被挂载到文件系统中的某个目录或文件中。    
  下面通过一张图来展示数据卷、绑定挂载和tmpfs挂载之间的差异，如下图所示。  
![alt](/article_img/docker/8.png)
  从图中可以看出，Docker提供的三种数据管理方式略有不同，具体分析如下。  
  ●volumes：存储在主机文件系统中（在Linux系统下是存在于/var/lib/Docker/volumes/目录），并由Docker管理，非Docker进程无法修改文件系统的这个部分。  
  ●bind mounts：可以存储在主机系统的任意位置，甚至可能是重要的系统文件或目录，在Docker主机或容器上的非Docker进程可以对他们进行任意修改。  
  ●tmpfs mounts：只存储在主机系统的内存中，并没有写入到主机的文件系统中。


, 2018-12-07, 2021-05-19, 默认分类, Docker,数据管理, true, null, 19, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [6, JDK 8——Lambda表达式介绍,   Lambda表达式是JDK 8中一个重要的新特性，它使用一个清晰简洁的表达式来表达一个接口，同时Lambda表达式也简化了对集合以及数组数据的遍历、过滤和提取等操作。下面，本篇文章就对Lambda表达式进行简要介绍，并进行演示说明。

**1. Lambda表达式入门**  

  匿名内部类存在的一个问题是，如果匿名内部类的实现非常简单，例如只包含一个抽象方法的接口，那么匿名内部类的语法仍然显得比较冗余。为此，JDK 8中新增了一个特性Lambda表达式，这种表达式只针对有一个抽象方法的接口实现，以简洁的表达式形式实现接口功能来作为方法参数。  
  一个Lambda表达式由三个部分组成，分别为参数列表、“->”和表达式主体，其语法格式如下：
```js
 ([数据类型 参数名,数据类型 参数名,...]) -> {表达式主体}
```  
  从上述语法格式上看，Lambda表达式的书写非常简单，下面针对Lambda表达式的组成部分进行简单介绍，具体如下：  
  （1）([数据类型 参数名,数据类型 参数名,...])：用来向表达式主体传递接口方法需要的参数，多个参数名中间必须用英文逗号“,”进行分隔；在编写Lambda表达式时，可以省略参数的数据类型，后面的表达式主体会自动进行校对和匹配；同时，如果只有一个参数，则可以省略括号“()”。  
  （2）->：表示Lambda表达式箭牌，用来指定参数数据指向，不能省略，且必须用英文横线和大于号书写。  
  （3）{表达式主体}：由单个表达式或语句块组成的主体，本质就是接口中抽象方法的具体实现，如果表达式主体只有一条语句，那么可以省略包含主体的大括号；另外，在Lambda表达式主体中允许有返回值，当只有一条return语句时，也可以省略return关键字。  
  了解了Lambda表达式的语法后，接下来编写一个示例文件对Lambda表达式的基本使用进行介绍，具体代码如下所示。
```js
 1	// 定义动物类接口
 2	interface Animal { 
 3		void shout(); // 定义方法shout()
 4	}
 5	public class Example22 {
 6		public static void main(String[] args) {
 7	       String name = "小花"; 
 8	       // 1、匿名内部类作为参数传递给animalShout()方法
 9		  animalShout(new Animal() { 
 10				 public void shout() { 
 11				    System.out.println("匿名内部类输出："+name+"喵喵...");
 12				}
 13		  });
 14		  // 2、使用Lambda表达式作为参数传递给animalShout()方法
 15	       animalShout(()-> System.out.println("Lambda表达式输出："
 16	                                                   +name+"喵喵..."));
 17		}
 18	    // 创建一个animalShout()静态方法，接收接口类型的参数
 19		public static void animalShout(Animal an) {
 20			an.shout();  
 21		}
 22	}
```  
  运行结果下图所示。
![alt](/article_img/lambda/1.jpg)
  上述代码示例中，先定义了只有一个抽象方法的接口Animal，然后分别使用匿名内部类和Lambda表达式的方式实现了接口方法。从图中可以看出，使用匿名内部类和Lambda表达式都能实现接口中方法，但很显然使用Lambda表达式更加简洁和清晰。, 2018-11-27, null, 默认分类, 2018,Lambda表达式, true, null, 18, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [7, 函数式接口, &emsp;&emsp;虽然Lambda表达式可以实现匿名内部类的功能，但在使用时却有一个局限，即接口中有且只有一个抽象方法时才能使用Lamdba表达式代替匿名内部类。这是因为Lamdba表达式是基于函数式接口实现的，所谓函数式接口是指有且仅有一个抽象方法的接口，Lambda表达式就是Java中函数式编程的体现，只有确保接口中有且仅有一个抽象方法，Lambda表达式才能顺利地推导出所实现的这个接口中的方法。  
&emsp;&emsp;在JDK 8中，专门为函数式接口引入了一个@FunctionalInterface注解，该注解只是显示的标注了接口是一个函数式接口，并强制编辑器进行更严格的检查，确保该接口是函数式接口，如果不是函数式接口，那么编译器就会报错，而对程序运行并没有实质上的影响。  
&emsp;&emsp;接下来通过一个案例来演示函数式接口的定义与使用，示例代码如下所示。
```js
 1	// 定义无参、无返回值的函数式接口
 2	@FunctionalInterface
 3	interface Animal {
 4		void shout();
 5	}
 6	// 定义有参、有返回值的函数式接口
 7	interface Calculate {
 8		int sum(int a, int b);
 9	}
 10	public class Example23 {
 11		public static void main(String[] args) {
 12		   // 分别两个函数式接口进行测试
 13		   animalShout(() -> System.out.println("无参、无返回值的函数式接口调用"));
 14		   showSum(10, 20, (x, y) -> x + y);
 15		}
 16		// 创建一个动物叫的方法，并传入接口对象Animal作为参数
 17		private static void animalShout(Animal animal) {
 18			animal.shout();
 19		}
 20		// 创建一个求和的方法，并传入两个int类型以及接口Calculate类型的参数
 21		private static void showSum(int x, int y, Calculate calculate) {
 22		   System.out.println(x + "+" + y + "的和为：" + calculate.sum(x, y));
 23		}
 24	}
```  
&emsp;&emsp;运行结果如下图所示。

![alt](/article_img/lambda/2.jpg)
&emsp;&emsp;上述代码示例中，先定义了两个函数式接口Animal和Calculate，然后在测试类中分别编写了两个静态方法，并将这两个函数式接口以参数的形式传入，最后在main()方法中分别调用这两个静态方法，并将所需要的函数式接口参数以Lambda表达式的形式传入。从图中可以看出，程序中函数式接口的定义和使用完全正确。
, 2018-12-01, null, 默认分类, 接口,函数式接口, true, null, 12, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20003} created. select username,password,valid from t_user where username = ?
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20003} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20003} Types : [VARCHAR]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20003, rs-50003} query executed. 2.5591 millis. select username,password,valid from t_user where username = ?
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20003, rs-50003} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20003, rs-50003} Header: [username, password, valid]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20003, rs-50003} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20003} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20004} created. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20004} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20004} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20004} executed. 0.5255 millis. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} Header: [count(0)]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} Result: [12]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20004} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20005} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20005} Parameters : [5]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20005} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20005} executed. 0.5883 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20005, rs-50005} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20005, rs-50005} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20005, rs-50005} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20005, rs-50005} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20005, rs-50005} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20005, rs-50005} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20005, rs-50005} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20005, rs-50005} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20005} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20006} created. select username,password,valid from t_user where username = ?
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20006} Parameters : [admin]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20006} Types : [VARCHAR]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20006, rs-50006} query executed. 0.5978 millis. select username,password,valid from t_user where username = ?
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20006, rs-50006} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20006, rs-50006} Header: [username, password, valid]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20006, rs-50006} Result: [admin, $2a$10$5ooQI8dir8jv0/gCa1Six.GpzAdIPf6pMqdminZ/3ijYzivCyPlfK, true]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20006, rs-50006} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20006} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20007} created. select u.username,a.authority from t_user u,t_authority a,t_user_authority ua where ua.user_id=u.id and ua.authority_id=a.id and u.username =?
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20007} Parameters : [admin]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20007} Types : [VARCHAR]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20007, rs-50007} query executed. 5.709 millis. select u.username,a.authority from t_user u,t_authority a,t_user_authority ua where ua.user_id=u.id and ua.authority_id=a.id and u.username =?
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20007, rs-50007} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20007, rs-50007} Header: [username, authority]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20007, rs-50007} Result: [admin, ROLE_admin]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20007, rs-50007} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20007} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20008} created. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20008} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20008} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20008} executed. 0.5188 millis. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20008, rs-50008} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20008, rs-50008} Header: [count(0)]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20008, rs-50008} Result: [12]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20008, rs-50008} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20008} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20009} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20009} Parameters : [5]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20009} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20009} executed. 0.5708 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20009, rs-50009} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20009, rs-50009} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20009, rs-50009} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20009, rs-50009} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20009, rs-50009} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20009, rs-50009} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20009, rs-50009} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20009, rs-50009} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20009} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20010} created. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20010} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20010} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20010} executed. 0.5236 millis. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20010, rs-50010} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20010, rs-50010} Header: [count(0)]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20010, rs-50010} Result: [12]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20010, rs-50010} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20010} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20011} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20011} Parameters : [5]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20011} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20011} executed. 0.4882 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20011, rs-50011} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20011, rs-50011} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20011, rs-50011} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20011, rs-50011} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20011, rs-50011} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20011, rs-50011} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20011, rs-50011} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20011, rs-50011} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20011} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} connected
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} created. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} executed. 10.2938 millis. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Header: [count(0)]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [12]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} Parameters : [5]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} executed. 1.2076 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} executed. 0.7416 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [12, Spring Boot 2 权威发布,   如果这两天登录 [https://start.spring.io/ ](https://start.spring.io/ )就会发现，Spring Boot 默认版本已经升到了 2.1.0。这是因为 Spring Boot 刚刚发布了 2.1.0 版本，我们来看下 Spring Boot 2 发布以来第一个子版本都发布了哪些内容？  

**2.1 中的新特性**     
  ●将spring-boot-starter-oauth2-oidc-client重命名为spring-boot-starter-oauth2-client命名更简洁  
  ●添加 OAuth2 资源服务 starter，OAuth2 一个用于认证的组件  
  ●支持 ConditionalOnBean 和 ConditionalOnMissingBean 下的参数化容器  
  ●自动配置 applicationTaskExecutor bean 的延迟加载来避免不必要的日志记录  
  ●将 DatabaseDriver＃SAP 重命名为 DatabaseDriver  
  ●跳过重启器不仅适用于 JUnit4，也适用于 JUnit5  
  ●在 Jest HealthIndicator 中使用集群端点  
  ●当 DevTools 禁用重启时添加日志输出  
  ●添加注解：@ConditionalOnMissingServletFilter提高 Servlet Filters 的自动装配。
  
**2.1 中的组件升级**  
  ●升级 Hibernate 5.3，Hibernate 的支持升级到了 5.3  
  ●升级 Tomcat 9 ，支持最新的 tomcat 9  
  ●支持 Java 11，Java 现在更新越来越快，Spring 快赶不上了    
  ●升级 Thymeleaf Extras Springsecurity 到 3.0.4.RELEASE ，thymeleaf-extras-springsecurity 是 Thymeleaf 提供集成 Spring Security 的组件  
  ●升级 Joda Time 2.10.1，Joda-Time， 面向 Java 应用程序的日期/时间库的替代选择，Joda-Time 令时间和日期值变得易于管理、操作和理解。  
  ●升级 Lettuce 5.1.2.RELEASE ，Lettuce 前面说过，传说中 Redis 最快的客户端。  
  ●升级 Reactor Californium-SR2 ，Californium 是物联网云服务的 Java COAP 实现。因此，它更专注的是可扩展性和可用性而不是像嵌入式设备那样关注资源效率。不过，Californium 也适合嵌入式的 JVM。  
  ●升级 Maven Failsafe Plugin 2.22.1 ，Maven 中的测试插件。  
  ●升级 Flyway 5.2.1 ， Flyway是一款开源的数据库版本管理工具  
  ●升级 Aspectj 1.9.2 ，AspectJ 是 Java 中流行的 AOP（Aspect-oriented Programming）编程扩展框架，是 Eclipse 托管给 Apache 基金会的一个开源项目。  
  ●升级 Mysql 8.0.13 ，Mysql 支持到 8。  
  ●...  
  更多的详细内容可以参考这里：[Spring Boot 2.1 Release Notes](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.1-Release-Notes)
, 2018-12-12, 2021-05-21, 默认分类, Spring Boot 2, true, null, 62, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [8, JDK 8——聚合操作, &emsp;&emsp;在Java8版本中，JDK包含许多聚合操作（如平均值，总和，最小，最大，和计数），返回一个计算流stream的聚合结果。这些聚合操作被称为聚合操作。JDK除返回单个值的聚合操作外，还有很多聚合操作返回一个collection集合实例。很多的reduce操作执行特定的任务，如求平均值或按类别分组元素。  

**1. 聚合操作简介**

  在开发中，多数情况下会涉及到对集合、数组中元素的操作，在JDK 8之前都是通过普通的循环遍历出每一个元素，然后还会穿插一些if条件语句选择性的对元素进行查找、过滤、修改等操作，这种原始的操作方法虽然可行，但是代码量较大并且执行效率较低。  
  为此，JDK 8中新增了一个Stream接口，该接口可以将集合、数组的中的元素转换为Stream流的形式，并结合Lambda表达式的优势来进一步简化集合、数组中元素的查找、过滤、转换等操作，这一新功能就是JDK 8中的聚合操作。  
  在程序中，使用聚合操作没有绝对的语法规范，根据实际操作流程，主要可以分为以下3个步骤：  
  （1）将原始集合或者数组对象转换为Stream流对象；  
  （2）对Stream流对象中的元素进行一系列的过滤、查找等中间操作（Intermediate Operations），然后仍然返回一个Stream流对象；  
  （3）对Stream流进行遍历、统计、收集等终结操作（Terminal Operation），获取想要的结果。  
  接下来，就根据上面聚合操作的3个步骤，通过一个案例来演示聚合操作的基本用法，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example31 {
 4		public static void main(String[] args) {
 5	          // 创建一个List集合对象
 6			List<String> list = new ArrayList<>(); 
 7			list.add("张三");
 8			list.add("李四");
 9			list.add("张小明");
 10			list.add("张阳");
 11			// 1、创建一个Stream流对象
 12			Stream<String> stream = list.stream();
 13			// 2、对Stream流中的元素分别进行过滤、截取操作
 14		       Stream<String> stream2 = stream.filter(i -> i.startsWith("张"));
 15			Stream<String> stream3 = stream2.limit(2);
 16			// 3、对Stream流中的元素进行终结操作，进行遍历输出
 17			stream3.forEach(j -> System.out.println(j));
 18			System.out.println("=======");
 19	         // 通过链式表达式的形式完成聚合操作
 20			list.stream().filter(i -> i.startsWith("张"))
 21						 .limit(2)
 22						 .forEach(j -> System.out.println(j));
 23		}
 24	}
``` 
   运行结果如下图所示。
![alt](/article_img/lambda/3.jpg)
  上述示例代码中，先创建了一个List集合，然后根据聚合操作的3个步骤实现了集合对象的聚合操作，对集合中的元素使用Stream流的形式进行过滤（filter）、截取（limit），并进行遍历输出。其中第12~17行代码分步骤详细展示了聚合操作，而第20~22行代码是使用了链式表达式（调用有返回值的方法时不获取返回值而是直接再调用另一个方法）实现了聚合操作，该表达式的语法格式更简洁、高效，这种链式调用也被称为操作管道流。

**2. 创建Stream流对象**  
  在上一小节中，介绍了聚合操作的主要使用步骤，其中首要解决的问题就是创建Stream流对象。聚合操作针对的就是可迭代数据进行的操作，如集合、数组等，所以创建Stream流对象其实就是将集合、数组等通过一些方法转换为Stream流对象。  
  在Java中，集合对象有对应的集合类，可以通过集合类提供的静态方法创建Stream流对象，而数组数据却没有对应的数组类，所以必须通过其他方法创建Stream流对象。针对不同的源数据，Java提供了多种创建Stream流对象的方式，分别如下：  
  （1）所有的Collections集合都可以使用stream()静态方法获取Stream流对象；  
  （2）Stream接口的of()静态方法可以获取基本类型包装类数组、引用类型数组和单个元素的Stream流对象；  
  （3）Arrays数组工具类的stream()静态方法也可以获取数组元素的Stream流对象。  
  接下来，通过一个案例来学习聚合操作中如何创建Stream流对象，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example32 {
 4		public static void main(String[] args) {
 5	          // 创建一个数组
 6			Integer[] array = { 9, 8, 3, 5, 2 };       
 7	          // 将数组转换为List集合
 8			List<Integer> list = Arrays.asList(array); 
 9			// 1、使用集合对象的stream()静态方法创建Stream流对象
 10			Stream<Integer> stream = list.stream();
 11			stream.forEach(i -> System.out.print(i+" "));
 12			System.out.println();
 13			// 2、使用Stream接口的of()静态方法创建Stream流对象
 14			Stream<Integer> stream2 = Stream.of(array);
 15			stream2.forEach(i -> System.out.print(i+" "));
 16			System.out.println();
 17			// 3、使用Arrays数组工具类的stream()静态方法创建Stream流对象
 18			Stream<Integer> stream3 = Arrays.stream(array);
 19			stream3.forEach(i -> System.out.print(i+" "));
 20		}
 21	}
```  
  运行结果如下图所示。
![alt](/article_img/lambda/4.jpg)
  上述示例代码中，先创建了一个数组和一个集合，然后通过三种方式实现了Stream流对象的创建，并通过Stream流对象的forEach()方法结合Lambda表达式完成了集合和数组中元素的遍历。  

**小提示：**  
  在JDK 8中，只针对单列集合Collections接口对象提供了stream()静态方法获取Stream流对象，并未对Map集合提供相关方法获取Stream流对象，所以想要用Map集合创建Stream流对象必须先通过Map集合的keySet()、values()、entrySet()等方法将Map集合转换为单列Set集合，然后再使用单列集合的stream()静态方法获取对应键、值集合的Stream流对象。

, 2018-12-02, null, 默认分类, JDK 8,聚合操作, true, null, 36, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [9, 虚拟化容器技术——Docker运行机制介绍,   Docker是一个开源的应用容器引擎，它基于go语言开发，并遵从Apache2.0开源协议。使用Docker可以让开发者封装他们的应用以及依赖包到一个可移植的容器中，然后发布到任意的Linux机器上，也可以实现虚拟化。Docker容器完全使用沙箱机制，相互之间不会有任何接口，这保证了容器之间的安全性。  

**1. Docker的引擎介绍**

  Docker Engine（Docker引擎）是Docker的核心部分，使用的是客户端-服务器（C/S）架构模式，其主要组成部分如下图所示。
![alt](/article_img/docker/1.png)
  从上图可以看出，Docker Engine中包含了三个核心组件（docker CLI、REST API和docker daemon），这三个组件的具体说明如下：  
  ①docker CLI（command line interface）：表示Docker命令行接口，开发者可以在命令行中使用Docker相关指令与Docker守护进程进行交互，从而管理诸如image（镜像）、container（容器）、network（网络）和data volumes（数据卷）等实体。  
  ②REST API：表示应用程序API接口，开发者通过该API接口可以与Docker的守护进程进行交互，从而指示后台进行相关操作。  
  ③docker daemon：表示Docker的服务端组件，他是Docker架构中运行在后台的一个守护进程，可以接收并处理来自命令行接口及API接口的指令，然后进行相应的后台操作。  
  对于开发者而言，既可以使用编写好的脚本文件通过REST API来实现与Docker进程交互，又可以直接使用Docker相关指令通过命令行接口来与Docker进程交互，而其他一些Docker应用则是通过底层的API和CLI进行交互的。

**2. Docker的架构介绍**

  了解了Docker内部引擎及作用后，我们还需要通过Docker的具体架构，来了解Docker的整个运行流程。接下来借助Docker官网的架构图来对Docker架构进行详细说明，如下图所示。
![alt](/article_img/docker/2.jpg)
  从图中可以看出，Docker架构主要包括Client、DOCKER_HOST和Register三部分，关于这三部分的具体说明如下。  
&emsp;&emsp;**（1）Client（客户端）**  
  Client即Docker客户端，也就是上一小节Docker Engine中介绍的docker CLI。开发者通过这个客户端使用Docker的相关指令与Docker守护进程进行交互，从而进行Docker镜像的创建、拉取和运行等操作。  
&emsp;&emsp;**（2）DOCKER_HOST（Docker主机）**  
  DOCKER_HOST即Docker内部引擎运行的主机，主要指Docker daemon（Docker守护进程）。可以通过Docker守护进程与客户端还有Docker的镜像仓库Registry进行交互，从而管理Images（镜像）和Containers（容器）等。  
&emsp;&emsp;**（3）Registry（注册中心）**  
  Registry即Docker注册中心，实质就是Docker镜像仓库，默认使用的是Docker官方远程注册中心Docker Hub，也可以使用开发者搭建的本地仓库。Registry中包含了大量的镜像，这些镜像可以是官网基础镜像，也可以是其他开发者上传的镜像。  
  我们在实际使用Docker时，除了会涉及到图中的三个主要部分外，还会涉及到很多Docker Objects（Docker对象），例如Images（镜像）、Containers（容器）、Networks（网络）、Volumes（数据卷）、Plugins（插件）等。其中常用的两个对象Image和Containers的说明如下。  
  ①Images（镜像）  
  Docker 镜像就是一个只读的模板，包含了一些创建Docker容器的操作指令。通常情况下，一个Docker镜像是基于另一个基础镜像创建的，并且新创建的镜像会额外包含一些功能配置。例如：开发者可以依赖于一个Ubuntu的基础镜像创建一个新镜像，并可以在新镜像中安装Apache等软件或其它应用程序。  
  ②Containers（容器）  
  Docker容器属于镜像的一个可运行实例（镜像与容器的关系其实与Java中的类与对象相似），开发者可以通过API接口或者CLI命令行接口来创建、运行、停止、移动、删除一个容器，也可以将一个容器连接到一个或多个网络中，将数据存储与容器进行关联。



, 2018-12-03, null, 默认分类, 虚拟化容器,Docker,运行机制, true, null, 26, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [10, Docker常用客户端指令介绍,   在使用Docker之前，首先会为对应的项目编写Dockerfile镜像构建文件，然后通过Docker的相关指令进行镜像构建，完成镜像的构建后，就可以使用这些项目镜像进行启动测试了。所以要想知道如何使用Docker来执行这些Dockerfile镜像构建文件，还需要学习Docker客户端的常用指令，本篇文章将对Docker客户端的常用指令进行详细讲解。  

**1.列出镜像**  
  通过docker images指令可以查看本地镜像列表中已有的镜像，具体使用方式如下。
```js
$ docker images
```  
  执行上述指令后，系统会将所有本地镜像都展示出来，如下图所示。
![alt](/article_img/docker/3.png)
  从图中可以看出，系统终端将本地镜像列表中的3个镜像分5列进行了展示，每一列的具体含义如下。  
  ●REPOSITORY：镜像名称。  
  ●TAG：镜像的参数，类似于版本号，默认是latest。  
  ●IMAGE ID：镜像ID，是唯一值。此处看到的是一个长度为12的字符串，实际上它是64位完整镜像ID的缩写形式。  
  ●CREATED：距今创建镜像的时间。  
  ●SIZE：镜像大小。    

**2.搜索镜像**  
  想知道在Docker Hub中包含了哪些镜像，除了可以登录Docker Hub，在官网中心进行查看外，还可以直接在Docker客户端进行查询。例如想要查询Ubuntu镜像，可以使用如下指令。
```js
$ docker search ubuntu
```  
  执行上述指令后，系统终端就会将搜索到的有关Ubuntu的镜像展示出来，如下图所示。
![alt](/article_img/docker/4.png)
  从图所示的结果可以看出，系统终端分5列将搜索到的Ubuntu相关镜像都列举出来了，这5列的具体含义如下。  
  ●NAME：表示镜像的名称，这里有两种格式的名称，其中不带有“/”的表示官方镜像，而带有“/”的表示其他用户的公开镜像。公开镜像“/”前面是用户在Docker Hub上的用户名（唯一），后面是对应的镜像名；官方镜像与用户镜像，除了从镜像名称上可以区分外，还可以通过第4列的OFFICIAL声明中看出（该列下内容为OK表示官方镜像）。  
  ●DESCRIPTION：表示镜像的描述，这里只显示了一小部分。  
  ●STARS：表示该镜像的收藏数，用户可以在Docker Hub上对镜像进行收藏，一般可以通过该数字反应出该镜像的受欢迎程度。  
  ●OFFICIAL：表示是否为官方镜像。  
  ●AUTOMATED：表示是否自动构建镜像。例如，用户可以将自己的Docker Hub绑定到如Github上，当代码提交更新后，可以自动构建镜像。   
 
**3.拉取镜像**  
  通过docker pull指令可以拉取仓库镜像到本地（默认都是拉取Docker Hub仓库镜像，也可以指定“IP+端口”拉取某个Docker机器上的私有仓库镜像），具体使用方式如下。
```js
$ docker pull ubuntu
```  
  执行上述指令后，Docker会自动从Docker Hub上下载最新版本的Ubuntu到本地，当然也可以使用以下指令拉取指定版本的镜像到本地，具体指令如下。
```js
$ docker pull ubuntu:14.04
```  
**4.构建镜像**  
  除了可以通过docker pull指令从仓库拉取镜像外，还可以通过docker build指令构建Docker镜像，通常情况下都是通过Dockerfile文件来构建镜像的。  
  这里假设linux系统home目录下/shitou/workspace/dockerspace文件夹中编写有对应的Dockerfile文件，则构建镜像直立示例如下所示。 
```js
$ docker build -t hellodocker3 /home/shitou/workspace/dockerspace/.
```
**5.删除镜像**  
  当本地存放过多不需要的镜像时，可以通过docker rmi指令将其删除。在删除镜像时，需要指定镜像名称或镜像ID。删除镜像的使用方式如下。
```js
$ docker rmi -f hellodocker2 hellodocker3
```  
  上述指令中，docker rmi表示删除镜像，-f表示进行强制删除，而hellodocker2和hellodocker3分别表示需要删除的镜像名称，这里同时删除两个镜像。除了根据名称删除镜像外，还也可以根据镜像ID来删除镜像，只是这里如果指定了删除ID为23c617a866d4的镜像后，会同时删除hellodocker、hellodocker2和hellodocker3三个镜像。  
  需要特别强调的是，在进行镜像删除操作时，如果是通过镜像ID进行镜像删除，那么由该镜像创建的容器必须提前删除或停止。另外，在通过镜像名称操作镜像时，如果出现镜像重名的情况，必须在镜像名称后面指定镜像标签tag参数来确保唯一性。

**6.创建并启动容器**  
  Docker镜像主要用于创建容器，可以使用docker run指令创建并启动容器，具体使用方式如下。
```js
$ docker run -d -p 5000:80 --name test hellodocker
```  
  上述创建并启动容器的指令略微复杂，具体分析如下。  
  ●docker run：表示创建并启动一个容器，而后面的hellodocker就表示要启动运行的镜像名称；  
  ●-d：表示容器启动时在后台运行；  
  ●-p 5000:80：表示将容器内暴露的80端口映射到宿主机指定的5000端口，也可以将-p 5000:80更改为-P来映射主机的随机端口（注意p字母的大小写）；  
  ●--name test：表示为创建后的容器指定名称为test，如果没有该参数配置，则生成的容器会设置一个随机名称。  
  docker run命令是Docker操作中较为复杂的一个，它可以携带多个参数和参数，我们可以通过docker run --help指令进行查看，其中有些参数如-e、-v和-w等都可以在Dockerfile文件中预先声明。 
 
**7.列出容器**  
  生成容器后，可以通过docker ps指令查看当前运行的所有容器，具体使用方式如下。
```js
$ docker ps
```  
  执行上述命令后，会将所有当前运行的容器都展示出来，具体如下图所示。
![alt](/article_img/docker/5.png)
  从图中可以看出，系统终端通过7列对当前的正在运行的一个容器进行了展示，图中每一列的具体含义如下。  
  ●CONTAINER ID：表示生成的容器ID；  
  ●IMAGE：表示生成该容器的镜像名称；  
  ●COMMAND：表示启动容器时运行的命令，Docker要求在启动容器时必须运行一个命令；  
  ●CREATED：表示容器创建的时间；  
  ●STATUS：表示容器运行状态，例如Up表示运行中，Exited表示已停止；  
  ●PORTS：表示容器内部暴露的端口映射到主机的端口；  
  ●NAMES：表示生成容器的名称，由Docker引擎自动生成，可以像上述示例中使用--name参数指定生成容器的名称。  
  另外，docker ps指令运行过程中可以指定多个参数，还可以通过docker ps --help指令对ps指令的其他信息进行查看。

**8.删除容器**  
  当不需要使用容器时，则可以使用docker rm指令删除已停止的容器，具体使用方式如下。
```js
$ docker rm f0c9a8b6e8c5
```  
  需要注意的是，上述指令只能删除已经停止运行的容器，而不能删除正在运行的容器。如果想要删除正在运行的容器，则需要添加-f参数强制删除，具体使用方式如下。
```js
$ docker rm -f f0c9a8b6e8c5
```  
  当需要删除的容器过多时，如果还一个个的删除就略显麻烦了，此时可以通过如下指令将全部容器删除。
```js
$ docker rm -f $(docker ps -aq)
```  
  上述指令中，首先会通过$(docker ps -aq)获取所有容器的ID，然后通过docker rm -f指令进行强制删除。如果开发者有自己特殊的删除需求，可以根据前面docker ps指令进行组装来获取需要删除的容器ID。  
  Docker提供的操作指令远不止这些，这里就不一一列举了，想要了解更多Docker的操作指令，可以通过docker --help指令进行查看。


, 2018-12-05, null, 默认分类, Docker,客户端指令, true, null, 21, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [11, Docker数据管理介绍,   当我们对容器进行相关操作时，产生的一系列数据都会存储在容器中，而Docker内部又是如果管理这些数据的呢？本篇文章将针对Docker数据管理的一些知识进行介绍。
  
**1. Docker数据存储机制**  
  使用Docker时，我们操作的都是镜像和由镜像生成的容器，所以想要更好的了解Docker内部的数据存储机制，就必须从镜像、容器与数据存储的关系出发。  
  Docker镜像是通过读取Dockerfile文件中的指令构建的，Dockerfile中的每条指令都会创建一个镜像层，并且每层都是只读的，这一系列的镜像层就构成了Docker镜像。接下来以一个Dockerfile文件为例进行说明，具体如下列代码示例所示。
```js
 1	FROM ubuntu:16.04
 2	COPY . /app
 3	RUN make /app
 4	CMD python /app/app.py
```  
   上述文件示例中的Dockerfile包含了4条指令，每条指令都会创建一个镜像层，其中每一层与前一层都有所不同，并且是层层叠加的。通过镜像构建容器时，会在镜像层上增加一个容器层（即可写层），所有对容器的更改都会写入容器层，这也是Docker默认的数据存储方式。  
  下面通过一个效果图进行说明，具体如下图所示。
![alt](/article_img/docker/6.png)
  从图中可以看出，Docker容器和镜像之间的主要区别是顶部的容器层，而所有对容器中数据的添加、修改等操作都会被存储在容器层中。当容器被删除时，容器层也会被删除，其中存储的数据会被一同删除，而下面的镜像层却保持不变。  
  由于所有的容器都是通过镜像构建的，所以每个容器都有各自的容器层，对于容器数据的更改就会保存在各自的容器层中。也就是说，由同一个镜像构建的多个容器，它们会拥有相同的底部镜像层，而拥有不同的容器层，多个容器可以访问相同的镜像层，并且有自己的独立数据状态。具体说明如下图所示。 
![alt](/article_img/docker/7.png)
  从图中可以看出，基于同一个镜像构建的多个容器可以共享该镜像层，但是多个容器想要共享相同的数据，就需要将这些数据存储到容器之外的地方，而这种方式就是下一节要提到的Docker volume数据外部挂载机制。  

**2. Docker数据存储方式**    
  在默认情况下，Docker中的数据都是存放在容器层的，但是这样存储数据却有较多的缺陷，具体表现如下。    
  ●当容器不再运行时，容器中的数据无法持久化保存，如果另一个进程需要这些数据，那么将很难从容器中获取数据；  
  ●容器层与正在运行的主机紧密耦合，不能轻易地移动数据；  
  ●容器层需要一个存储驱动程序来管理文件系统，存储驱动程序提供了一个使用Linux内核的联合文件系统，这种额外的抽象化降低了性能。  
  基于上述种种原因，多数情况下Docker数据管理都不会直接将数据写入容器层，而是使用另一种叫做Docker volume数据外部挂载的机制进行数据管理。  
  针对Docker volume数据外部挂载机制，Docker提供了三种不同的方式将数据从容器映射到Docker宿主机，他们分别为：volumes（数据卷）、bind mounts（绑定挂载）和tmpfs mounts（tmpfs挂载）。这三种数据管理方式的具体选择，需要结合实际情况进行考虑，其中的volumes数据卷是最常用也是官方推荐的数据管理方式。无论选择使用哪种数据管理方式，数据在容器内看起来都一样的，而在容器外则会被被挂载到文件系统中的某个目录或文件中。    
  下面通过一张图来展示数据卷、绑定挂载和tmpfs挂载之间的差异，如下图所示。  
![alt](/article_img/docker/8.png)
  从图中可以看出，Docker提供的三种数据管理方式略有不同，具体分析如下。  
  ●volumes：存储在主机文件系统中（在Linux系统下是存在于/var/lib/Docker/volumes/目录），并由Docker管理，非Docker进程无法修改文件系统的这个部分。  
  ●bind mounts：可以存储在主机系统的任意位置，甚至可能是重要的系统文件或目录，在Docker主机或容器上的非Docker进程可以对他们进行任意修改。  
  ●tmpfs mounts：只存储在主机系统的内存中，并没有写入到主机的文件系统中。


, 2018-12-07, 2021-05-19, 默认分类, Docker,数据管理, true, null, 19, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [6, JDK 8——Lambda表达式介绍,   Lambda表达式是JDK 8中一个重要的新特性，它使用一个清晰简洁的表达式来表达一个接口，同时Lambda表达式也简化了对集合以及数组数据的遍历、过滤和提取等操作。下面，本篇文章就对Lambda表达式进行简要介绍，并进行演示说明。

**1. Lambda表达式入门**  

  匿名内部类存在的一个问题是，如果匿名内部类的实现非常简单，例如只包含一个抽象方法的接口，那么匿名内部类的语法仍然显得比较冗余。为此，JDK 8中新增了一个特性Lambda表达式，这种表达式只针对有一个抽象方法的接口实现，以简洁的表达式形式实现接口功能来作为方法参数。  
  一个Lambda表达式由三个部分组成，分别为参数列表、“->”和表达式主体，其语法格式如下：
```js
 ([数据类型 参数名,数据类型 参数名,...]) -> {表达式主体}
```  
  从上述语法格式上看，Lambda表达式的书写非常简单，下面针对Lambda表达式的组成部分进行简单介绍，具体如下：  
  （1）([数据类型 参数名,数据类型 参数名,...])：用来向表达式主体传递接口方法需要的参数，多个参数名中间必须用英文逗号“,”进行分隔；在编写Lambda表达式时，可以省略参数的数据类型，后面的表达式主体会自动进行校对和匹配；同时，如果只有一个参数，则可以省略括号“()”。  
  （2）->：表示Lambda表达式箭牌，用来指定参数数据指向，不能省略，且必须用英文横线和大于号书写。  
  （3）{表达式主体}：由单个表达式或语句块组成的主体，本质就是接口中抽象方法的具体实现，如果表达式主体只有一条语句，那么可以省略包含主体的大括号；另外，在Lambda表达式主体中允许有返回值，当只有一条return语句时，也可以省略return关键字。  
  了解了Lambda表达式的语法后，接下来编写一个示例文件对Lambda表达式的基本使用进行介绍，具体代码如下所示。
```js
 1	// 定义动物类接口
 2	interface Animal { 
 3		void shout(); // 定义方法shout()
 4	}
 5	public class Example22 {
 6		public static void main(String[] args) {
 7	       String name = "小花"; 
 8	       // 1、匿名内部类作为参数传递给animalShout()方法
 9		  animalShout(new Animal() { 
 10				 public void shout() { 
 11				    System.out.println("匿名内部类输出："+name+"喵喵...");
 12				}
 13		  });
 14		  // 2、使用Lambda表达式作为参数传递给animalShout()方法
 15	       animalShout(()-> System.out.println("Lambda表达式输出："
 16	                                                   +name+"喵喵..."));
 17		}
 18	    // 创建一个animalShout()静态方法，接收接口类型的参数
 19		public static void animalShout(Animal an) {
 20			an.shout();  
 21		}
 22	}
```  
  运行结果下图所示。
![alt](/article_img/lambda/1.jpg)
  上述代码示例中，先定义了只有一个抽象方法的接口Animal，然后分别使用匿名内部类和Lambda表达式的方式实现了接口方法。从图中可以看出，使用匿名内部类和Lambda表达式都能实现接口中方法，但很显然使用Lambda表达式更加简洁和清晰。, 2018-11-27, null, 默认分类, 2018,Lambda表达式, true, null, 18, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [7, 函数式接口, &emsp;&emsp;虽然Lambda表达式可以实现匿名内部类的功能，但在使用时却有一个局限，即接口中有且只有一个抽象方法时才能使用Lamdba表达式代替匿名内部类。这是因为Lamdba表达式是基于函数式接口实现的，所谓函数式接口是指有且仅有一个抽象方法的接口，Lambda表达式就是Java中函数式编程的体现，只有确保接口中有且仅有一个抽象方法，Lambda表达式才能顺利地推导出所实现的这个接口中的方法。  
&emsp;&emsp;在JDK 8中，专门为函数式接口引入了一个@FunctionalInterface注解，该注解只是显示的标注了接口是一个函数式接口，并强制编辑器进行更严格的检查，确保该接口是函数式接口，如果不是函数式接口，那么编译器就会报错，而对程序运行并没有实质上的影响。  
&emsp;&emsp;接下来通过一个案例来演示函数式接口的定义与使用，示例代码如下所示。
```js
 1	// 定义无参、无返回值的函数式接口
 2	@FunctionalInterface
 3	interface Animal {
 4		void shout();
 5	}
 6	// 定义有参、有返回值的函数式接口
 7	interface Calculate {
 8		int sum(int a, int b);
 9	}
 10	public class Example23 {
 11		public static void main(String[] args) {
 12		   // 分别两个函数式接口进行测试
 13		   animalShout(() -> System.out.println("无参、无返回值的函数式接口调用"));
 14		   showSum(10, 20, (x, y) -> x + y);
 15		}
 16		// 创建一个动物叫的方法，并传入接口对象Animal作为参数
 17		private static void animalShout(Animal animal) {
 18			animal.shout();
 19		}
 20		// 创建一个求和的方法，并传入两个int类型以及接口Calculate类型的参数
 21		private static void showSum(int x, int y, Calculate calculate) {
 22		   System.out.println(x + "+" + y + "的和为：" + calculate.sum(x, y));
 23		}
 24	}
```  
&emsp;&emsp;运行结果如下图所示。

![alt](/article_img/lambda/2.jpg)
&emsp;&emsp;上述代码示例中，先定义了两个函数式接口Animal和Calculate，然后在测试类中分别编写了两个静态方法，并将这两个函数式接口以参数的形式传入，最后在main()方法中分别调用这两个静态方法，并将所需要的函数式接口参数以Lambda表达式的形式传入。从图中可以看出，程序中函数式接口的定义和使用完全正确。
, 2018-12-01, null, 默认分类, 接口,函数式接口, true, null, 12, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20003} created. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20003} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20003} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20003} executed. 0.533 millis. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20003, rs-50003} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20003, rs-50003} Header: [count(0)]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20003, rs-50003} Result: [12]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20003, rs-50003} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20003} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20004} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20004} Parameters : [5]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20004} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20004} executed. 0.5703 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20004} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20005} created. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20005} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20005} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20005} executed. 0.5793 millis. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20005, rs-50005} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20005, rs-50005} Header: [count(0)]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20005, rs-50005} Result: [12]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20005, rs-50005} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20005} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20006} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20006} Parameters : [5]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20006} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20006} executed. 0.5565 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20006, rs-50006} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20006, rs-50006} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20006, rs-50006} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20006, rs-50006} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20006, rs-50006} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20006, rs-50006} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20006, rs-50006} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20006, rs-50006} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20006} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} connected
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} created. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} executed. 9.4331 millis. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Header: [count(0)]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [12]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} Parameters : [5]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} executed. 2.633 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} executed. 0.8016 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [12, Spring Boot 2 权威发布,   如果这两天登录 [https://start.spring.io/ ](https://start.spring.io/ )就会发现，Spring Boot 默认版本已经升到了 2.1.0。这是因为 Spring Boot 刚刚发布了 2.1.0 版本，我们来看下 Spring Boot 2 发布以来第一个子版本都发布了哪些内容？  

**2.1 中的新特性**     
  ●将spring-boot-starter-oauth2-oidc-client重命名为spring-boot-starter-oauth2-client命名更简洁  
  ●添加 OAuth2 资源服务 starter，OAuth2 一个用于认证的组件  
  ●支持 ConditionalOnBean 和 ConditionalOnMissingBean 下的参数化容器  
  ●自动配置 applicationTaskExecutor bean 的延迟加载来避免不必要的日志记录  
  ●将 DatabaseDriver＃SAP 重命名为 DatabaseDriver  
  ●跳过重启器不仅适用于 JUnit4，也适用于 JUnit5  
  ●在 Jest HealthIndicator 中使用集群端点  
  ●当 DevTools 禁用重启时添加日志输出  
  ●添加注解：@ConditionalOnMissingServletFilter提高 Servlet Filters 的自动装配。
  
**2.1 中的组件升级**  
  ●升级 Hibernate 5.3，Hibernate 的支持升级到了 5.3  
  ●升级 Tomcat 9 ，支持最新的 tomcat 9  
  ●支持 Java 11，Java 现在更新越来越快，Spring 快赶不上了    
  ●升级 Thymeleaf Extras Springsecurity 到 3.0.4.RELEASE ，thymeleaf-extras-springsecurity 是 Thymeleaf 提供集成 Spring Security 的组件  
  ●升级 Joda Time 2.10.1，Joda-Time， 面向 Java 应用程序的日期/时间库的替代选择，Joda-Time 令时间和日期值变得易于管理、操作和理解。  
  ●升级 Lettuce 5.1.2.RELEASE ，Lettuce 前面说过，传说中 Redis 最快的客户端。  
  ●升级 Reactor Californium-SR2 ，Californium 是物联网云服务的 Java COAP 实现。因此，它更专注的是可扩展性和可用性而不是像嵌入式设备那样关注资源效率。不过，Californium 也适合嵌入式的 JVM。  
  ●升级 Maven Failsafe Plugin 2.22.1 ，Maven 中的测试插件。  
  ●升级 Flyway 5.2.1 ， Flyway是一款开源的数据库版本管理工具  
  ●升级 Aspectj 1.9.2 ，AspectJ 是 Java 中流行的 AOP（Aspect-oriented Programming）编程扩展框架，是 Eclipse 托管给 Apache 基金会的一个开源项目。  
  ●升级 Mysql 8.0.13 ，Mysql 支持到 8。  
  ●...  
  更多的详细内容可以参考这里：[Spring Boot 2.1 Release Notes](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.1-Release-Notes)
, 2018-12-12, 2021-05-21, 默认分类, Spring Boot 2, true, null, 62, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [8, JDK 8——聚合操作, &emsp;&emsp;在Java8版本中，JDK包含许多聚合操作（如平均值，总和，最小，最大，和计数），返回一个计算流stream的聚合结果。这些聚合操作被称为聚合操作。JDK除返回单个值的聚合操作外，还有很多聚合操作返回一个collection集合实例。很多的reduce操作执行特定的任务，如求平均值或按类别分组元素。  

**1. 聚合操作简介**

  在开发中，多数情况下会涉及到对集合、数组中元素的操作，在JDK 8之前都是通过普通的循环遍历出每一个元素，然后还会穿插一些if条件语句选择性的对元素进行查找、过滤、修改等操作，这种原始的操作方法虽然可行，但是代码量较大并且执行效率较低。  
  为此，JDK 8中新增了一个Stream接口，该接口可以将集合、数组的中的元素转换为Stream流的形式，并结合Lambda表达式的优势来进一步简化集合、数组中元素的查找、过滤、转换等操作，这一新功能就是JDK 8中的聚合操作。  
  在程序中，使用聚合操作没有绝对的语法规范，根据实际操作流程，主要可以分为以下3个步骤：  
  （1）将原始集合或者数组对象转换为Stream流对象；  
  （2）对Stream流对象中的元素进行一系列的过滤、查找等中间操作（Intermediate Operations），然后仍然返回一个Stream流对象；  
  （3）对Stream流进行遍历、统计、收集等终结操作（Terminal Operation），获取想要的结果。  
  接下来，就根据上面聚合操作的3个步骤，通过一个案例来演示聚合操作的基本用法，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example31 {
 4		public static void main(String[] args) {
 5	          // 创建一个List集合对象
 6			List<String> list = new ArrayList<>(); 
 7			list.add("张三");
 8			list.add("李四");
 9			list.add("张小明");
 10			list.add("张阳");
 11			// 1、创建一个Stream流对象
 12			Stream<String> stream = list.stream();
 13			// 2、对Stream流中的元素分别进行过滤、截取操作
 14		       Stream<String> stream2 = stream.filter(i -> i.startsWith("张"));
 15			Stream<String> stream3 = stream2.limit(2);
 16			// 3、对Stream流中的元素进行终结操作，进行遍历输出
 17			stream3.forEach(j -> System.out.println(j));
 18			System.out.println("=======");
 19	         // 通过链式表达式的形式完成聚合操作
 20			list.stream().filter(i -> i.startsWith("张"))
 21						 .limit(2)
 22						 .forEach(j -> System.out.println(j));
 23		}
 24	}
``` 
   运行结果如下图所示。
![alt](/article_img/lambda/3.jpg)
  上述示例代码中，先创建了一个List集合，然后根据聚合操作的3个步骤实现了集合对象的聚合操作，对集合中的元素使用Stream流的形式进行过滤（filter）、截取（limit），并进行遍历输出。其中第12~17行代码分步骤详细展示了聚合操作，而第20~22行代码是使用了链式表达式（调用有返回值的方法时不获取返回值而是直接再调用另一个方法）实现了聚合操作，该表达式的语法格式更简洁、高效，这种链式调用也被称为操作管道流。

**2. 创建Stream流对象**  
  在上一小节中，介绍了聚合操作的主要使用步骤，其中首要解决的问题就是创建Stream流对象。聚合操作针对的就是可迭代数据进行的操作，如集合、数组等，所以创建Stream流对象其实就是将集合、数组等通过一些方法转换为Stream流对象。  
  在Java中，集合对象有对应的集合类，可以通过集合类提供的静态方法创建Stream流对象，而数组数据却没有对应的数组类，所以必须通过其他方法创建Stream流对象。针对不同的源数据，Java提供了多种创建Stream流对象的方式，分别如下：  
  （1）所有的Collections集合都可以使用stream()静态方法获取Stream流对象；  
  （2）Stream接口的of()静态方法可以获取基本类型包装类数组、引用类型数组和单个元素的Stream流对象；  
  （3）Arrays数组工具类的stream()静态方法也可以获取数组元素的Stream流对象。  
  接下来，通过一个案例来学习聚合操作中如何创建Stream流对象，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example32 {
 4		public static void main(String[] args) {
 5	          // 创建一个数组
 6			Integer[] array = { 9, 8, 3, 5, 2 };       
 7	          // 将数组转换为List集合
 8			List<Integer> list = Arrays.asList(array); 
 9			// 1、使用集合对象的stream()静态方法创建Stream流对象
 10			Stream<Integer> stream = list.stream();
 11			stream.forEach(i -> System.out.print(i+" "));
 12			System.out.println();
 13			// 2、使用Stream接口的of()静态方法创建Stream流对象
 14			Stream<Integer> stream2 = Stream.of(array);
 15			stream2.forEach(i -> System.out.print(i+" "));
 16			System.out.println();
 17			// 3、使用Arrays数组工具类的stream()静态方法创建Stream流对象
 18			Stream<Integer> stream3 = Arrays.stream(array);
 19			stream3.forEach(i -> System.out.print(i+" "));
 20		}
 21	}
```  
  运行结果如下图所示。
![alt](/article_img/lambda/4.jpg)
  上述示例代码中，先创建了一个数组和一个集合，然后通过三种方式实现了Stream流对象的创建，并通过Stream流对象的forEach()方法结合Lambda表达式完成了集合和数组中元素的遍历。  

**小提示：**  
  在JDK 8中，只针对单列集合Collections接口对象提供了stream()静态方法获取Stream流对象，并未对Map集合提供相关方法获取Stream流对象，所以想要用Map集合创建Stream流对象必须先通过Map集合的keySet()、values()、entrySet()等方法将Map集合转换为单列Set集合，然后再使用单列集合的stream()静态方法获取对应键、值集合的Stream流对象。

, 2018-12-02, null, 默认分类, JDK 8,聚合操作, true, null, 36, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [9, 虚拟化容器技术——Docker运行机制介绍,   Docker是一个开源的应用容器引擎，它基于go语言开发，并遵从Apache2.0开源协议。使用Docker可以让开发者封装他们的应用以及依赖包到一个可移植的容器中，然后发布到任意的Linux机器上，也可以实现虚拟化。Docker容器完全使用沙箱机制，相互之间不会有任何接口，这保证了容器之间的安全性。  

**1. Docker的引擎介绍**

  Docker Engine（Docker引擎）是Docker的核心部分，使用的是客户端-服务器（C/S）架构模式，其主要组成部分如下图所示。
![alt](/article_img/docker/1.png)
  从上图可以看出，Docker Engine中包含了三个核心组件（docker CLI、REST API和docker daemon），这三个组件的具体说明如下：  
  ①docker CLI（command line interface）：表示Docker命令行接口，开发者可以在命令行中使用Docker相关指令与Docker守护进程进行交互，从而管理诸如image（镜像）、container（容器）、network（网络）和data volumes（数据卷）等实体。  
  ②REST API：表示应用程序API接口，开发者通过该API接口可以与Docker的守护进程进行交互，从而指示后台进行相关操作。  
  ③docker daemon：表示Docker的服务端组件，他是Docker架构中运行在后台的一个守护进程，可以接收并处理来自命令行接口及API接口的指令，然后进行相应的后台操作。  
  对于开发者而言，既可以使用编写好的脚本文件通过REST API来实现与Docker进程交互，又可以直接使用Docker相关指令通过命令行接口来与Docker进程交互，而其他一些Docker应用则是通过底层的API和CLI进行交互的。

**2. Docker的架构介绍**

  了解了Docker内部引擎及作用后，我们还需要通过Docker的具体架构，来了解Docker的整个运行流程。接下来借助Docker官网的架构图来对Docker架构进行详细说明，如下图所示。
![alt](/article_img/docker/2.jpg)
  从图中可以看出，Docker架构主要包括Client、DOCKER_HOST和Register三部分，关于这三部分的具体说明如下。  
&emsp;&emsp;**（1）Client（客户端）**  
  Client即Docker客户端，也就是上一小节Docker Engine中介绍的docker CLI。开发者通过这个客户端使用Docker的相关指令与Docker守护进程进行交互，从而进行Docker镜像的创建、拉取和运行等操作。  
&emsp;&emsp;**（2）DOCKER_HOST（Docker主机）**  
  DOCKER_HOST即Docker内部引擎运行的主机，主要指Docker daemon（Docker守护进程）。可以通过Docker守护进程与客户端还有Docker的镜像仓库Registry进行交互，从而管理Images（镜像）和Containers（容器）等。  
&emsp;&emsp;**（3）Registry（注册中心）**  
  Registry即Docker注册中心，实质就是Docker镜像仓库，默认使用的是Docker官方远程注册中心Docker Hub，也可以使用开发者搭建的本地仓库。Registry中包含了大量的镜像，这些镜像可以是官网基础镜像，也可以是其他开发者上传的镜像。  
  我们在实际使用Docker时，除了会涉及到图中的三个主要部分外，还会涉及到很多Docker Objects（Docker对象），例如Images（镜像）、Containers（容器）、Networks（网络）、Volumes（数据卷）、Plugins（插件）等。其中常用的两个对象Image和Containers的说明如下。  
  ①Images（镜像）  
  Docker 镜像就是一个只读的模板，包含了一些创建Docker容器的操作指令。通常情况下，一个Docker镜像是基于另一个基础镜像创建的，并且新创建的镜像会额外包含一些功能配置。例如：开发者可以依赖于一个Ubuntu的基础镜像创建一个新镜像，并可以在新镜像中安装Apache等软件或其它应用程序。  
  ②Containers（容器）  
  Docker容器属于镜像的一个可运行实例（镜像与容器的关系其实与Java中的类与对象相似），开发者可以通过API接口或者CLI命令行接口来创建、运行、停止、移动、删除一个容器，也可以将一个容器连接到一个或多个网络中，将数据存储与容器进行关联。



, 2018-12-03, null, 默认分类, 虚拟化容器,Docker,运行机制, true, null, 26, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [10, Docker常用客户端指令介绍,   在使用Docker之前，首先会为对应的项目编写Dockerfile镜像构建文件，然后通过Docker的相关指令进行镜像构建，完成镜像的构建后，就可以使用这些项目镜像进行启动测试了。所以要想知道如何使用Docker来执行这些Dockerfile镜像构建文件，还需要学习Docker客户端的常用指令，本篇文章将对Docker客户端的常用指令进行详细讲解。  

**1.列出镜像**  
  通过docker images指令可以查看本地镜像列表中已有的镜像，具体使用方式如下。
```js
$ docker images
```  
  执行上述指令后，系统会将所有本地镜像都展示出来，如下图所示。
![alt](/article_img/docker/3.png)
  从图中可以看出，系统终端将本地镜像列表中的3个镜像分5列进行了展示，每一列的具体含义如下。  
  ●REPOSITORY：镜像名称。  
  ●TAG：镜像的参数，类似于版本号，默认是latest。  
  ●IMAGE ID：镜像ID，是唯一值。此处看到的是一个长度为12的字符串，实际上它是64位完整镜像ID的缩写形式。  
  ●CREATED：距今创建镜像的时间。  
  ●SIZE：镜像大小。    

**2.搜索镜像**  
  想知道在Docker Hub中包含了哪些镜像，除了可以登录Docker Hub，在官网中心进行查看外，还可以直接在Docker客户端进行查询。例如想要查询Ubuntu镜像，可以使用如下指令。
```js
$ docker search ubuntu
```  
  执行上述指令后，系统终端就会将搜索到的有关Ubuntu的镜像展示出来，如下图所示。
![alt](/article_img/docker/4.png)
  从图所示的结果可以看出，系统终端分5列将搜索到的Ubuntu相关镜像都列举出来了，这5列的具体含义如下。  
  ●NAME：表示镜像的名称，这里有两种格式的名称，其中不带有“/”的表示官方镜像，而带有“/”的表示其他用户的公开镜像。公开镜像“/”前面是用户在Docker Hub上的用户名（唯一），后面是对应的镜像名；官方镜像与用户镜像，除了从镜像名称上可以区分外，还可以通过第4列的OFFICIAL声明中看出（该列下内容为OK表示官方镜像）。  
  ●DESCRIPTION：表示镜像的描述，这里只显示了一小部分。  
  ●STARS：表示该镜像的收藏数，用户可以在Docker Hub上对镜像进行收藏，一般可以通过该数字反应出该镜像的受欢迎程度。  
  ●OFFICIAL：表示是否为官方镜像。  
  ●AUTOMATED：表示是否自动构建镜像。例如，用户可以将自己的Docker Hub绑定到如Github上，当代码提交更新后，可以自动构建镜像。   
 
**3.拉取镜像**  
  通过docker pull指令可以拉取仓库镜像到本地（默认都是拉取Docker Hub仓库镜像，也可以指定“IP+端口”拉取某个Docker机器上的私有仓库镜像），具体使用方式如下。
```js
$ docker pull ubuntu
```  
  执行上述指令后，Docker会自动从Docker Hub上下载最新版本的Ubuntu到本地，当然也可以使用以下指令拉取指定版本的镜像到本地，具体指令如下。
```js
$ docker pull ubuntu:14.04
```  
**4.构建镜像**  
  除了可以通过docker pull指令从仓库拉取镜像外，还可以通过docker build指令构建Docker镜像，通常情况下都是通过Dockerfile文件来构建镜像的。  
  这里假设linux系统home目录下/shitou/workspace/dockerspace文件夹中编写有对应的Dockerfile文件，则构建镜像直立示例如下所示。 
```js
$ docker build -t hellodocker3 /home/shitou/workspace/dockerspace/.
```
**5.删除镜像**  
  当本地存放过多不需要的镜像时，可以通过docker rmi指令将其删除。在删除镜像时，需要指定镜像名称或镜像ID。删除镜像的使用方式如下。
```js
$ docker rmi -f hellodocker2 hellodocker3
```  
  上述指令中，docker rmi表示删除镜像，-f表示进行强制删除，而hellodocker2和hellodocker3分别表示需要删除的镜像名称，这里同时删除两个镜像。除了根据名称删除镜像外，还也可以根据镜像ID来删除镜像，只是这里如果指定了删除ID为23c617a866d4的镜像后，会同时删除hellodocker、hellodocker2和hellodocker3三个镜像。  
  需要特别强调的是，在进行镜像删除操作时，如果是通过镜像ID进行镜像删除，那么由该镜像创建的容器必须提前删除或停止。另外，在通过镜像名称操作镜像时，如果出现镜像重名的情况，必须在镜像名称后面指定镜像标签tag参数来确保唯一性。

**6.创建并启动容器**  
  Docker镜像主要用于创建容器，可以使用docker run指令创建并启动容器，具体使用方式如下。
```js
$ docker run -d -p 5000:80 --name test hellodocker
```  
  上述创建并启动容器的指令略微复杂，具体分析如下。  
  ●docker run：表示创建并启动一个容器，而后面的hellodocker就表示要启动运行的镜像名称；  
  ●-d：表示容器启动时在后台运行；  
  ●-p 5000:80：表示将容器内暴露的80端口映射到宿主机指定的5000端口，也可以将-p 5000:80更改为-P来映射主机的随机端口（注意p字母的大小写）；  
  ●--name test：表示为创建后的容器指定名称为test，如果没有该参数配置，则生成的容器会设置一个随机名称。  
  docker run命令是Docker操作中较为复杂的一个，它可以携带多个参数和参数，我们可以通过docker run --help指令进行查看，其中有些参数如-e、-v和-w等都可以在Dockerfile文件中预先声明。 
 
**7.列出容器**  
  生成容器后，可以通过docker ps指令查看当前运行的所有容器，具体使用方式如下。
```js
$ docker ps
```  
  执行上述命令后，会将所有当前运行的容器都展示出来，具体如下图所示。
![alt](/article_img/docker/5.png)
  从图中可以看出，系统终端通过7列对当前的正在运行的一个容器进行了展示，图中每一列的具体含义如下。  
  ●CONTAINER ID：表示生成的容器ID；  
  ●IMAGE：表示生成该容器的镜像名称；  
  ●COMMAND：表示启动容器时运行的命令，Docker要求在启动容器时必须运行一个命令；  
  ●CREATED：表示容器创建的时间；  
  ●STATUS：表示容器运行状态，例如Up表示运行中，Exited表示已停止；  
  ●PORTS：表示容器内部暴露的端口映射到主机的端口；  
  ●NAMES：表示生成容器的名称，由Docker引擎自动生成，可以像上述示例中使用--name参数指定生成容器的名称。  
  另外，docker ps指令运行过程中可以指定多个参数，还可以通过docker ps --help指令对ps指令的其他信息进行查看。

**8.删除容器**  
  当不需要使用容器时，则可以使用docker rm指令删除已停止的容器，具体使用方式如下。
```js
$ docker rm f0c9a8b6e8c5
```  
  需要注意的是，上述指令只能删除已经停止运行的容器，而不能删除正在运行的容器。如果想要删除正在运行的容器，则需要添加-f参数强制删除，具体使用方式如下。
```js
$ docker rm -f f0c9a8b6e8c5
```  
  当需要删除的容器过多时，如果还一个个的删除就略显麻烦了，此时可以通过如下指令将全部容器删除。
```js
$ docker rm -f $(docker ps -aq)
```  
  上述指令中，首先会通过$(docker ps -aq)获取所有容器的ID，然后通过docker rm -f指令进行强制删除。如果开发者有自己特殊的删除需求，可以根据前面docker ps指令进行组装来获取需要删除的容器ID。  
  Docker提供的操作指令远不止这些，这里就不一一列举了，想要了解更多Docker的操作指令，可以通过docker --help指令进行查看。


, 2018-12-05, null, 默认分类, Docker,客户端指令, true, null, 21, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [11, Docker数据管理介绍,   当我们对容器进行相关操作时，产生的一系列数据都会存储在容器中，而Docker内部又是如果管理这些数据的呢？本篇文章将针对Docker数据管理的一些知识进行介绍。
  
**1. Docker数据存储机制**  
  使用Docker时，我们操作的都是镜像和由镜像生成的容器，所以想要更好的了解Docker内部的数据存储机制，就必须从镜像、容器与数据存储的关系出发。  
  Docker镜像是通过读取Dockerfile文件中的指令构建的，Dockerfile中的每条指令都会创建一个镜像层，并且每层都是只读的，这一系列的镜像层就构成了Docker镜像。接下来以一个Dockerfile文件为例进行说明，具体如下列代码示例所示。
```js
 1	FROM ubuntu:16.04
 2	COPY . /app
 3	RUN make /app
 4	CMD python /app/app.py
```  
   上述文件示例中的Dockerfile包含了4条指令，每条指令都会创建一个镜像层，其中每一层与前一层都有所不同，并且是层层叠加的。通过镜像构建容器时，会在镜像层上增加一个容器层（即可写层），所有对容器的更改都会写入容器层，这也是Docker默认的数据存储方式。  
  下面通过一个效果图进行说明，具体如下图所示。
![alt](/article_img/docker/6.png)
  从图中可以看出，Docker容器和镜像之间的主要区别是顶部的容器层，而所有对容器中数据的添加、修改等操作都会被存储在容器层中。当容器被删除时，容器层也会被删除，其中存储的数据会被一同删除，而下面的镜像层却保持不变。  
  由于所有的容器都是通过镜像构建的，所以每个容器都有各自的容器层，对于容器数据的更改就会保存在各自的容器层中。也就是说，由同一个镜像构建的多个容器，它们会拥有相同的底部镜像层，而拥有不同的容器层，多个容器可以访问相同的镜像层，并且有自己的独立数据状态。具体说明如下图所示。 
![alt](/article_img/docker/7.png)
  从图中可以看出，基于同一个镜像构建的多个容器可以共享该镜像层，但是多个容器想要共享相同的数据，就需要将这些数据存储到容器之外的地方，而这种方式就是下一节要提到的Docker volume数据外部挂载机制。  

**2. Docker数据存储方式**    
  在默认情况下，Docker中的数据都是存放在容器层的，但是这样存储数据却有较多的缺陷，具体表现如下。    
  ●当容器不再运行时，容器中的数据无法持久化保存，如果另一个进程需要这些数据，那么将很难从容器中获取数据；  
  ●容器层与正在运行的主机紧密耦合，不能轻易地移动数据；  
  ●容器层需要一个存储驱动程序来管理文件系统，存储驱动程序提供了一个使用Linux内核的联合文件系统，这种额外的抽象化降低了性能。  
  基于上述种种原因，多数情况下Docker数据管理都不会直接将数据写入容器层，而是使用另一种叫做Docker volume数据外部挂载的机制进行数据管理。  
  针对Docker volume数据外部挂载机制，Docker提供了三种不同的方式将数据从容器映射到Docker宿主机，他们分别为：volumes（数据卷）、bind mounts（绑定挂载）和tmpfs mounts（tmpfs挂载）。这三种数据管理方式的具体选择，需要结合实际情况进行考虑，其中的volumes数据卷是最常用也是官方推荐的数据管理方式。无论选择使用哪种数据管理方式，数据在容器内看起来都一样的，而在容器外则会被被挂载到文件系统中的某个目录或文件中。    
  下面通过一张图来展示数据卷、绑定挂载和tmpfs挂载之间的差异，如下图所示。  
![alt](/article_img/docker/8.png)
  从图中可以看出，Docker提供的三种数据管理方式略有不同，具体分析如下。  
  ●volumes：存储在主机文件系统中（在Linux系统下是存在于/var/lib/Docker/volumes/目录），并由Docker管理，非Docker进程无法修改文件系统的这个部分。  
  ●bind mounts：可以存储在主机系统的任意位置，甚至可能是重要的系统文件或目录，在Docker主机或容器上的非Docker进程可以对他们进行任意修改。  
  ●tmpfs mounts：只存储在主机系统的内存中，并没有写入到主机的文件系统中。


, 2018-12-07, 2021-05-19, 默认分类, Docker,数据管理, true, null, 19, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [6, JDK 8——Lambda表达式介绍,   Lambda表达式是JDK 8中一个重要的新特性，它使用一个清晰简洁的表达式来表达一个接口，同时Lambda表达式也简化了对集合以及数组数据的遍历、过滤和提取等操作。下面，本篇文章就对Lambda表达式进行简要介绍，并进行演示说明。

**1. Lambda表达式入门**  

  匿名内部类存在的一个问题是，如果匿名内部类的实现非常简单，例如只包含一个抽象方法的接口，那么匿名内部类的语法仍然显得比较冗余。为此，JDK 8中新增了一个特性Lambda表达式，这种表达式只针对有一个抽象方法的接口实现，以简洁的表达式形式实现接口功能来作为方法参数。  
  一个Lambda表达式由三个部分组成，分别为参数列表、“->”和表达式主体，其语法格式如下：
```js
 ([数据类型 参数名,数据类型 参数名,...]) -> {表达式主体}
```  
  从上述语法格式上看，Lambda表达式的书写非常简单，下面针对Lambda表达式的组成部分进行简单介绍，具体如下：  
  （1）([数据类型 参数名,数据类型 参数名,...])：用来向表达式主体传递接口方法需要的参数，多个参数名中间必须用英文逗号“,”进行分隔；在编写Lambda表达式时，可以省略参数的数据类型，后面的表达式主体会自动进行校对和匹配；同时，如果只有一个参数，则可以省略括号“()”。  
  （2）->：表示Lambda表达式箭牌，用来指定参数数据指向，不能省略，且必须用英文横线和大于号书写。  
  （3）{表达式主体}：由单个表达式或语句块组成的主体，本质就是接口中抽象方法的具体实现，如果表达式主体只有一条语句，那么可以省略包含主体的大括号；另外，在Lambda表达式主体中允许有返回值，当只有一条return语句时，也可以省略return关键字。  
  了解了Lambda表达式的语法后，接下来编写一个示例文件对Lambda表达式的基本使用进行介绍，具体代码如下所示。
```js
 1	// 定义动物类接口
 2	interface Animal { 
 3		void shout(); // 定义方法shout()
 4	}
 5	public class Example22 {
 6		public static void main(String[] args) {
 7	       String name = "小花"; 
 8	       // 1、匿名内部类作为参数传递给animalShout()方法
 9		  animalShout(new Animal() { 
 10				 public void shout() { 
 11				    System.out.println("匿名内部类输出："+name+"喵喵...");
 12				}
 13		  });
 14		  // 2、使用Lambda表达式作为参数传递给animalShout()方法
 15	       animalShout(()-> System.out.println("Lambda表达式输出："
 16	                                                   +name+"喵喵..."));
 17		}
 18	    // 创建一个animalShout()静态方法，接收接口类型的参数
 19		public static void animalShout(Animal an) {
 20			an.shout();  
 21		}
 22	}
```  
  运行结果下图所示。
![alt](/article_img/lambda/1.jpg)
  上述代码示例中，先定义了只有一个抽象方法的接口Animal，然后分别使用匿名内部类和Lambda表达式的方式实现了接口方法。从图中可以看出，使用匿名内部类和Lambda表达式都能实现接口中方法，但很显然使用Lambda表达式更加简洁和清晰。, 2018-11-27, null, 默认分类, 2018,Lambda表达式, true, null, 18, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [7, 函数式接口, &emsp;&emsp;虽然Lambda表达式可以实现匿名内部类的功能，但在使用时却有一个局限，即接口中有且只有一个抽象方法时才能使用Lamdba表达式代替匿名内部类。这是因为Lamdba表达式是基于函数式接口实现的，所谓函数式接口是指有且仅有一个抽象方法的接口，Lambda表达式就是Java中函数式编程的体现，只有确保接口中有且仅有一个抽象方法，Lambda表达式才能顺利地推导出所实现的这个接口中的方法。  
&emsp;&emsp;在JDK 8中，专门为函数式接口引入了一个@FunctionalInterface注解，该注解只是显示的标注了接口是一个函数式接口，并强制编辑器进行更严格的检查，确保该接口是函数式接口，如果不是函数式接口，那么编译器就会报错，而对程序运行并没有实质上的影响。  
&emsp;&emsp;接下来通过一个案例来演示函数式接口的定义与使用，示例代码如下所示。
```js
 1	// 定义无参、无返回值的函数式接口
 2	@FunctionalInterface
 3	interface Animal {
 4		void shout();
 5	}
 6	// 定义有参、有返回值的函数式接口
 7	interface Calculate {
 8		int sum(int a, int b);
 9	}
 10	public class Example23 {
 11		public static void main(String[] args) {
 12		   // 分别两个函数式接口进行测试
 13		   animalShout(() -> System.out.println("无参、无返回值的函数式接口调用"));
 14		   showSum(10, 20, (x, y) -> x + y);
 15		}
 16		// 创建一个动物叫的方法，并传入接口对象Animal作为参数
 17		private static void animalShout(Animal animal) {
 18			animal.shout();
 19		}
 20		// 创建一个求和的方法，并传入两个int类型以及接口Calculate类型的参数
 21		private static void showSum(int x, int y, Calculate calculate) {
 22		   System.out.println(x + "+" + y + "的和为：" + calculate.sum(x, y));
 23		}
 24	}
```  
&emsp;&emsp;运行结果如下图所示。

![alt](/article_img/lambda/2.jpg)
&emsp;&emsp;上述代码示例中，先定义了两个函数式接口Animal和Calculate，然后在测试类中分别编写了两个静态方法，并将这两个函数式接口以参数的形式传入，最后在main()方法中分别调用这两个静态方法，并将所需要的函数式接口参数以Lambda表达式的形式传入。从图中可以看出，程序中函数式接口的定义和使用完全正确。
, 2018-12-01, null, 默认分类, 接口,函数式接口, true, null, 12, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} connected
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} created. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} executed. 15.5369 millis. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Header: [count(0)]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [12]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} Parameters : [5]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} executed. 1.3864 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} executed. 0.8305 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [12, Spring Boot 2 权威发布,   如果这两天登录 [https://start.spring.io/ ](https://start.spring.io/ )就会发现，Spring Boot 默认版本已经升到了 2.1.0。这是因为 Spring Boot 刚刚发布了 2.1.0 版本，我们来看下 Spring Boot 2 发布以来第一个子版本都发布了哪些内容？  

**2.1 中的新特性**     
  ●将spring-boot-starter-oauth2-oidc-client重命名为spring-boot-starter-oauth2-client命名更简洁  
  ●添加 OAuth2 资源服务 starter，OAuth2 一个用于认证的组件  
  ●支持 ConditionalOnBean 和 ConditionalOnMissingBean 下的参数化容器  
  ●自动配置 applicationTaskExecutor bean 的延迟加载来避免不必要的日志记录  
  ●将 DatabaseDriver＃SAP 重命名为 DatabaseDriver  
  ●跳过重启器不仅适用于 JUnit4，也适用于 JUnit5  
  ●在 Jest HealthIndicator 中使用集群端点  
  ●当 DevTools 禁用重启时添加日志输出  
  ●添加注解：@ConditionalOnMissingServletFilter提高 Servlet Filters 的自动装配。
  
**2.1 中的组件升级**  
  ●升级 Hibernate 5.3，Hibernate 的支持升级到了 5.3  
  ●升级 Tomcat 9 ，支持最新的 tomcat 9  
  ●支持 Java 11，Java 现在更新越来越快，Spring 快赶不上了    
  ●升级 Thymeleaf Extras Springsecurity 到 3.0.4.RELEASE ，thymeleaf-extras-springsecurity 是 Thymeleaf 提供集成 Spring Security 的组件  
  ●升级 Joda Time 2.10.1，Joda-Time， 面向 Java 应用程序的日期/时间库的替代选择，Joda-Time 令时间和日期值变得易于管理、操作和理解。  
  ●升级 Lettuce 5.1.2.RELEASE ，Lettuce 前面说过，传说中 Redis 最快的客户端。  
  ●升级 Reactor Californium-SR2 ，Californium 是物联网云服务的 Java COAP 实现。因此，它更专注的是可扩展性和可用性而不是像嵌入式设备那样关注资源效率。不过，Californium 也适合嵌入式的 JVM。  
  ●升级 Maven Failsafe Plugin 2.22.1 ，Maven 中的测试插件。  
  ●升级 Flyway 5.2.1 ， Flyway是一款开源的数据库版本管理工具  
  ●升级 Aspectj 1.9.2 ，AspectJ 是 Java 中流行的 AOP（Aspect-oriented Programming）编程扩展框架，是 Eclipse 托管给 Apache 基金会的一个开源项目。  
  ●升级 Mysql 8.0.13 ，Mysql 支持到 8。  
  ●...  
  更多的详细内容可以参考这里：[Spring Boot 2.1 Release Notes](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.1-Release-Notes)
, 2018-12-12, 2021-05-21, 默认分类, Spring Boot 2, true, null, 62, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [8, JDK 8——聚合操作, &emsp;&emsp;在Java8版本中，JDK包含许多聚合操作（如平均值，总和，最小，最大，和计数），返回一个计算流stream的聚合结果。这些聚合操作被称为聚合操作。JDK除返回单个值的聚合操作外，还有很多聚合操作返回一个collection集合实例。很多的reduce操作执行特定的任务，如求平均值或按类别分组元素。  

**1. 聚合操作简介**

  在开发中，多数情况下会涉及到对集合、数组中元素的操作，在JDK 8之前都是通过普通的循环遍历出每一个元素，然后还会穿插一些if条件语句选择性的对元素进行查找、过滤、修改等操作，这种原始的操作方法虽然可行，但是代码量较大并且执行效率较低。  
  为此，JDK 8中新增了一个Stream接口，该接口可以将集合、数组的中的元素转换为Stream流的形式，并结合Lambda表达式的优势来进一步简化集合、数组中元素的查找、过滤、转换等操作，这一新功能就是JDK 8中的聚合操作。  
  在程序中，使用聚合操作没有绝对的语法规范，根据实际操作流程，主要可以分为以下3个步骤：  
  （1）将原始集合或者数组对象转换为Stream流对象；  
  （2）对Stream流对象中的元素进行一系列的过滤、查找等中间操作（Intermediate Operations），然后仍然返回一个Stream流对象；  
  （3）对Stream流进行遍历、统计、收集等终结操作（Terminal Operation），获取想要的结果。  
  接下来，就根据上面聚合操作的3个步骤，通过一个案例来演示聚合操作的基本用法，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example31 {
 4		public static void main(String[] args) {
 5	          // 创建一个List集合对象
 6			List<String> list = new ArrayList<>(); 
 7			list.add("张三");
 8			list.add("李四");
 9			list.add("张小明");
 10			list.add("张阳");
 11			// 1、创建一个Stream流对象
 12			Stream<String> stream = list.stream();
 13			// 2、对Stream流中的元素分别进行过滤、截取操作
 14		       Stream<String> stream2 = stream.filter(i -> i.startsWith("张"));
 15			Stream<String> stream3 = stream2.limit(2);
 16			// 3、对Stream流中的元素进行终结操作，进行遍历输出
 17			stream3.forEach(j -> System.out.println(j));
 18			System.out.println("=======");
 19	         // 通过链式表达式的形式完成聚合操作
 20			list.stream().filter(i -> i.startsWith("张"))
 21						 .limit(2)
 22						 .forEach(j -> System.out.println(j));
 23		}
 24	}
``` 
   运行结果如下图所示。
![alt](/article_img/lambda/3.jpg)
  上述示例代码中，先创建了一个List集合，然后根据聚合操作的3个步骤实现了集合对象的聚合操作，对集合中的元素使用Stream流的形式进行过滤（filter）、截取（limit），并进行遍历输出。其中第12~17行代码分步骤详细展示了聚合操作，而第20~22行代码是使用了链式表达式（调用有返回值的方法时不获取返回值而是直接再调用另一个方法）实现了聚合操作，该表达式的语法格式更简洁、高效，这种链式调用也被称为操作管道流。

**2. 创建Stream流对象**  
  在上一小节中，介绍了聚合操作的主要使用步骤，其中首要解决的问题就是创建Stream流对象。聚合操作针对的就是可迭代数据进行的操作，如集合、数组等，所以创建Stream流对象其实就是将集合、数组等通过一些方法转换为Stream流对象。  
  在Java中，集合对象有对应的集合类，可以通过集合类提供的静态方法创建Stream流对象，而数组数据却没有对应的数组类，所以必须通过其他方法创建Stream流对象。针对不同的源数据，Java提供了多种创建Stream流对象的方式，分别如下：  
  （1）所有的Collections集合都可以使用stream()静态方法获取Stream流对象；  
  （2）Stream接口的of()静态方法可以获取基本类型包装类数组、引用类型数组和单个元素的Stream流对象；  
  （3）Arrays数组工具类的stream()静态方法也可以获取数组元素的Stream流对象。  
  接下来，通过一个案例来学习聚合操作中如何创建Stream流对象，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example32 {
 4		public static void main(String[] args) {
 5	          // 创建一个数组
 6			Integer[] array = { 9, 8, 3, 5, 2 };       
 7	          // 将数组转换为List集合
 8			List<Integer> list = Arrays.asList(array); 
 9			// 1、使用集合对象的stream()静态方法创建Stream流对象
 10			Stream<Integer> stream = list.stream();
 11			stream.forEach(i -> System.out.print(i+" "));
 12			System.out.println();
 13			// 2、使用Stream接口的of()静态方法创建Stream流对象
 14			Stream<Integer> stream2 = Stream.of(array);
 15			stream2.forEach(i -> System.out.print(i+" "));
 16			System.out.println();
 17			// 3、使用Arrays数组工具类的stream()静态方法创建Stream流对象
 18			Stream<Integer> stream3 = Arrays.stream(array);
 19			stream3.forEach(i -> System.out.print(i+" "));
 20		}
 21	}
```  
  运行结果如下图所示。
![alt](/article_img/lambda/4.jpg)
  上述示例代码中，先创建了一个数组和一个集合，然后通过三种方式实现了Stream流对象的创建，并通过Stream流对象的forEach()方法结合Lambda表达式完成了集合和数组中元素的遍历。  

**小提示：**  
  在JDK 8中，只针对单列集合Collections接口对象提供了stream()静态方法获取Stream流对象，并未对Map集合提供相关方法获取Stream流对象，所以想要用Map集合创建Stream流对象必须先通过Map集合的keySet()、values()、entrySet()等方法将Map集合转换为单列Set集合，然后再使用单列集合的stream()静态方法获取对应键、值集合的Stream流对象。

, 2018-12-02, null, 默认分类, JDK 8,聚合操作, true, null, 36, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [9, 虚拟化容器技术——Docker运行机制介绍,   Docker是一个开源的应用容器引擎，它基于go语言开发，并遵从Apache2.0开源协议。使用Docker可以让开发者封装他们的应用以及依赖包到一个可移植的容器中，然后发布到任意的Linux机器上，也可以实现虚拟化。Docker容器完全使用沙箱机制，相互之间不会有任何接口，这保证了容器之间的安全性。  

**1. Docker的引擎介绍**

  Docker Engine（Docker引擎）是Docker的核心部分，使用的是客户端-服务器（C/S）架构模式，其主要组成部分如下图所示。
![alt](/article_img/docker/1.png)
  从上图可以看出，Docker Engine中包含了三个核心组件（docker CLI、REST API和docker daemon），这三个组件的具体说明如下：  
  ①docker CLI（command line interface）：表示Docker命令行接口，开发者可以在命令行中使用Docker相关指令与Docker守护进程进行交互，从而管理诸如image（镜像）、container（容器）、network（网络）和data volumes（数据卷）等实体。  
  ②REST API：表示应用程序API接口，开发者通过该API接口可以与Docker的守护进程进行交互，从而指示后台进行相关操作。  
  ③docker daemon：表示Docker的服务端组件，他是Docker架构中运行在后台的一个守护进程，可以接收并处理来自命令行接口及API接口的指令，然后进行相应的后台操作。  
  对于开发者而言，既可以使用编写好的脚本文件通过REST API来实现与Docker进程交互，又可以直接使用Docker相关指令通过命令行接口来与Docker进程交互，而其他一些Docker应用则是通过底层的API和CLI进行交互的。

**2. Docker的架构介绍**

  了解了Docker内部引擎及作用后，我们还需要通过Docker的具体架构，来了解Docker的整个运行流程。接下来借助Docker官网的架构图来对Docker架构进行详细说明，如下图所示。
![alt](/article_img/docker/2.jpg)
  从图中可以看出，Docker架构主要包括Client、DOCKER_HOST和Register三部分，关于这三部分的具体说明如下。  
&emsp;&emsp;**（1）Client（客户端）**  
  Client即Docker客户端，也就是上一小节Docker Engine中介绍的docker CLI。开发者通过这个客户端使用Docker的相关指令与Docker守护进程进行交互，从而进行Docker镜像的创建、拉取和运行等操作。  
&emsp;&emsp;**（2）DOCKER_HOST（Docker主机）**  
  DOCKER_HOST即Docker内部引擎运行的主机，主要指Docker daemon（Docker守护进程）。可以通过Docker守护进程与客户端还有Docker的镜像仓库Registry进行交互，从而管理Images（镜像）和Containers（容器）等。  
&emsp;&emsp;**（3）Registry（注册中心）**  
  Registry即Docker注册中心，实质就是Docker镜像仓库，默认使用的是Docker官方远程注册中心Docker Hub，也可以使用开发者搭建的本地仓库。Registry中包含了大量的镜像，这些镜像可以是官网基础镜像，也可以是其他开发者上传的镜像。  
  我们在实际使用Docker时，除了会涉及到图中的三个主要部分外，还会涉及到很多Docker Objects（Docker对象），例如Images（镜像）、Containers（容器）、Networks（网络）、Volumes（数据卷）、Plugins（插件）等。其中常用的两个对象Image和Containers的说明如下。  
  ①Images（镜像）  
  Docker 镜像就是一个只读的模板，包含了一些创建Docker容器的操作指令。通常情况下，一个Docker镜像是基于另一个基础镜像创建的，并且新创建的镜像会额外包含一些功能配置。例如：开发者可以依赖于一个Ubuntu的基础镜像创建一个新镜像，并可以在新镜像中安装Apache等软件或其它应用程序。  
  ②Containers（容器）  
  Docker容器属于镜像的一个可运行实例（镜像与容器的关系其实与Java中的类与对象相似），开发者可以通过API接口或者CLI命令行接口来创建、运行、停止、移动、删除一个容器，也可以将一个容器连接到一个或多个网络中，将数据存储与容器进行关联。



, 2018-12-03, null, 默认分类, 虚拟化容器,Docker,运行机制, true, null, 26, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [10, Docker常用客户端指令介绍,   在使用Docker之前，首先会为对应的项目编写Dockerfile镜像构建文件，然后通过Docker的相关指令进行镜像构建，完成镜像的构建后，就可以使用这些项目镜像进行启动测试了。所以要想知道如何使用Docker来执行这些Dockerfile镜像构建文件，还需要学习Docker客户端的常用指令，本篇文章将对Docker客户端的常用指令进行详细讲解。  

**1.列出镜像**  
  通过docker images指令可以查看本地镜像列表中已有的镜像，具体使用方式如下。
```js
$ docker images
```  
  执行上述指令后，系统会将所有本地镜像都展示出来，如下图所示。
![alt](/article_img/docker/3.png)
  从图中可以看出，系统终端将本地镜像列表中的3个镜像分5列进行了展示，每一列的具体含义如下。  
  ●REPOSITORY：镜像名称。  
  ●TAG：镜像的参数，类似于版本号，默认是latest。  
  ●IMAGE ID：镜像ID，是唯一值。此处看到的是一个长度为12的字符串，实际上它是64位完整镜像ID的缩写形式。  
  ●CREATED：距今创建镜像的时间。  
  ●SIZE：镜像大小。    

**2.搜索镜像**  
  想知道在Docker Hub中包含了哪些镜像，除了可以登录Docker Hub，在官网中心进行查看外，还可以直接在Docker客户端进行查询。例如想要查询Ubuntu镜像，可以使用如下指令。
```js
$ docker search ubuntu
```  
  执行上述指令后，系统终端就会将搜索到的有关Ubuntu的镜像展示出来，如下图所示。
![alt](/article_img/docker/4.png)
  从图所示的结果可以看出，系统终端分5列将搜索到的Ubuntu相关镜像都列举出来了，这5列的具体含义如下。  
  ●NAME：表示镜像的名称，这里有两种格式的名称，其中不带有“/”的表示官方镜像，而带有“/”的表示其他用户的公开镜像。公开镜像“/”前面是用户在Docker Hub上的用户名（唯一），后面是对应的镜像名；官方镜像与用户镜像，除了从镜像名称上可以区分外，还可以通过第4列的OFFICIAL声明中看出（该列下内容为OK表示官方镜像）。  
  ●DESCRIPTION：表示镜像的描述，这里只显示了一小部分。  
  ●STARS：表示该镜像的收藏数，用户可以在Docker Hub上对镜像进行收藏，一般可以通过该数字反应出该镜像的受欢迎程度。  
  ●OFFICIAL：表示是否为官方镜像。  
  ●AUTOMATED：表示是否自动构建镜像。例如，用户可以将自己的Docker Hub绑定到如Github上，当代码提交更新后，可以自动构建镜像。   
 
**3.拉取镜像**  
  通过docker pull指令可以拉取仓库镜像到本地（默认都是拉取Docker Hub仓库镜像，也可以指定“IP+端口”拉取某个Docker机器上的私有仓库镜像），具体使用方式如下。
```js
$ docker pull ubuntu
```  
  执行上述指令后，Docker会自动从Docker Hub上下载最新版本的Ubuntu到本地，当然也可以使用以下指令拉取指定版本的镜像到本地，具体指令如下。
```js
$ docker pull ubuntu:14.04
```  
**4.构建镜像**  
  除了可以通过docker pull指令从仓库拉取镜像外，还可以通过docker build指令构建Docker镜像，通常情况下都是通过Dockerfile文件来构建镜像的。  
  这里假设linux系统home目录下/shitou/workspace/dockerspace文件夹中编写有对应的Dockerfile文件，则构建镜像直立示例如下所示。 
```js
$ docker build -t hellodocker3 /home/shitou/workspace/dockerspace/.
```
**5.删除镜像**  
  当本地存放过多不需要的镜像时，可以通过docker rmi指令将其删除。在删除镜像时，需要指定镜像名称或镜像ID。删除镜像的使用方式如下。
```js
$ docker rmi -f hellodocker2 hellodocker3
```  
  上述指令中，docker rmi表示删除镜像，-f表示进行强制删除，而hellodocker2和hellodocker3分别表示需要删除的镜像名称，这里同时删除两个镜像。除了根据名称删除镜像外，还也可以根据镜像ID来删除镜像，只是这里如果指定了删除ID为23c617a866d4的镜像后，会同时删除hellodocker、hellodocker2和hellodocker3三个镜像。  
  需要特别强调的是，在进行镜像删除操作时，如果是通过镜像ID进行镜像删除，那么由该镜像创建的容器必须提前删除或停止。另外，在通过镜像名称操作镜像时，如果出现镜像重名的情况，必须在镜像名称后面指定镜像标签tag参数来确保唯一性。

**6.创建并启动容器**  
  Docker镜像主要用于创建容器，可以使用docker run指令创建并启动容器，具体使用方式如下。
```js
$ docker run -d -p 5000:80 --name test hellodocker
```  
  上述创建并启动容器的指令略微复杂，具体分析如下。  
  ●docker run：表示创建并启动一个容器，而后面的hellodocker就表示要启动运行的镜像名称；  
  ●-d：表示容器启动时在后台运行；  
  ●-p 5000:80：表示将容器内暴露的80端口映射到宿主机指定的5000端口，也可以将-p 5000:80更改为-P来映射主机的随机端口（注意p字母的大小写）；  
  ●--name test：表示为创建后的容器指定名称为test，如果没有该参数配置，则生成的容器会设置一个随机名称。  
  docker run命令是Docker操作中较为复杂的一个，它可以携带多个参数和参数，我们可以通过docker run --help指令进行查看，其中有些参数如-e、-v和-w等都可以在Dockerfile文件中预先声明。 
 
**7.列出容器**  
  生成容器后，可以通过docker ps指令查看当前运行的所有容器，具体使用方式如下。
```js
$ docker ps
```  
  执行上述命令后，会将所有当前运行的容器都展示出来，具体如下图所示。
![alt](/article_img/docker/5.png)
  从图中可以看出，系统终端通过7列对当前的正在运行的一个容器进行了展示，图中每一列的具体含义如下。  
  ●CONTAINER ID：表示生成的容器ID；  
  ●IMAGE：表示生成该容器的镜像名称；  
  ●COMMAND：表示启动容器时运行的命令，Docker要求在启动容器时必须运行一个命令；  
  ●CREATED：表示容器创建的时间；  
  ●STATUS：表示容器运行状态，例如Up表示运行中，Exited表示已停止；  
  ●PORTS：表示容器内部暴露的端口映射到主机的端口；  
  ●NAMES：表示生成容器的名称，由Docker引擎自动生成，可以像上述示例中使用--name参数指定生成容器的名称。  
  另外，docker ps指令运行过程中可以指定多个参数，还可以通过docker ps --help指令对ps指令的其他信息进行查看。

**8.删除容器**  
  当不需要使用容器时，则可以使用docker rm指令删除已停止的容器，具体使用方式如下。
```js
$ docker rm f0c9a8b6e8c5
```  
  需要注意的是，上述指令只能删除已经停止运行的容器，而不能删除正在运行的容器。如果想要删除正在运行的容器，则需要添加-f参数强制删除，具体使用方式如下。
```js
$ docker rm -f f0c9a8b6e8c5
```  
  当需要删除的容器过多时，如果还一个个的删除就略显麻烦了，此时可以通过如下指令将全部容器删除。
```js
$ docker rm -f $(docker ps -aq)
```  
  上述指令中，首先会通过$(docker ps -aq)获取所有容器的ID，然后通过docker rm -f指令进行强制删除。如果开发者有自己特殊的删除需求，可以根据前面docker ps指令进行组装来获取需要删除的容器ID。  
  Docker提供的操作指令远不止这些，这里就不一一列举了，想要了解更多Docker的操作指令，可以通过docker --help指令进行查看。


, 2018-12-05, null, 默认分类, Docker,客户端指令, true, null, 21, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [11, Docker数据管理介绍,   当我们对容器进行相关操作时，产生的一系列数据都会存储在容器中，而Docker内部又是如果管理这些数据的呢？本篇文章将针对Docker数据管理的一些知识进行介绍。
  
**1. Docker数据存储机制**  
  使用Docker时，我们操作的都是镜像和由镜像生成的容器，所以想要更好的了解Docker内部的数据存储机制，就必须从镜像、容器与数据存储的关系出发。  
  Docker镜像是通过读取Dockerfile文件中的指令构建的，Dockerfile中的每条指令都会创建一个镜像层，并且每层都是只读的，这一系列的镜像层就构成了Docker镜像。接下来以一个Dockerfile文件为例进行说明，具体如下列代码示例所示。
```js
 1	FROM ubuntu:16.04
 2	COPY . /app
 3	RUN make /app
 4	CMD python /app/app.py
```  
   上述文件示例中的Dockerfile包含了4条指令，每条指令都会创建一个镜像层，其中每一层与前一层都有所不同，并且是层层叠加的。通过镜像构建容器时，会在镜像层上增加一个容器层（即可写层），所有对容器的更改都会写入容器层，这也是Docker默认的数据存储方式。  
  下面通过一个效果图进行说明，具体如下图所示。
![alt](/article_img/docker/6.png)
  从图中可以看出，Docker容器和镜像之间的主要区别是顶部的容器层，而所有对容器中数据的添加、修改等操作都会被存储在容器层中。当容器被删除时，容器层也会被删除，其中存储的数据会被一同删除，而下面的镜像层却保持不变。  
  由于所有的容器都是通过镜像构建的，所以每个容器都有各自的容器层，对于容器数据的更改就会保存在各自的容器层中。也就是说，由同一个镜像构建的多个容器，它们会拥有相同的底部镜像层，而拥有不同的容器层，多个容器可以访问相同的镜像层，并且有自己的独立数据状态。具体说明如下图所示。 
![alt](/article_img/docker/7.png)
  从图中可以看出，基于同一个镜像构建的多个容器可以共享该镜像层，但是多个容器想要共享相同的数据，就需要将这些数据存储到容器之外的地方，而这种方式就是下一节要提到的Docker volume数据外部挂载机制。  

**2. Docker数据存储方式**    
  在默认情况下，Docker中的数据都是存放在容器层的，但是这样存储数据却有较多的缺陷，具体表现如下。    
  ●当容器不再运行时，容器中的数据无法持久化保存，如果另一个进程需要这些数据，那么将很难从容器中获取数据；  
  ●容器层与正在运行的主机紧密耦合，不能轻易地移动数据；  
  ●容器层需要一个存储驱动程序来管理文件系统，存储驱动程序提供了一个使用Linux内核的联合文件系统，这种额外的抽象化降低了性能。  
  基于上述种种原因，多数情况下Docker数据管理都不会直接将数据写入容器层，而是使用另一种叫做Docker volume数据外部挂载的机制进行数据管理。  
  针对Docker volume数据外部挂载机制，Docker提供了三种不同的方式将数据从容器映射到Docker宿主机，他们分别为：volumes（数据卷）、bind mounts（绑定挂载）和tmpfs mounts（tmpfs挂载）。这三种数据管理方式的具体选择，需要结合实际情况进行考虑，其中的volumes数据卷是最常用也是官方推荐的数据管理方式。无论选择使用哪种数据管理方式，数据在容器内看起来都一样的，而在容器外则会被被挂载到文件系统中的某个目录或文件中。    
  下面通过一张图来展示数据卷、绑定挂载和tmpfs挂载之间的差异，如下图所示。  
![alt](/article_img/docker/8.png)
  从图中可以看出，Docker提供的三种数据管理方式略有不同，具体分析如下。  
  ●volumes：存储在主机文件系统中（在Linux系统下是存在于/var/lib/Docker/volumes/目录），并由Docker管理，非Docker进程无法修改文件系统的这个部分。  
  ●bind mounts：可以存储在主机系统的任意位置，甚至可能是重要的系统文件或目录，在Docker主机或容器上的非Docker进程可以对他们进行任意修改。  
  ●tmpfs mounts：只存储在主机系统的内存中，并没有写入到主机的文件系统中。


, 2018-12-07, 2021-05-19, 默认分类, Docker,数据管理, true, null, 19, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [6, JDK 8——Lambda表达式介绍,   Lambda表达式是JDK 8中一个重要的新特性，它使用一个清晰简洁的表达式来表达一个接口，同时Lambda表达式也简化了对集合以及数组数据的遍历、过滤和提取等操作。下面，本篇文章就对Lambda表达式进行简要介绍，并进行演示说明。

**1. Lambda表达式入门**  

  匿名内部类存在的一个问题是，如果匿名内部类的实现非常简单，例如只包含一个抽象方法的接口，那么匿名内部类的语法仍然显得比较冗余。为此，JDK 8中新增了一个特性Lambda表达式，这种表达式只针对有一个抽象方法的接口实现，以简洁的表达式形式实现接口功能来作为方法参数。  
  一个Lambda表达式由三个部分组成，分别为参数列表、“->”和表达式主体，其语法格式如下：
```js
 ([数据类型 参数名,数据类型 参数名,...]) -> {表达式主体}
```  
  从上述语法格式上看，Lambda表达式的书写非常简单，下面针对Lambda表达式的组成部分进行简单介绍，具体如下：  
  （1）([数据类型 参数名,数据类型 参数名,...])：用来向表达式主体传递接口方法需要的参数，多个参数名中间必须用英文逗号“,”进行分隔；在编写Lambda表达式时，可以省略参数的数据类型，后面的表达式主体会自动进行校对和匹配；同时，如果只有一个参数，则可以省略括号“()”。  
  （2）->：表示Lambda表达式箭牌，用来指定参数数据指向，不能省略，且必须用英文横线和大于号书写。  
  （3）{表达式主体}：由单个表达式或语句块组成的主体，本质就是接口中抽象方法的具体实现，如果表达式主体只有一条语句，那么可以省略包含主体的大括号；另外，在Lambda表达式主体中允许有返回值，当只有一条return语句时，也可以省略return关键字。  
  了解了Lambda表达式的语法后，接下来编写一个示例文件对Lambda表达式的基本使用进行介绍，具体代码如下所示。
```js
 1	// 定义动物类接口
 2	interface Animal { 
 3		void shout(); // 定义方法shout()
 4	}
 5	public class Example22 {
 6		public static void main(String[] args) {
 7	       String name = "小花"; 
 8	       // 1、匿名内部类作为参数传递给animalShout()方法
 9		  animalShout(new Animal() { 
 10				 public void shout() { 
 11				    System.out.println("匿名内部类输出："+name+"喵喵...");
 12				}
 13		  });
 14		  // 2、使用Lambda表达式作为参数传递给animalShout()方法
 15	       animalShout(()-> System.out.println("Lambda表达式输出："
 16	                                                   +name+"喵喵..."));
 17		}
 18	    // 创建一个animalShout()静态方法，接收接口类型的参数
 19		public static void animalShout(Animal an) {
 20			an.shout();  
 21		}
 22	}
```  
  运行结果下图所示。
![alt](/article_img/lambda/1.jpg)
  上述代码示例中，先定义了只有一个抽象方法的接口Animal，然后分别使用匿名内部类和Lambda表达式的方式实现了接口方法。从图中可以看出，使用匿名内部类和Lambda表达式都能实现接口中方法，但很显然使用Lambda表达式更加简洁和清晰。, 2018-11-27, null, 默认分类, 2018,Lambda表达式, true, null, 18, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [7, 函数式接口, &emsp;&emsp;虽然Lambda表达式可以实现匿名内部类的功能，但在使用时却有一个局限，即接口中有且只有一个抽象方法时才能使用Lamdba表达式代替匿名内部类。这是因为Lamdba表达式是基于函数式接口实现的，所谓函数式接口是指有且仅有一个抽象方法的接口，Lambda表达式就是Java中函数式编程的体现，只有确保接口中有且仅有一个抽象方法，Lambda表达式才能顺利地推导出所实现的这个接口中的方法。  
&emsp;&emsp;在JDK 8中，专门为函数式接口引入了一个@FunctionalInterface注解，该注解只是显示的标注了接口是一个函数式接口，并强制编辑器进行更严格的检查，确保该接口是函数式接口，如果不是函数式接口，那么编译器就会报错，而对程序运行并没有实质上的影响。  
&emsp;&emsp;接下来通过一个案例来演示函数式接口的定义与使用，示例代码如下所示。
```js
 1	// 定义无参、无返回值的函数式接口
 2	@FunctionalInterface
 3	interface Animal {
 4		void shout();
 5	}
 6	// 定义有参、有返回值的函数式接口
 7	interface Calculate {
 8		int sum(int a, int b);
 9	}
 10	public class Example23 {
 11		public static void main(String[] args) {
 12		   // 分别两个函数式接口进行测试
 13		   animalShout(() -> System.out.println("无参、无返回值的函数式接口调用"));
 14		   showSum(10, 20, (x, y) -> x + y);
 15		}
 16		// 创建一个动物叫的方法，并传入接口对象Animal作为参数
 17		private static void animalShout(Animal animal) {
 18			animal.shout();
 19		}
 20		// 创建一个求和的方法，并传入两个int类型以及接口Calculate类型的参数
 21		private static void showSum(int x, int y, Calculate calculate) {
 22		   System.out.println(x + "+" + y + "的和为：" + calculate.sum(x, y));
 23		}
 24	}
```  
&emsp;&emsp;运行结果如下图所示。

![alt](/article_img/lambda/2.jpg)
&emsp;&emsp;上述代码示例中，先定义了两个函数式接口Animal和Calculate，然后在测试类中分别编写了两个静态方法，并将这两个函数式接口以参数的形式传入，最后在main()方法中分别调用这两个静态方法，并将所需要的函数式接口参数以Lambda表达式的形式传入。从图中可以看出，程序中函数式接口的定义和使用完全正确。
, 2018-12-01, null, 默认分类, 接口,函数式接口, true, null, 12, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20003} created. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20003} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20003} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20003} executed. 0.5695 millis. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20003, rs-50003} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20003, rs-50003} Header: [count(0)]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20003, rs-50003} Result: [12]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20003, rs-50003} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20003} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20004} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20004} Parameters : [5]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20004} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20004} executed. 0.5253 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20004} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20005} created. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20005} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20005} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20005} executed. 0.744 millis. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20005, rs-50005} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20005, rs-50005} Header: [count(0)]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20005, rs-50005} Result: [12]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20005, rs-50005} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20005} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20006} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20006} Parameters : [5]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20006} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20006} executed. 0.8911 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20006, rs-50006} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20006, rs-50006} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20006, rs-50006} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20006, rs-50006} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20006, rs-50006} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20006, rs-50006} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20006, rs-50006} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20006, rs-50006} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20006} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20007} created. select username,password,valid from t_user where username = ?
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20007} Parameters : [admin]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20007} Types : [VARCHAR]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20007, rs-50007} query executed. 15.2641 millis. select username,password,valid from t_user where username = ?
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20007, rs-50007} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20007, rs-50007} Header: [username, password, valid]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20007, rs-50007} Result: [admin, $2a$10$5ooQI8dir8jv0/gCa1Six.GpzAdIPf6pMqdminZ/3ijYzivCyPlfK, true]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20007, rs-50007} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20007} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20008} created. select u.username,a.authority from t_user u,t_authority a,t_user_authority ua where ua.user_id=u.id and ua.authority_id=a.id and u.username =?
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20008} Parameters : [admin]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20008} Types : [VARCHAR]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20008, rs-50008} query executed. 5.0325 millis. select u.username,a.authority from t_user u,t_authority a,t_user_authority ua where ua.user_id=u.id and ua.authority_id=a.id and u.username =?
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20008, rs-50008} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20008, rs-50008} Header: [username, authority]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20008, rs-50008} Result: [admin, ROLE_admin]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20008, rs-50008} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20008} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20009} created. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20009} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20009} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20009} executed. 0.5303 millis. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20009, rs-50009} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20009, rs-50009} Header: [count(0)]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20009, rs-50009} Result: [12]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20009, rs-50009} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20009} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20010} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20010} Parameters : [5]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20010} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20010} executed. 0.5508 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20010, rs-50010} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20010, rs-50010} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20010, rs-50010} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20010, rs-50010} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20010, rs-50010} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20010, rs-50010} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20010, rs-50010} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20010, rs-50010} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20010} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][com.boot.controller.adminController]2021-05-22 23:15:35   用户名：admin进入admim后台
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20011} created. SELECT count(0) FROM t_article, t_comment WHERE t_article.id = t_comment.article_id
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20011} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20011} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20011} executed. 4.2344 millis. SELECT count(0) FROM t_article, t_comment WHERE t_article.id = t_comment.article_id
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20011, rs-50011} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20011, rs-50011} Header: [count(0)]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20011, rs-50011} Result: [12]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20011, rs-50011} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20011} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20012} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_comment.article_id,
	t_comment.c_content,
	t_comment.created,
	t_comment.author,
	t_comment.ip,
	t_comment.status
    FROM
    t_article,
	t_comment
    WHERE
	t_article.id = t_comment.article_id
	order by t_article.created desc LIMIT ? 
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20012} Parameters : [5]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20012} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20012} executed. 9.0705 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_comment.article_id,
	t_comment.c_content,
	t_comment.created,
	t_comment.author,
	t_comment.ip,
	t_comment.status
    FROM
    t_article,
	t_comment
    WHERE
	t_article.id = t_comment.article_id
	order by t_article.created desc LIMIT ? 
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20012, rs-50012} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20012, rs-50012} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, article_id, c_content, created, author, ip, status]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20012, rs-50012} Result: [12, Spring Boot 2 权威发布,   如果这两天登录 [https://start.spring.io/ ](https://start.spring.io/ )就会发现，Spring Boot 默认版本已经升到了 2.1.0。这是因为 Spring Boot 刚刚发布了 2.1.0 版本，我们来看下 Spring Boot 2 发布以来第一个子版本都发布了哪些内容？  

**2.1 中的新特性**     
  ●将spring-boot-starter-oauth2-oidc-client重命名为spring-boot-starter-oauth2-client命名更简洁  
  ●添加 OAuth2 资源服务 starter，OAuth2 一个用于认证的组件  
  ●支持 ConditionalOnBean 和 ConditionalOnMissingBean 下的参数化容器  
  ●自动配置 applicationTaskExecutor bean 的延迟加载来避免不必要的日志记录  
  ●将 DatabaseDriver＃SAP 重命名为 DatabaseDriver  
  ●跳过重启器不仅适用于 JUnit4，也适用于 JUnit5  
  ●在 Jest HealthIndicator 中使用集群端点  
  ●当 DevTools 禁用重启时添加日志输出  
  ●添加注解：@ConditionalOnMissingServletFilter提高 Servlet Filters 的自动装配。
  
**2.1 中的组件升级**  
  ●升级 Hibernate 5.3，Hibernate 的支持升级到了 5.3  
  ●升级 Tomcat 9 ，支持最新的 tomcat 9  
  ●支持 Java 11，Java 现在更新越来越快，Spring 快赶不上了    
  ●升级 Thymeleaf Extras Springsecurity 到 3.0.4.RELEASE ，thymeleaf-extras-springsecurity 是 Thymeleaf 提供集成 Spring Security 的组件  
  ●升级 Joda Time 2.10.1，Joda-Time， 面向 Java 应用程序的日期/时间库的替代选择，Joda-Time 令时间和日期值变得易于管理、操作和理解。  
  ●升级 Lettuce 5.1.2.RELEASE ，Lettuce 前面说过，传说中 Redis 最快的客户端。  
  ●升级 Reactor Californium-SR2 ，Californium 是物联网云服务的 Java COAP 实现。因此，它更专注的是可扩展性和可用性而不是像嵌入式设备那样关注资源效率。不过，Californium 也适合嵌入式的 JVM。  
  ●升级 Maven Failsafe Plugin 2.22.1 ，Maven 中的测试插件。  
  ●升级 Flyway 5.2.1 ， Flyway是一款开源的数据库版本管理工具  
  ●升级 Aspectj 1.9.2 ，AspectJ 是 Java 中流行的 AOP（Aspect-oriented Programming）编程扩展框架，是 Eclipse 托管给 Apache 基金会的一个开源项目。  
  ●升级 Mysql 8.0.13 ，Mysql 支持到 8。  
  ●...  
  更多的详细内容可以参考这里：[Spring Boot 2.1 Release Notes](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.1-Release-Notes)
, 2018-12-12, 2021-05-21, 默认分类, Spring Boot 2, true, null, 12, 很不错，不过这文章排版不太好看啊, 2018-12-13, 李四, 0:0:0:0:0:0:0:1, approved]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20012, rs-50012} Result: [12, Spring Boot 2 权威发布,   如果这两天登录 [https://start.spring.io/ ](https://start.spring.io/ )就会发现，Spring Boot 默认版本已经升到了 2.1.0。这是因为 Spring Boot 刚刚发布了 2.1.0 版本，我们来看下 Spring Boot 2 发布以来第一个子版本都发布了哪些内容？  

**2.1 中的新特性**     
  ●将spring-boot-starter-oauth2-oidc-client重命名为spring-boot-starter-oauth2-client命名更简洁  
  ●添加 OAuth2 资源服务 starter，OAuth2 一个用于认证的组件  
  ●支持 ConditionalOnBean 和 ConditionalOnMissingBean 下的参数化容器  
  ●自动配置 applicationTaskExecutor bean 的延迟加载来避免不必要的日志记录  
  ●将 DatabaseDriver＃SAP 重命名为 DatabaseDriver  
  ●跳过重启器不仅适用于 JUnit4，也适用于 JUnit5  
  ●在 Jest HealthIndicator 中使用集群端点  
  ●当 DevTools 禁用重启时添加日志输出  
  ●添加注解：@ConditionalOnMissingServletFilter提高 Servlet Filters 的自动装配。
  
**2.1 中的组件升级**  
  ●升级 Hibernate 5.3，Hibernate 的支持升级到了 5.3  
  ●升级 Tomcat 9 ，支持最新的 tomcat 9  
  ●支持 Java 11，Java 现在更新越来越快，Spring 快赶不上了    
  ●升级 Thymeleaf Extras Springsecurity 到 3.0.4.RELEASE ，thymeleaf-extras-springsecurity 是 Thymeleaf 提供集成 Spring Security 的组件  
  ●升级 Joda Time 2.10.1，Joda-Time， 面向 Java 应用程序的日期/时间库的替代选择，Joda-Time 令时间和日期值变得易于管理、操作和理解。  
  ●升级 Lettuce 5.1.2.RELEASE ，Lettuce 前面说过，传说中 Redis 最快的客户端。  
  ●升级 Reactor Californium-SR2 ，Californium 是物联网云服务的 Java COAP 实现。因此，它更专注的是可扩展性和可用性而不是像嵌入式设备那样关注资源效率。不过，Californium 也适合嵌入式的 JVM。  
  ●升级 Maven Failsafe Plugin 2.22.1 ，Maven 中的测试插件。  
  ●升级 Flyway 5.2.1 ， Flyway是一款开源的数据库版本管理工具  
  ●升级 Aspectj 1.9.2 ，AspectJ 是 Java 中流行的 AOP（Aspect-oriented Programming）编程扩展框架，是 Eclipse 托管给 Apache 基金会的一个开源项目。  
  ●升级 Mysql 8.0.13 ，Mysql 支持到 8。  
  ●...  
  更多的详细内容可以参考这里：[Spring Boot 2.1 Release Notes](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.1-Release-Notes)
, 2018-12-12, 2021-05-21, 默认分类, Spring Boot 2, true, null, 12, 000111, 2021-05-21, admin, 0:0:0:0:0:0:0:1, approved]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20012, rs-50012} Result: [11, Docker数据管理介绍,   当我们对容器进行相关操作时，产生的一系列数据都会存储在容器中，而Docker内部又是如果管理这些数据的呢？本篇文章将针对Docker数据管理的一些知识进行介绍。
  
**1. Docker数据存储机制**  
  使用Docker时，我们操作的都是镜像和由镜像生成的容器，所以想要更好的了解Docker内部的数据存储机制，就必须从镜像、容器与数据存储的关系出发。  
  Docker镜像是通过读取Dockerfile文件中的指令构建的，Dockerfile中的每条指令都会创建一个镜像层，并且每层都是只读的，这一系列的镜像层就构成了Docker镜像。接下来以一个Dockerfile文件为例进行说明，具体如下列代码示例所示。
```js
 1	FROM ubuntu:16.04
 2	COPY . /app
 3	RUN make /app
 4	CMD python /app/app.py
```  
   上述文件示例中的Dockerfile包含了4条指令，每条指令都会创建一个镜像层，其中每一层与前一层都有所不同，并且是层层叠加的。通过镜像构建容器时，会在镜像层上增加一个容器层（即可写层），所有对容器的更改都会写入容器层，这也是Docker默认的数据存储方式。  
  下面通过一个效果图进行说明，具体如下图所示。
![alt](/article_img/docker/6.png)
  从图中可以看出，Docker容器和镜像之间的主要区别是顶部的容器层，而所有对容器中数据的添加、修改等操作都会被存储在容器层中。当容器被删除时，容器层也会被删除，其中存储的数据会被一同删除，而下面的镜像层却保持不变。  
  由于所有的容器都是通过镜像构建的，所以每个容器都有各自的容器层，对于容器数据的更改就会保存在各自的容器层中。也就是说，由同一个镜像构建的多个容器，它们会拥有相同的底部镜像层，而拥有不同的容器层，多个容器可以访问相同的镜像层，并且有自己的独立数据状态。具体说明如下图所示。 
![alt](/article_img/docker/7.png)
  从图中可以看出，基于同一个镜像构建的多个容器可以共享该镜像层，但是多个容器想要共享相同的数据，就需要将这些数据存储到容器之外的地方，而这种方式就是下一节要提到的Docker volume数据外部挂载机制。  

**2. Docker数据存储方式**    
  在默认情况下，Docker中的数据都是存放在容器层的，但是这样存储数据却有较多的缺陷，具体表现如下。    
  ●当容器不再运行时，容器中的数据无法持久化保存，如果另一个进程需要这些数据，那么将很难从容器中获取数据；  
  ●容器层与正在运行的主机紧密耦合，不能轻易地移动数据；  
  ●容器层需要一个存储驱动程序来管理文件系统，存储驱动程序提供了一个使用Linux内核的联合文件系统，这种额外的抽象化降低了性能。  
  基于上述种种原因，多数情况下Docker数据管理都不会直接将数据写入容器层，而是使用另一种叫做Docker volume数据外部挂载的机制进行数据管理。  
  针对Docker volume数据外部挂载机制，Docker提供了三种不同的方式将数据从容器映射到Docker宿主机，他们分别为：volumes（数据卷）、bind mounts（绑定挂载）和tmpfs mounts（tmpfs挂载）。这三种数据管理方式的具体选择，需要结合实际情况进行考虑，其中的volumes数据卷是最常用也是官方推荐的数据管理方式。无论选择使用哪种数据管理方式，数据在容器内看起来都一样的，而在容器外则会被被挂载到文件系统中的某个目录或文件中。    
  下面通过一张图来展示数据卷、绑定挂载和tmpfs挂载之间的差异，如下图所示。  
![alt](/article_img/docker/8.png)
  从图中可以看出，Docker提供的三种数据管理方式略有不同，具体分析如下。  
  ●volumes：存储在主机文件系统中（在Linux系统下是存在于/var/lib/Docker/volumes/目录），并由Docker管理，非Docker进程无法修改文件系统的这个部分。  
  ●bind mounts：可以存储在主机系统的任意位置，甚至可能是重要的系统文件或目录，在Docker主机或容器上的非Docker进程可以对他们进行任意修改。  
  ●tmpfs mounts：只存储在主机系统的内存中，并没有写入到主机的文件系统中。


, 2018-12-07, 2021-05-19, 默认分类, Docker,数据管理, true, null, 11, 很不错的原理分析，受用了！, 2018-12-13, 李四, 0:0:0:0:0:0:0:1, approved]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20012, rs-50012} Result: [10, Docker常用客户端指令介绍,   在使用Docker之前，首先会为对应的项目编写Dockerfile镜像构建文件，然后通过Docker的相关指令进行镜像构建，完成镜像的构建后，就可以使用这些项目镜像进行启动测试了。所以要想知道如何使用Docker来执行这些Dockerfile镜像构建文件，还需要学习Docker客户端的常用指令，本篇文章将对Docker客户端的常用指令进行详细讲解。  

**1.列出镜像**  
  通过docker images指令可以查看本地镜像列表中已有的镜像，具体使用方式如下。
```js
$ docker images
```  
  执行上述指令后，系统会将所有本地镜像都展示出来，如下图所示。
![alt](/article_img/docker/3.png)
  从图中可以看出，系统终端将本地镜像列表中的3个镜像分5列进行了展示，每一列的具体含义如下。  
  ●REPOSITORY：镜像名称。  
  ●TAG：镜像的参数，类似于版本号，默认是latest。  
  ●IMAGE ID：镜像ID，是唯一值。此处看到的是一个长度为12的字符串，实际上它是64位完整镜像ID的缩写形式。  
  ●CREATED：距今创建镜像的时间。  
  ●SIZE：镜像大小。    

**2.搜索镜像**  
  想知道在Docker Hub中包含了哪些镜像，除了可以登录Docker Hub，在官网中心进行查看外，还可以直接在Docker客户端进行查询。例如想要查询Ubuntu镜像，可以使用如下指令。
```js
$ docker search ubuntu
```  
  执行上述指令后，系统终端就会将搜索到的有关Ubuntu的镜像展示出来，如下图所示。
![alt](/article_img/docker/4.png)
  从图所示的结果可以看出，系统终端分5列将搜索到的Ubuntu相关镜像都列举出来了，这5列的具体含义如下。  
  ●NAME：表示镜像的名称，这里有两种格式的名称，其中不带有“/”的表示官方镜像，而带有“/”的表示其他用户的公开镜像。公开镜像“/”前面是用户在Docker Hub上的用户名（唯一），后面是对应的镜像名；官方镜像与用户镜像，除了从镜像名称上可以区分外，还可以通过第4列的OFFICIAL声明中看出（该列下内容为OK表示官方镜像）。  
  ●DESCRIPTION：表示镜像的描述，这里只显示了一小部分。  
  ●STARS：表示该镜像的收藏数，用户可以在Docker Hub上对镜像进行收藏，一般可以通过该数字反应出该镜像的受欢迎程度。  
  ●OFFICIAL：表示是否为官方镜像。  
  ●AUTOMATED：表示是否自动构建镜像。例如，用户可以将自己的Docker Hub绑定到如Github上，当代码提交更新后，可以自动构建镜像。   
 
**3.拉取镜像**  
  通过docker pull指令可以拉取仓库镜像到本地（默认都是拉取Docker Hub仓库镜像，也可以指定“IP+端口”拉取某个Docker机器上的私有仓库镜像），具体使用方式如下。
```js
$ docker pull ubuntu
```  
  执行上述指令后，Docker会自动从Docker Hub上下载最新版本的Ubuntu到本地，当然也可以使用以下指令拉取指定版本的镜像到本地，具体指令如下。
```js
$ docker pull ubuntu:14.04
```  
**4.构建镜像**  
  除了可以通过docker pull指令从仓库拉取镜像外，还可以通过docker build指令构建Docker镜像，通常情况下都是通过Dockerfile文件来构建镜像的。  
  这里假设linux系统home目录下/shitou/workspace/dockerspace文件夹中编写有对应的Dockerfile文件，则构建镜像直立示例如下所示。 
```js
$ docker build -t hellodocker3 /home/shitou/workspace/dockerspace/.
```
**5.删除镜像**  
  当本地存放过多不需要的镜像时，可以通过docker rmi指令将其删除。在删除镜像时，需要指定镜像名称或镜像ID。删除镜像的使用方式如下。
```js
$ docker rmi -f hellodocker2 hellodocker3
```  
  上述指令中，docker rmi表示删除镜像，-f表示进行强制删除，而hellodocker2和hellodocker3分别表示需要删除的镜像名称，这里同时删除两个镜像。除了根据名称删除镜像外，还也可以根据镜像ID来删除镜像，只是这里如果指定了删除ID为23c617a866d4的镜像后，会同时删除hellodocker、hellodocker2和hellodocker3三个镜像。  
  需要特别强调的是，在进行镜像删除操作时，如果是通过镜像ID进行镜像删除，那么由该镜像创建的容器必须提前删除或停止。另外，在通过镜像名称操作镜像时，如果出现镜像重名的情况，必须在镜像名称后面指定镜像标签tag参数来确保唯一性。

**6.创建并启动容器**  
  Docker镜像主要用于创建容器，可以使用docker run指令创建并启动容器，具体使用方式如下。
```js
$ docker run -d -p 5000:80 --name test hellodocker
```  
  上述创建并启动容器的指令略微复杂，具体分析如下。  
  ●docker run：表示创建并启动一个容器，而后面的hellodocker就表示要启动运行的镜像名称；  
  ●-d：表示容器启动时在后台运行；  
  ●-p 5000:80：表示将容器内暴露的80端口映射到宿主机指定的5000端口，也可以将-p 5000:80更改为-P来映射主机的随机端口（注意p字母的大小写）；  
  ●--name test：表示为创建后的容器指定名称为test，如果没有该参数配置，则生成的容器会设置一个随机名称。  
  docker run命令是Docker操作中较为复杂的一个，它可以携带多个参数和参数，我们可以通过docker run --help指令进行查看，其中有些参数如-e、-v和-w等都可以在Dockerfile文件中预先声明。 
 
**7.列出容器**  
  生成容器后，可以通过docker ps指令查看当前运行的所有容器，具体使用方式如下。
```js
$ docker ps
```  
  执行上述命令后，会将所有当前运行的容器都展示出来，具体如下图所示。
![alt](/article_img/docker/5.png)
  从图中可以看出，系统终端通过7列对当前的正在运行的一个容器进行了展示，图中每一列的具体含义如下。  
  ●CONTAINER ID：表示生成的容器ID；  
  ●IMAGE：表示生成该容器的镜像名称；  
  ●COMMAND：表示启动容器时运行的命令，Docker要求在启动容器时必须运行一个命令；  
  ●CREATED：表示容器创建的时间；  
  ●STATUS：表示容器运行状态，例如Up表示运行中，Exited表示已停止；  
  ●PORTS：表示容器内部暴露的端口映射到主机的端口；  
  ●NAMES：表示生成容器的名称，由Docker引擎自动生成，可以像上述示例中使用--name参数指定生成容器的名称。  
  另外，docker ps指令运行过程中可以指定多个参数，还可以通过docker ps --help指令对ps指令的其他信息进行查看。

**8.删除容器**  
  当不需要使用容器时，则可以使用docker rm指令删除已停止的容器，具体使用方式如下。
```js
$ docker rm f0c9a8b6e8c5
```  
  需要注意的是，上述指令只能删除已经停止运行的容器，而不能删除正在运行的容器。如果想要删除正在运行的容器，则需要添加-f参数强制删除，具体使用方式如下。
```js
$ docker rm -f f0c9a8b6e8c5
```  
  当需要删除的容器过多时，如果还一个个的删除就略显麻烦了，此时可以通过如下指令将全部容器删除。
```js
$ docker rm -f $(docker ps -aq)
```  
  上述指令中，首先会通过$(docker ps -aq)获取所有容器的ID，然后通过docker rm -f指令进行强制删除。如果开发者有自己特殊的删除需求，可以根据前面docker ps指令进行组装来获取需要删除的容器ID。  
  Docker提供的操作指令远不止这些，这里就不一一列举了，想要了解更多Docker的操作指令，可以通过docker --help指令进行查看。


, 2018-12-05, null, 默认分类, Docker,客户端指令, true, null, 10, 关于Docker虚拟容器的讲解挺好的额，学习中, 2018-12-13, 李四, 0:0:0:0:0:0:0:1, approved]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20012, rs-50012} Result: [9, 虚拟化容器技术——Docker运行机制介绍,   Docker是一个开源的应用容器引擎，它基于go语言开发，并遵从Apache2.0开源协议。使用Docker可以让开发者封装他们的应用以及依赖包到一个可移植的容器中，然后发布到任意的Linux机器上，也可以实现虚拟化。Docker容器完全使用沙箱机制，相互之间不会有任何接口，这保证了容器之间的安全性。  

**1. Docker的引擎介绍**

  Docker Engine（Docker引擎）是Docker的核心部分，使用的是客户端-服务器（C/S）架构模式，其主要组成部分如下图所示。
![alt](/article_img/docker/1.png)
  从上图可以看出，Docker Engine中包含了三个核心组件（docker CLI、REST API和docker daemon），这三个组件的具体说明如下：  
  ①docker CLI（command line interface）：表示Docker命令行接口，开发者可以在命令行中使用Docker相关指令与Docker守护进程进行交互，从而管理诸如image（镜像）、container（容器）、network（网络）和data volumes（数据卷）等实体。  
  ②REST API：表示应用程序API接口，开发者通过该API接口可以与Docker的守护进程进行交互，从而指示后台进行相关操作。  
  ③docker daemon：表示Docker的服务端组件，他是Docker架构中运行在后台的一个守护进程，可以接收并处理来自命令行接口及API接口的指令，然后进行相应的后台操作。  
  对于开发者而言，既可以使用编写好的脚本文件通过REST API来实现与Docker进程交互，又可以直接使用Docker相关指令通过命令行接口来与Docker进程交互，而其他一些Docker应用则是通过底层的API和CLI进行交互的。

**2. Docker的架构介绍**

  了解了Docker内部引擎及作用后，我们还需要通过Docker的具体架构，来了解Docker的整个运行流程。接下来借助Docker官网的架构图来对Docker架构进行详细说明，如下图所示。
![alt](/article_img/docker/2.jpg)
  从图中可以看出，Docker架构主要包括Client、DOCKER_HOST和Register三部分，关于这三部分的具体说明如下。  
&emsp;&emsp;**（1）Client（客户端）**  
  Client即Docker客户端，也就是上一小节Docker Engine中介绍的docker CLI。开发者通过这个客户端使用Docker的相关指令与Docker守护进程进行交互，从而进行Docker镜像的创建、拉取和运行等操作。  
&emsp;&emsp;**（2）DOCKER_HOST（Docker主机）**  
  DOCKER_HOST即Docker内部引擎运行的主机，主要指Docker daemon（Docker守护进程）。可以通过Docker守护进程与客户端还有Docker的镜像仓库Registry进行交互，从而管理Images（镜像）和Containers（容器）等。  
&emsp;&emsp;**（3）Registry（注册中心）**  
  Registry即Docker注册中心，实质就是Docker镜像仓库，默认使用的是Docker官方远程注册中心Docker Hub，也可以使用开发者搭建的本地仓库。Registry中包含了大量的镜像，这些镜像可以是官网基础镜像，也可以是其他开发者上传的镜像。  
  我们在实际使用Docker时，除了会涉及到图中的三个主要部分外，还会涉及到很多Docker Objects（Docker对象），例如Images（镜像）、Containers（容器）、Networks（网络）、Volumes（数据卷）、Plugins（插件）等。其中常用的两个对象Image和Containers的说明如下。  
  ①Images（镜像）  
  Docker 镜像就是一个只读的模板，包含了一些创建Docker容器的操作指令。通常情况下，一个Docker镜像是基于另一个基础镜像创建的，并且新创建的镜像会额外包含一些功能配置。例如：开发者可以依赖于一个Ubuntu的基础镜像创建一个新镜像，并可以在新镜像中安装Apache等软件或其它应用程序。  
  ②Containers（容器）  
  Docker容器属于镜像的一个可运行实例（镜像与容器的关系其实与Java中的类与对象相似），开发者可以通过API接口或者CLI命令行接口来创建、运行、停止、移动、删除一个容器，也可以将一个容器连接到一个或多个网络中，将数据存储与容器进行关联。



, 2018-12-03, null, 默认分类, 虚拟化容器,Docker,运行机制, true, null, 9, asdaa阿斯顿, 2019-03-30, tom, 0:0:0:0:0:0:0:1, approved]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20012, rs-50012} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20012} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20013} created. SELECT count(0) FROM t_comment
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20013} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20013} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20013} executed. 0.4343 millis. SELECT count(0) FROM t_comment
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20013, rs-50013} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20013, rs-50013} Header: [count(0)]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20013, rs-50013} Result: [12]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20013, rs-50013} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20013} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20014} created. select * from t_comment order by created desc LIMIT ? 
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20014} Parameters : [5]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20014} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20014} executed. 0.7132 millis. select * from t_comment order by created desc LIMIT ? 
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20014, rs-50014} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20014, rs-50014} Header: [id, article_id, created, ip, c_content, status, author]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20014, rs-50014} Result: [18, 12, 2021-05-21, 0:0:0:0:0:0:0:1, 000111, approved, admin]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20014, rs-50014} Result: [17, 2, 2021-05-20, 0:0:0:0:0:0:0:1, 111222, approved, tom]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20014, rs-50014} Result: [15, 9, 2019-03-30, 0:0:0:0:0:0:0:1, asdaa阿斯顿, approved, tom]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20014, rs-50014} Result: [1, 12, 2018-12-13, 0:0:0:0:0:0:0:1, 很不错，不过这文章排版不太好看啊, approved, 李四]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20014, rs-50014} Result: [2, 11, 2018-12-13, 0:0:0:0:0:0:0:1, 很不错的原理分析，受用了！, approved, 李四]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20014, rs-50014} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20014} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20015} created. select count('article_id') from t_article;
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20015} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20015} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20015} executed. 0.4261 millis. select count('article_id') from t_article;
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20015, rs-50015} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20015, rs-50015} Header: [count('article_id')]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20015, rs-50015} Result: [12]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20015, rs-50015} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20015} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][com.boot.controller.adminController]2021-05-22 23:15:36   用户名：admin进入后台发布页面
[DEBUG][21-05-22][com.boot.controller.adminController]2021-05-22 23:15:37   用户名：admin查看文章列表
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20016} created. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20016} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20016} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20016} executed. 0.593 millis. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20016, rs-50016} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20016, rs-50016} Header: [count(0)]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20016, rs-50016} Result: [12]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20016, rs-50016} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20016} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20017} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
	order by created desc LIMIT ? 
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20017} Parameters : [6]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20017} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20017} executed. 2.4592 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
	order by created desc LIMIT ? 
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20017, rs-50017} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20017, rs-50017} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20017, rs-50017} Result: [12, Spring Boot 2 权威发布,   如果这两天登录 [https://start.spring.io/ ](https://start.spring.io/ )就会发现，Spring Boot 默认版本已经升到了 2.1.0。这是因为 Spring Boot 刚刚发布了 2.1.0 版本，我们来看下 Spring Boot 2 发布以来第一个子版本都发布了哪些内容？  

**2.1 中的新特性**     
  ●将spring-boot-starter-oauth2-oidc-client重命名为spring-boot-starter-oauth2-client命名更简洁  
  ●添加 OAuth2 资源服务 starter，OAuth2 一个用于认证的组件  
  ●支持 ConditionalOnBean 和 ConditionalOnMissingBean 下的参数化容器  
  ●自动配置 applicationTaskExecutor bean 的延迟加载来避免不必要的日志记录  
  ●将 DatabaseDriver＃SAP 重命名为 DatabaseDriver  
  ●跳过重启器不仅适用于 JUnit4，也适用于 JUnit5  
  ●在 Jest HealthIndicator 中使用集群端点  
  ●当 DevTools 禁用重启时添加日志输出  
  ●添加注解：@ConditionalOnMissingServletFilter提高 Servlet Filters 的自动装配。
  
**2.1 中的组件升级**  
  ●升级 Hibernate 5.3，Hibernate 的支持升级到了 5.3  
  ●升级 Tomcat 9 ，支持最新的 tomcat 9  
  ●支持 Java 11，Java 现在更新越来越快，Spring 快赶不上了    
  ●升级 Thymeleaf Extras Springsecurity 到 3.0.4.RELEASE ，thymeleaf-extras-springsecurity 是 Thymeleaf 提供集成 Spring Security 的组件  
  ●升级 Joda Time 2.10.1，Joda-Time， 面向 Java 应用程序的日期/时间库的替代选择，Joda-Time 令时间和日期值变得易于管理、操作和理解。  
  ●升级 Lettuce 5.1.2.RELEASE ，Lettuce 前面说过，传说中 Redis 最快的客户端。  
  ●升级 Reactor Californium-SR2 ，Californium 是物联网云服务的 Java COAP 实现。因此，它更专注的是可扩展性和可用性而不是像嵌入式设备那样关注资源效率。不过，Californium 也适合嵌入式的 JVM。  
  ●升级 Maven Failsafe Plugin 2.22.1 ，Maven 中的测试插件。  
  ●升级 Flyway 5.2.1 ， Flyway是一款开源的数据库版本管理工具  
  ●升级 Aspectj 1.9.2 ，AspectJ 是 Java 中流行的 AOP（Aspect-oriented Programming）编程扩展框架，是 Eclipse 托管给 Apache 基金会的一个开源项目。  
  ●升级 Mysql 8.0.13 ，Mysql 支持到 8。  
  ●...  
  更多的详细内容可以参考这里：[Spring Boot 2.1 Release Notes](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.1-Release-Notes)
, 2018-12-12, 2021-05-21, 默认分类, Spring Boot 2, true, null, 62, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20017, rs-50017} Result: [11, Docker数据管理介绍,   当我们对容器进行相关操作时，产生的一系列数据都会存储在容器中，而Docker内部又是如果管理这些数据的呢？本篇文章将针对Docker数据管理的一些知识进行介绍。
  
**1. Docker数据存储机制**  
  使用Docker时，我们操作的都是镜像和由镜像生成的容器，所以想要更好的了解Docker内部的数据存储机制，就必须从镜像、容器与数据存储的关系出发。  
  Docker镜像是通过读取Dockerfile文件中的指令构建的，Dockerfile中的每条指令都会创建一个镜像层，并且每层都是只读的，这一系列的镜像层就构成了Docker镜像。接下来以一个Dockerfile文件为例进行说明，具体如下列代码示例所示。
```js
 1	FROM ubuntu:16.04
 2	COPY . /app
 3	RUN make /app
 4	CMD python /app/app.py
```  
   上述文件示例中的Dockerfile包含了4条指令，每条指令都会创建一个镜像层，其中每一层与前一层都有所不同，并且是层层叠加的。通过镜像构建容器时，会在镜像层上增加一个容器层（即可写层），所有对容器的更改都会写入容器层，这也是Docker默认的数据存储方式。  
  下面通过一个效果图进行说明，具体如下图所示。
![alt](/article_img/docker/6.png)
  从图中可以看出，Docker容器和镜像之间的主要区别是顶部的容器层，而所有对容器中数据的添加、修改等操作都会被存储在容器层中。当容器被删除时，容器层也会被删除，其中存储的数据会被一同删除，而下面的镜像层却保持不变。  
  由于所有的容器都是通过镜像构建的，所以每个容器都有各自的容器层，对于容器数据的更改就会保存在各自的容器层中。也就是说，由同一个镜像构建的多个容器，它们会拥有相同的底部镜像层，而拥有不同的容器层，多个容器可以访问相同的镜像层，并且有自己的独立数据状态。具体说明如下图所示。 
![alt](/article_img/docker/7.png)
  从图中可以看出，基于同一个镜像构建的多个容器可以共享该镜像层，但是多个容器想要共享相同的数据，就需要将这些数据存储到容器之外的地方，而这种方式就是下一节要提到的Docker volume数据外部挂载机制。  

**2. Docker数据存储方式**    
  在默认情况下，Docker中的数据都是存放在容器层的，但是这样存储数据却有较多的缺陷，具体表现如下。    
  ●当容器不再运行时，容器中的数据无法持久化保存，如果另一个进程需要这些数据，那么将很难从容器中获取数据；  
  ●容器层与正在运行的主机紧密耦合，不能轻易地移动数据；  
  ●容器层需要一个存储驱动程序来管理文件系统，存储驱动程序提供了一个使用Linux内核的联合文件系统，这种额外的抽象化降低了性能。  
  基于上述种种原因，多数情况下Docker数据管理都不会直接将数据写入容器层，而是使用另一种叫做Docker volume数据外部挂载的机制进行数据管理。  
  针对Docker volume数据外部挂载机制，Docker提供了三种不同的方式将数据从容器映射到Docker宿主机，他们分别为：volumes（数据卷）、bind mounts（绑定挂载）和tmpfs mounts（tmpfs挂载）。这三种数据管理方式的具体选择，需要结合实际情况进行考虑，其中的volumes数据卷是最常用也是官方推荐的数据管理方式。无论选择使用哪种数据管理方式，数据在容器内看起来都一样的，而在容器外则会被被挂载到文件系统中的某个目录或文件中。    
  下面通过一张图来展示数据卷、绑定挂载和tmpfs挂载之间的差异，如下图所示。  
![alt](/article_img/docker/8.png)
  从图中可以看出，Docker提供的三种数据管理方式略有不同，具体分析如下。  
  ●volumes：存储在主机文件系统中（在Linux系统下是存在于/var/lib/Docker/volumes/目录），并由Docker管理，非Docker进程无法修改文件系统的这个部分。  
  ●bind mounts：可以存储在主机系统的任意位置，甚至可能是重要的系统文件或目录，在Docker主机或容器上的非Docker进程可以对他们进行任意修改。  
  ●tmpfs mounts：只存储在主机系统的内存中，并没有写入到主机的文件系统中。


, 2018-12-07, 2021-05-19, 默认分类, Docker,数据管理, true, null, 19, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20017, rs-50017} Result: [10, Docker常用客户端指令介绍,   在使用Docker之前，首先会为对应的项目编写Dockerfile镜像构建文件，然后通过Docker的相关指令进行镜像构建，完成镜像的构建后，就可以使用这些项目镜像进行启动测试了。所以要想知道如何使用Docker来执行这些Dockerfile镜像构建文件，还需要学习Docker客户端的常用指令，本篇文章将对Docker客户端的常用指令进行详细讲解。  

**1.列出镜像**  
  通过docker images指令可以查看本地镜像列表中已有的镜像，具体使用方式如下。
```js
$ docker images
```  
  执行上述指令后，系统会将所有本地镜像都展示出来，如下图所示。
![alt](/article_img/docker/3.png)
  从图中可以看出，系统终端将本地镜像列表中的3个镜像分5列进行了展示，每一列的具体含义如下。  
  ●REPOSITORY：镜像名称。  
  ●TAG：镜像的参数，类似于版本号，默认是latest。  
  ●IMAGE ID：镜像ID，是唯一值。此处看到的是一个长度为12的字符串，实际上它是64位完整镜像ID的缩写形式。  
  ●CREATED：距今创建镜像的时间。  
  ●SIZE：镜像大小。    

**2.搜索镜像**  
  想知道在Docker Hub中包含了哪些镜像，除了可以登录Docker Hub，在官网中心进行查看外，还可以直接在Docker客户端进行查询。例如想要查询Ubuntu镜像，可以使用如下指令。
```js
$ docker search ubuntu
```  
  执行上述指令后，系统终端就会将搜索到的有关Ubuntu的镜像展示出来，如下图所示。
![alt](/article_img/docker/4.png)
  从图所示的结果可以看出，系统终端分5列将搜索到的Ubuntu相关镜像都列举出来了，这5列的具体含义如下。  
  ●NAME：表示镜像的名称，这里有两种格式的名称，其中不带有“/”的表示官方镜像，而带有“/”的表示其他用户的公开镜像。公开镜像“/”前面是用户在Docker Hub上的用户名（唯一），后面是对应的镜像名；官方镜像与用户镜像，除了从镜像名称上可以区分外，还可以通过第4列的OFFICIAL声明中看出（该列下内容为OK表示官方镜像）。  
  ●DESCRIPTION：表示镜像的描述，这里只显示了一小部分。  
  ●STARS：表示该镜像的收藏数，用户可以在Docker Hub上对镜像进行收藏，一般可以通过该数字反应出该镜像的受欢迎程度。  
  ●OFFICIAL：表示是否为官方镜像。  
  ●AUTOMATED：表示是否自动构建镜像。例如，用户可以将自己的Docker Hub绑定到如Github上，当代码提交更新后，可以自动构建镜像。   
 
**3.拉取镜像**  
  通过docker pull指令可以拉取仓库镜像到本地（默认都是拉取Docker Hub仓库镜像，也可以指定“IP+端口”拉取某个Docker机器上的私有仓库镜像），具体使用方式如下。
```js
$ docker pull ubuntu
```  
  执行上述指令后，Docker会自动从Docker Hub上下载最新版本的Ubuntu到本地，当然也可以使用以下指令拉取指定版本的镜像到本地，具体指令如下。
```js
$ docker pull ubuntu:14.04
```  
**4.构建镜像**  
  除了可以通过docker pull指令从仓库拉取镜像外，还可以通过docker build指令构建Docker镜像，通常情况下都是通过Dockerfile文件来构建镜像的。  
  这里假设linux系统home目录下/shitou/workspace/dockerspace文件夹中编写有对应的Dockerfile文件，则构建镜像直立示例如下所示。 
```js
$ docker build -t hellodocker3 /home/shitou/workspace/dockerspace/.
```
**5.删除镜像**  
  当本地存放过多不需要的镜像时，可以通过docker rmi指令将其删除。在删除镜像时，需要指定镜像名称或镜像ID。删除镜像的使用方式如下。
```js
$ docker rmi -f hellodocker2 hellodocker3
```  
  上述指令中，docker rmi表示删除镜像，-f表示进行强制删除，而hellodocker2和hellodocker3分别表示需要删除的镜像名称，这里同时删除两个镜像。除了根据名称删除镜像外，还也可以根据镜像ID来删除镜像，只是这里如果指定了删除ID为23c617a866d4的镜像后，会同时删除hellodocker、hellodocker2和hellodocker3三个镜像。  
  需要特别强调的是，在进行镜像删除操作时，如果是通过镜像ID进行镜像删除，那么由该镜像创建的容器必须提前删除或停止。另外，在通过镜像名称操作镜像时，如果出现镜像重名的情况，必须在镜像名称后面指定镜像标签tag参数来确保唯一性。

**6.创建并启动容器**  
  Docker镜像主要用于创建容器，可以使用docker run指令创建并启动容器，具体使用方式如下。
```js
$ docker run -d -p 5000:80 --name test hellodocker
```  
  上述创建并启动容器的指令略微复杂，具体分析如下。  
  ●docker run：表示创建并启动一个容器，而后面的hellodocker就表示要启动运行的镜像名称；  
  ●-d：表示容器启动时在后台运行；  
  ●-p 5000:80：表示将容器内暴露的80端口映射到宿主机指定的5000端口，也可以将-p 5000:80更改为-P来映射主机的随机端口（注意p字母的大小写）；  
  ●--name test：表示为创建后的容器指定名称为test，如果没有该参数配置，则生成的容器会设置一个随机名称。  
  docker run命令是Docker操作中较为复杂的一个，它可以携带多个参数和参数，我们可以通过docker run --help指令进行查看，其中有些参数如-e、-v和-w等都可以在Dockerfile文件中预先声明。 
 
**7.列出容器**  
  生成容器后，可以通过docker ps指令查看当前运行的所有容器，具体使用方式如下。
```js
$ docker ps
```  
  执行上述命令后，会将所有当前运行的容器都展示出来，具体如下图所示。
![alt](/article_img/docker/5.png)
  从图中可以看出，系统终端通过7列对当前的正在运行的一个容器进行了展示，图中每一列的具体含义如下。  
  ●CONTAINER ID：表示生成的容器ID；  
  ●IMAGE：表示生成该容器的镜像名称；  
  ●COMMAND：表示启动容器时运行的命令，Docker要求在启动容器时必须运行一个命令；  
  ●CREATED：表示容器创建的时间；  
  ●STATUS：表示容器运行状态，例如Up表示运行中，Exited表示已停止；  
  ●PORTS：表示容器内部暴露的端口映射到主机的端口；  
  ●NAMES：表示生成容器的名称，由Docker引擎自动生成，可以像上述示例中使用--name参数指定生成容器的名称。  
  另外，docker ps指令运行过程中可以指定多个参数，还可以通过docker ps --help指令对ps指令的其他信息进行查看。

**8.删除容器**  
  当不需要使用容器时，则可以使用docker rm指令删除已停止的容器，具体使用方式如下。
```js
$ docker rm f0c9a8b6e8c5
```  
  需要注意的是，上述指令只能删除已经停止运行的容器，而不能删除正在运行的容器。如果想要删除正在运行的容器，则需要添加-f参数强制删除，具体使用方式如下。
```js
$ docker rm -f f0c9a8b6e8c5
```  
  当需要删除的容器过多时，如果还一个个的删除就略显麻烦了，此时可以通过如下指令将全部容器删除。
```js
$ docker rm -f $(docker ps -aq)
```  
  上述指令中，首先会通过$(docker ps -aq)获取所有容器的ID，然后通过docker rm -f指令进行强制删除。如果开发者有自己特殊的删除需求，可以根据前面docker ps指令进行组装来获取需要删除的容器ID。  
  Docker提供的操作指令远不止这些，这里就不一一列举了，想要了解更多Docker的操作指令，可以通过docker --help指令进行查看。


, 2018-12-05, null, 默认分类, Docker,客户端指令, true, null, 21, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20017, rs-50017} Result: [9, 虚拟化容器技术——Docker运行机制介绍,   Docker是一个开源的应用容器引擎，它基于go语言开发，并遵从Apache2.0开源协议。使用Docker可以让开发者封装他们的应用以及依赖包到一个可移植的容器中，然后发布到任意的Linux机器上，也可以实现虚拟化。Docker容器完全使用沙箱机制，相互之间不会有任何接口，这保证了容器之间的安全性。  

**1. Docker的引擎介绍**

  Docker Engine（Docker引擎）是Docker的核心部分，使用的是客户端-服务器（C/S）架构模式，其主要组成部分如下图所示。
![alt](/article_img/docker/1.png)
  从上图可以看出，Docker Engine中包含了三个核心组件（docker CLI、REST API和docker daemon），这三个组件的具体说明如下：  
  ①docker CLI（command line interface）：表示Docker命令行接口，开发者可以在命令行中使用Docker相关指令与Docker守护进程进行交互，从而管理诸如image（镜像）、container（容器）、network（网络）和data volumes（数据卷）等实体。  
  ②REST API：表示应用程序API接口，开发者通过该API接口可以与Docker的守护进程进行交互，从而指示后台进行相关操作。  
  ③docker daemon：表示Docker的服务端组件，他是Docker架构中运行在后台的一个守护进程，可以接收并处理来自命令行接口及API接口的指令，然后进行相应的后台操作。  
  对于开发者而言，既可以使用编写好的脚本文件通过REST API来实现与Docker进程交互，又可以直接使用Docker相关指令通过命令行接口来与Docker进程交互，而其他一些Docker应用则是通过底层的API和CLI进行交互的。

**2. Docker的架构介绍**

  了解了Docker内部引擎及作用后，我们还需要通过Docker的具体架构，来了解Docker的整个运行流程。接下来借助Docker官网的架构图来对Docker架构进行详细说明，如下图所示。
![alt](/article_img/docker/2.jpg)
  从图中可以看出，Docker架构主要包括Client、DOCKER_HOST和Register三部分，关于这三部分的具体说明如下。  
&emsp;&emsp;**（1）Client（客户端）**  
  Client即Docker客户端，也就是上一小节Docker Engine中介绍的docker CLI。开发者通过这个客户端使用Docker的相关指令与Docker守护进程进行交互，从而进行Docker镜像的创建、拉取和运行等操作。  
&emsp;&emsp;**（2）DOCKER_HOST（Docker主机）**  
  DOCKER_HOST即Docker内部引擎运行的主机，主要指Docker daemon（Docker守护进程）。可以通过Docker守护进程与客户端还有Docker的镜像仓库Registry进行交互，从而管理Images（镜像）和Containers（容器）等。  
&emsp;&emsp;**（3）Registry（注册中心）**  
  Registry即Docker注册中心，实质就是Docker镜像仓库，默认使用的是Docker官方远程注册中心Docker Hub，也可以使用开发者搭建的本地仓库。Registry中包含了大量的镜像，这些镜像可以是官网基础镜像，也可以是其他开发者上传的镜像。  
  我们在实际使用Docker时，除了会涉及到图中的三个主要部分外，还会涉及到很多Docker Objects（Docker对象），例如Images（镜像）、Containers（容器）、Networks（网络）、Volumes（数据卷）、Plugins（插件）等。其中常用的两个对象Image和Containers的说明如下。  
  ①Images（镜像）  
  Docker 镜像就是一个只读的模板，包含了一些创建Docker容器的操作指令。通常情况下，一个Docker镜像是基于另一个基础镜像创建的，并且新创建的镜像会额外包含一些功能配置。例如：开发者可以依赖于一个Ubuntu的基础镜像创建一个新镜像，并可以在新镜像中安装Apache等软件或其它应用程序。  
  ②Containers（容器）  
  Docker容器属于镜像的一个可运行实例（镜像与容器的关系其实与Java中的类与对象相似），开发者可以通过API接口或者CLI命令行接口来创建、运行、停止、移动、删除一个容器，也可以将一个容器连接到一个或多个网络中，将数据存储与容器进行关联。



, 2018-12-03, null, 默认分类, 虚拟化容器,Docker,运行机制, true, null, 26, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20017, rs-50017} Result: [8, JDK 8——聚合操作, &emsp;&emsp;在Java8版本中，JDK包含许多聚合操作（如平均值，总和，最小，最大，和计数），返回一个计算流stream的聚合结果。这些聚合操作被称为聚合操作。JDK除返回单个值的聚合操作外，还有很多聚合操作返回一个collection集合实例。很多的reduce操作执行特定的任务，如求平均值或按类别分组元素。  

**1. 聚合操作简介**

  在开发中，多数情况下会涉及到对集合、数组中元素的操作，在JDK 8之前都是通过普通的循环遍历出每一个元素，然后还会穿插一些if条件语句选择性的对元素进行查找、过滤、修改等操作，这种原始的操作方法虽然可行，但是代码量较大并且执行效率较低。  
  为此，JDK 8中新增了一个Stream接口，该接口可以将集合、数组的中的元素转换为Stream流的形式，并结合Lambda表达式的优势来进一步简化集合、数组中元素的查找、过滤、转换等操作，这一新功能就是JDK 8中的聚合操作。  
  在程序中，使用聚合操作没有绝对的语法规范，根据实际操作流程，主要可以分为以下3个步骤：  
  （1）将原始集合或者数组对象转换为Stream流对象；  
  （2）对Stream流对象中的元素进行一系列的过滤、查找等中间操作（Intermediate Operations），然后仍然返回一个Stream流对象；  
  （3）对Stream流进行遍历、统计、收集等终结操作（Terminal Operation），获取想要的结果。  
  接下来，就根据上面聚合操作的3个步骤，通过一个案例来演示聚合操作的基本用法，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example31 {
 4		public static void main(String[] args) {
 5	          // 创建一个List集合对象
 6			List<String> list = new ArrayList<>(); 
 7			list.add("张三");
 8			list.add("李四");
 9			list.add("张小明");
 10			list.add("张阳");
 11			// 1、创建一个Stream流对象
 12			Stream<String> stream = list.stream();
 13			// 2、对Stream流中的元素分别进行过滤、截取操作
 14		       Stream<String> stream2 = stream.filter(i -> i.startsWith("张"));
 15			Stream<String> stream3 = stream2.limit(2);
 16			// 3、对Stream流中的元素进行终结操作，进行遍历输出
 17			stream3.forEach(j -> System.out.println(j));
 18			System.out.println("=======");
 19	         // 通过链式表达式的形式完成聚合操作
 20			list.stream().filter(i -> i.startsWith("张"))
 21						 .limit(2)
 22						 .forEach(j -> System.out.println(j));
 23		}
 24	}
``` 
   运行结果如下图所示。
![alt](/article_img/lambda/3.jpg)
  上述示例代码中，先创建了一个List集合，然后根据聚合操作的3个步骤实现了集合对象的聚合操作，对集合中的元素使用Stream流的形式进行过滤（filter）、截取（limit），并进行遍历输出。其中第12~17行代码分步骤详细展示了聚合操作，而第20~22行代码是使用了链式表达式（调用有返回值的方法时不获取返回值而是直接再调用另一个方法）实现了聚合操作，该表达式的语法格式更简洁、高效，这种链式调用也被称为操作管道流。

**2. 创建Stream流对象**  
  在上一小节中，介绍了聚合操作的主要使用步骤，其中首要解决的问题就是创建Stream流对象。聚合操作针对的就是可迭代数据进行的操作，如集合、数组等，所以创建Stream流对象其实就是将集合、数组等通过一些方法转换为Stream流对象。  
  在Java中，集合对象有对应的集合类，可以通过集合类提供的静态方法创建Stream流对象，而数组数据却没有对应的数组类，所以必须通过其他方法创建Stream流对象。针对不同的源数据，Java提供了多种创建Stream流对象的方式，分别如下：  
  （1）所有的Collections集合都可以使用stream()静态方法获取Stream流对象；  
  （2）Stream接口的of()静态方法可以获取基本类型包装类数组、引用类型数组和单个元素的Stream流对象；  
  （3）Arrays数组工具类的stream()静态方法也可以获取数组元素的Stream流对象。  
  接下来，通过一个案例来学习聚合操作中如何创建Stream流对象，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example32 {
 4		public static void main(String[] args) {
 5	          // 创建一个数组
 6			Integer[] array = { 9, 8, 3, 5, 2 };       
 7	          // 将数组转换为List集合
 8			List<Integer> list = Arrays.asList(array); 
 9			// 1、使用集合对象的stream()静态方法创建Stream流对象
 10			Stream<Integer> stream = list.stream();
 11			stream.forEach(i -> System.out.print(i+" "));
 12			System.out.println();
 13			// 2、使用Stream接口的of()静态方法创建Stream流对象
 14			Stream<Integer> stream2 = Stream.of(array);
 15			stream2.forEach(i -> System.out.print(i+" "));
 16			System.out.println();
 17			// 3、使用Arrays数组工具类的stream()静态方法创建Stream流对象
 18			Stream<Integer> stream3 = Arrays.stream(array);
 19			stream3.forEach(i -> System.out.print(i+" "));
 20		}
 21	}
```  
  运行结果如下图所示。
![alt](/article_img/lambda/4.jpg)
  上述示例代码中，先创建了一个数组和一个集合，然后通过三种方式实现了Stream流对象的创建，并通过Stream流对象的forEach()方法结合Lambda表达式完成了集合和数组中元素的遍历。  

**小提示：**  
  在JDK 8中，只针对单列集合Collections接口对象提供了stream()静态方法获取Stream流对象，并未对Map集合提供相关方法获取Stream流对象，所以想要用Map集合创建Stream流对象必须先通过Map集合的keySet()、values()、entrySet()等方法将Map集合转换为单列Set集合，然后再使用单列集合的stream()静态方法获取对应键、值集合的Stream流对象。

, 2018-12-02, null, 默认分类, JDK 8,聚合操作, true, null, 36, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20017, rs-50017} Result: [7, 函数式接口, &emsp;&emsp;虽然Lambda表达式可以实现匿名内部类的功能，但在使用时却有一个局限，即接口中有且只有一个抽象方法时才能使用Lamdba表达式代替匿名内部类。这是因为Lamdba表达式是基于函数式接口实现的，所谓函数式接口是指有且仅有一个抽象方法的接口，Lambda表达式就是Java中函数式编程的体现，只有确保接口中有且仅有一个抽象方法，Lambda表达式才能顺利地推导出所实现的这个接口中的方法。  
&emsp;&emsp;在JDK 8中，专门为函数式接口引入了一个@FunctionalInterface注解，该注解只是显示的标注了接口是一个函数式接口，并强制编辑器进行更严格的检查，确保该接口是函数式接口，如果不是函数式接口，那么编译器就会报错，而对程序运行并没有实质上的影响。  
&emsp;&emsp;接下来通过一个案例来演示函数式接口的定义与使用，示例代码如下所示。
```js
 1	// 定义无参、无返回值的函数式接口
 2	@FunctionalInterface
 3	interface Animal {
 4		void shout();
 5	}
 6	// 定义有参、有返回值的函数式接口
 7	interface Calculate {
 8		int sum(int a, int b);
 9	}
 10	public class Example23 {
 11		public static void main(String[] args) {
 12		   // 分别两个函数式接口进行测试
 13		   animalShout(() -> System.out.println("无参、无返回值的函数式接口调用"));
 14		   showSum(10, 20, (x, y) -> x + y);
 15		}
 16		// 创建一个动物叫的方法，并传入接口对象Animal作为参数
 17		private static void animalShout(Animal animal) {
 18			animal.shout();
 19		}
 20		// 创建一个求和的方法，并传入两个int类型以及接口Calculate类型的参数
 21		private static void showSum(int x, int y, Calculate calculate) {
 22		   System.out.println(x + "+" + y + "的和为：" + calculate.sum(x, y));
 23		}
 24	}
```  
&emsp;&emsp;运行结果如下图所示。

![alt](/article_img/lambda/2.jpg)
&emsp;&emsp;上述代码示例中，先定义了两个函数式接口Animal和Calculate，然后在测试类中分别编写了两个静态方法，并将这两个函数式接口以参数的形式传入，最后在main()方法中分别调用这两个静态方法，并将所需要的函数式接口参数以Lambda表达式的形式传入。从图中可以看出，程序中函数式接口的定义和使用完全正确。
, 2018-12-01, null, 默认分类, 接口,函数式接口, true, null, 12, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20017, rs-50017} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20017} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][com.boot.controller.adminController]2021-05-22 23:15:38   用户名：admin进入文章编辑页面
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20018} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail
    FROM
    t_article
    WHERE
	t_article.id = ?
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20018} Parameters : [12]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20018} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20018} executed. 0.5251 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail
    FROM
    t_article
    WHERE
	t_article.id = ?
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20018, rs-50018} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20018, rs-50018} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20018, rs-50018} Result: [12, Spring Boot 2 权威发布,   如果这两天登录 [https://start.spring.io/ ](https://start.spring.io/ )就会发现，Spring Boot 默认版本已经升到了 2.1.0。这是因为 Spring Boot 刚刚发布了 2.1.0 版本，我们来看下 Spring Boot 2 发布以来第一个子版本都发布了哪些内容？  

**2.1 中的新特性**     
  ●将spring-boot-starter-oauth2-oidc-client重命名为spring-boot-starter-oauth2-client命名更简洁  
  ●添加 OAuth2 资源服务 starter，OAuth2 一个用于认证的组件  
  ●支持 ConditionalOnBean 和 ConditionalOnMissingBean 下的参数化容器  
  ●自动配置 applicationTaskExecutor bean 的延迟加载来避免不必要的日志记录  
  ●将 DatabaseDriver＃SAP 重命名为 DatabaseDriver  
  ●跳过重启器不仅适用于 JUnit4，也适用于 JUnit5  
  ●在 Jest HealthIndicator 中使用集群端点  
  ●当 DevTools 禁用重启时添加日志输出  
  ●添加注解：@ConditionalOnMissingServletFilter提高 Servlet Filters 的自动装配。
  
**2.1 中的组件升级**  
  ●升级 Hibernate 5.3，Hibernate 的支持升级到了 5.3  
  ●升级 Tomcat 9 ，支持最新的 tomcat 9  
  ●支持 Java 11，Java 现在更新越来越快，Spring 快赶不上了    
  ●升级 Thymeleaf Extras Springsecurity 到 3.0.4.RELEASE ，thymeleaf-extras-springsecurity 是 Thymeleaf 提供集成 Spring Security 的组件  
  ●升级 Joda Time 2.10.1，Joda-Time， 面向 Java 应用程序的日期/时间库的替代选择，Joda-Time 令时间和日期值变得易于管理、操作和理解。  
  ●升级 Lettuce 5.1.2.RELEASE ，Lettuce 前面说过，传说中 Redis 最快的客户端。  
  ●升级 Reactor Californium-SR2 ，Californium 是物联网云服务的 Java COAP 实现。因此，它更专注的是可扩展性和可用性而不是像嵌入式设备那样关注资源效率。不过，Californium 也适合嵌入式的 JVM。  
  ●升级 Maven Failsafe Plugin 2.22.1 ，Maven 中的测试插件。  
  ●升级 Flyway 5.2.1 ， Flyway是一款开源的数据库版本管理工具  
  ●升级 Aspectj 1.9.2 ，AspectJ 是 Java 中流行的 AOP（Aspect-oriented Programming）编程扩展框架，是 Eclipse 托管给 Apache 基金会的一个开源项目。  
  ●升级 Mysql 8.0.13 ，Mysql 支持到 8。  
  ●...  
  更多的详细内容可以参考这里：[Spring Boot 2.1 Release Notes](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.1-Release-Notes)
, 2018-12-12, 2021-05-21, 默认分类, Spring Boot 2, true, null]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20018, rs-50018} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20018} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20019} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
	order by created desc
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20019} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20019} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20019} executed. 1.3523 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
	order by created desc
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20019, rs-50019} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20019, rs-50019} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20019, rs-50019} Result: [12, Spring Boot 2 权威发布,   如果这两天登录 [https://start.spring.io/ ](https://start.spring.io/ )就会发现，Spring Boot 默认版本已经升到了 2.1.0。这是因为 Spring Boot 刚刚发布了 2.1.0 版本，我们来看下 Spring Boot 2 发布以来第一个子版本都发布了哪些内容？  

**2.1 中的新特性**     
  ●将spring-boot-starter-oauth2-oidc-client重命名为spring-boot-starter-oauth2-client命名更简洁  
  ●添加 OAuth2 资源服务 starter，OAuth2 一个用于认证的组件  
  ●支持 ConditionalOnBean 和 ConditionalOnMissingBean 下的参数化容器  
  ●自动配置 applicationTaskExecutor bean 的延迟加载来避免不必要的日志记录  
  ●将 DatabaseDriver＃SAP 重命名为 DatabaseDriver  
  ●跳过重启器不仅适用于 JUnit4，也适用于 JUnit5  
  ●在 Jest HealthIndicator 中使用集群端点  
  ●当 DevTools 禁用重启时添加日志输出  
  ●添加注解：@ConditionalOnMissingServletFilter提高 Servlet Filters 的自动装配。
  
**2.1 中的组件升级**  
  ●升级 Hibernate 5.3，Hibernate 的支持升级到了 5.3  
  ●升级 Tomcat 9 ，支持最新的 tomcat 9  
  ●支持 Java 11，Java 现在更新越来越快，Spring 快赶不上了    
  ●升级 Thymeleaf Extras Springsecurity 到 3.0.4.RELEASE ，thymeleaf-extras-springsecurity 是 Thymeleaf 提供集成 Spring Security 的组件  
  ●升级 Joda Time 2.10.1，Joda-Time， 面向 Java 应用程序的日期/时间库的替代选择，Joda-Time 令时间和日期值变得易于管理、操作和理解。  
  ●升级 Lettuce 5.1.2.RELEASE ，Lettuce 前面说过，传说中 Redis 最快的客户端。  
  ●升级 Reactor Californium-SR2 ，Californium 是物联网云服务的 Java COAP 实现。因此，它更专注的是可扩展性和可用性而不是像嵌入式设备那样关注资源效率。不过，Californium 也适合嵌入式的 JVM。  
  ●升级 Maven Failsafe Plugin 2.22.1 ，Maven 中的测试插件。  
  ●升级 Flyway 5.2.1 ， Flyway是一款开源的数据库版本管理工具  
  ●升级 Aspectj 1.9.2 ，AspectJ 是 Java 中流行的 AOP（Aspect-oriented Programming）编程扩展框架，是 Eclipse 托管给 Apache 基金会的一个开源项目。  
  ●升级 Mysql 8.0.13 ，Mysql 支持到 8。  
  ●...  
  更多的详细内容可以参考这里：[Spring Boot 2.1 Release Notes](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.1-Release-Notes)
, 2018-12-12, 2021-05-21, 默认分类, Spring Boot 2, true, null, 62, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20019, rs-50019} Result: [11, Docker数据管理介绍,   当我们对容器进行相关操作时，产生的一系列数据都会存储在容器中，而Docker内部又是如果管理这些数据的呢？本篇文章将针对Docker数据管理的一些知识进行介绍。
  
**1. Docker数据存储机制**  
  使用Docker时，我们操作的都是镜像和由镜像生成的容器，所以想要更好的了解Docker内部的数据存储机制，就必须从镜像、容器与数据存储的关系出发。  
  Docker镜像是通过读取Dockerfile文件中的指令构建的，Dockerfile中的每条指令都会创建一个镜像层，并且每层都是只读的，这一系列的镜像层就构成了Docker镜像。接下来以一个Dockerfile文件为例进行说明，具体如下列代码示例所示。
```js
 1	FROM ubuntu:16.04
 2	COPY . /app
 3	RUN make /app
 4	CMD python /app/app.py
```  
   上述文件示例中的Dockerfile包含了4条指令，每条指令都会创建一个镜像层，其中每一层与前一层都有所不同，并且是层层叠加的。通过镜像构建容器时，会在镜像层上增加一个容器层（即可写层），所有对容器的更改都会写入容器层，这也是Docker默认的数据存储方式。  
  下面通过一个效果图进行说明，具体如下图所示。
![alt](/article_img/docker/6.png)
  从图中可以看出，Docker容器和镜像之间的主要区别是顶部的容器层，而所有对容器中数据的添加、修改等操作都会被存储在容器层中。当容器被删除时，容器层也会被删除，其中存储的数据会被一同删除，而下面的镜像层却保持不变。  
  由于所有的容器都是通过镜像构建的，所以每个容器都有各自的容器层，对于容器数据的更改就会保存在各自的容器层中。也就是说，由同一个镜像构建的多个容器，它们会拥有相同的底部镜像层，而拥有不同的容器层，多个容器可以访问相同的镜像层，并且有自己的独立数据状态。具体说明如下图所示。 
![alt](/article_img/docker/7.png)
  从图中可以看出，基于同一个镜像构建的多个容器可以共享该镜像层，但是多个容器想要共享相同的数据，就需要将这些数据存储到容器之外的地方，而这种方式就是下一节要提到的Docker volume数据外部挂载机制。  

**2. Docker数据存储方式**    
  在默认情况下，Docker中的数据都是存放在容器层的，但是这样存储数据却有较多的缺陷，具体表现如下。    
  ●当容器不再运行时，容器中的数据无法持久化保存，如果另一个进程需要这些数据，那么将很难从容器中获取数据；  
  ●容器层与正在运行的主机紧密耦合，不能轻易地移动数据；  
  ●容器层需要一个存储驱动程序来管理文件系统，存储驱动程序提供了一个使用Linux内核的联合文件系统，这种额外的抽象化降低了性能。  
  基于上述种种原因，多数情况下Docker数据管理都不会直接将数据写入容器层，而是使用另一种叫做Docker volume数据外部挂载的机制进行数据管理。  
  针对Docker volume数据外部挂载机制，Docker提供了三种不同的方式将数据从容器映射到Docker宿主机，他们分别为：volumes（数据卷）、bind mounts（绑定挂载）和tmpfs mounts（tmpfs挂载）。这三种数据管理方式的具体选择，需要结合实际情况进行考虑，其中的volumes数据卷是最常用也是官方推荐的数据管理方式。无论选择使用哪种数据管理方式，数据在容器内看起来都一样的，而在容器外则会被被挂载到文件系统中的某个目录或文件中。    
  下面通过一张图来展示数据卷、绑定挂载和tmpfs挂载之间的差异，如下图所示。  
![alt](/article_img/docker/8.png)
  从图中可以看出，Docker提供的三种数据管理方式略有不同，具体分析如下。  
  ●volumes：存储在主机文件系统中（在Linux系统下是存在于/var/lib/Docker/volumes/目录），并由Docker管理，非Docker进程无法修改文件系统的这个部分。  
  ●bind mounts：可以存储在主机系统的任意位置，甚至可能是重要的系统文件或目录，在Docker主机或容器上的非Docker进程可以对他们进行任意修改。  
  ●tmpfs mounts：只存储在主机系统的内存中，并没有写入到主机的文件系统中。


, 2018-12-07, 2021-05-19, 默认分类, Docker,数据管理, true, null, 19, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20019, rs-50019} Result: [10, Docker常用客户端指令介绍,   在使用Docker之前，首先会为对应的项目编写Dockerfile镜像构建文件，然后通过Docker的相关指令进行镜像构建，完成镜像的构建后，就可以使用这些项目镜像进行启动测试了。所以要想知道如何使用Docker来执行这些Dockerfile镜像构建文件，还需要学习Docker客户端的常用指令，本篇文章将对Docker客户端的常用指令进行详细讲解。  

**1.列出镜像**  
  通过docker images指令可以查看本地镜像列表中已有的镜像，具体使用方式如下。
```js
$ docker images
```  
  执行上述指令后，系统会将所有本地镜像都展示出来，如下图所示。
![alt](/article_img/docker/3.png)
  从图中可以看出，系统终端将本地镜像列表中的3个镜像分5列进行了展示，每一列的具体含义如下。  
  ●REPOSITORY：镜像名称。  
  ●TAG：镜像的参数，类似于版本号，默认是latest。  
  ●IMAGE ID：镜像ID，是唯一值。此处看到的是一个长度为12的字符串，实际上它是64位完整镜像ID的缩写形式。  
  ●CREATED：距今创建镜像的时间。  
  ●SIZE：镜像大小。    

**2.搜索镜像**  
  想知道在Docker Hub中包含了哪些镜像，除了可以登录Docker Hub，在官网中心进行查看外，还可以直接在Docker客户端进行查询。例如想要查询Ubuntu镜像，可以使用如下指令。
```js
$ docker search ubuntu
```  
  执行上述指令后，系统终端就会将搜索到的有关Ubuntu的镜像展示出来，如下图所示。
![alt](/article_img/docker/4.png)
  从图所示的结果可以看出，系统终端分5列将搜索到的Ubuntu相关镜像都列举出来了，这5列的具体含义如下。  
  ●NAME：表示镜像的名称，这里有两种格式的名称，其中不带有“/”的表示官方镜像，而带有“/”的表示其他用户的公开镜像。公开镜像“/”前面是用户在Docker Hub上的用户名（唯一），后面是对应的镜像名；官方镜像与用户镜像，除了从镜像名称上可以区分外，还可以通过第4列的OFFICIAL声明中看出（该列下内容为OK表示官方镜像）。  
  ●DESCRIPTION：表示镜像的描述，这里只显示了一小部分。  
  ●STARS：表示该镜像的收藏数，用户可以在Docker Hub上对镜像进行收藏，一般可以通过该数字反应出该镜像的受欢迎程度。  
  ●OFFICIAL：表示是否为官方镜像。  
  ●AUTOMATED：表示是否自动构建镜像。例如，用户可以将自己的Docker Hub绑定到如Github上，当代码提交更新后，可以自动构建镜像。   
 
**3.拉取镜像**  
  通过docker pull指令可以拉取仓库镜像到本地（默认都是拉取Docker Hub仓库镜像，也可以指定“IP+端口”拉取某个Docker机器上的私有仓库镜像），具体使用方式如下。
```js
$ docker pull ubuntu
```  
  执行上述指令后，Docker会自动从Docker Hub上下载最新版本的Ubuntu到本地，当然也可以使用以下指令拉取指定版本的镜像到本地，具体指令如下。
```js
$ docker pull ubuntu:14.04
```  
**4.构建镜像**  
  除了可以通过docker pull指令从仓库拉取镜像外，还可以通过docker build指令构建Docker镜像，通常情况下都是通过Dockerfile文件来构建镜像的。  
  这里假设linux系统home目录下/shitou/workspace/dockerspace文件夹中编写有对应的Dockerfile文件，则构建镜像直立示例如下所示。 
```js
$ docker build -t hellodocker3 /home/shitou/workspace/dockerspace/.
```
**5.删除镜像**  
  当本地存放过多不需要的镜像时，可以通过docker rmi指令将其删除。在删除镜像时，需要指定镜像名称或镜像ID。删除镜像的使用方式如下。
```js
$ docker rmi -f hellodocker2 hellodocker3
```  
  上述指令中，docker rmi表示删除镜像，-f表示进行强制删除，而hellodocker2和hellodocker3分别表示需要删除的镜像名称，这里同时删除两个镜像。除了根据名称删除镜像外，还也可以根据镜像ID来删除镜像，只是这里如果指定了删除ID为23c617a866d4的镜像后，会同时删除hellodocker、hellodocker2和hellodocker3三个镜像。  
  需要特别强调的是，在进行镜像删除操作时，如果是通过镜像ID进行镜像删除，那么由该镜像创建的容器必须提前删除或停止。另外，在通过镜像名称操作镜像时，如果出现镜像重名的情况，必须在镜像名称后面指定镜像标签tag参数来确保唯一性。

**6.创建并启动容器**  
  Docker镜像主要用于创建容器，可以使用docker run指令创建并启动容器，具体使用方式如下。
```js
$ docker run -d -p 5000:80 --name test hellodocker
```  
  上述创建并启动容器的指令略微复杂，具体分析如下。  
  ●docker run：表示创建并启动一个容器，而后面的hellodocker就表示要启动运行的镜像名称；  
  ●-d：表示容器启动时在后台运行；  
  ●-p 5000:80：表示将容器内暴露的80端口映射到宿主机指定的5000端口，也可以将-p 5000:80更改为-P来映射主机的随机端口（注意p字母的大小写）；  
  ●--name test：表示为创建后的容器指定名称为test，如果没有该参数配置，则生成的容器会设置一个随机名称。  
  docker run命令是Docker操作中较为复杂的一个，它可以携带多个参数和参数，我们可以通过docker run --help指令进行查看，其中有些参数如-e、-v和-w等都可以在Dockerfile文件中预先声明。 
 
**7.列出容器**  
  生成容器后，可以通过docker ps指令查看当前运行的所有容器，具体使用方式如下。
```js
$ docker ps
```  
  执行上述命令后，会将所有当前运行的容器都展示出来，具体如下图所示。
![alt](/article_img/docker/5.png)
  从图中可以看出，系统终端通过7列对当前的正在运行的一个容器进行了展示，图中每一列的具体含义如下。  
  ●CONTAINER ID：表示生成的容器ID；  
  ●IMAGE：表示生成该容器的镜像名称；  
  ●COMMAND：表示启动容器时运行的命令，Docker要求在启动容器时必须运行一个命令；  
  ●CREATED：表示容器创建的时间；  
  ●STATUS：表示容器运行状态，例如Up表示运行中，Exited表示已停止；  
  ●PORTS：表示容器内部暴露的端口映射到主机的端口；  
  ●NAMES：表示生成容器的名称，由Docker引擎自动生成，可以像上述示例中使用--name参数指定生成容器的名称。  
  另外，docker ps指令运行过程中可以指定多个参数，还可以通过docker ps --help指令对ps指令的其他信息进行查看。

**8.删除容器**  
  当不需要使用容器时，则可以使用docker rm指令删除已停止的容器，具体使用方式如下。
```js
$ docker rm f0c9a8b6e8c5
```  
  需要注意的是，上述指令只能删除已经停止运行的容器，而不能删除正在运行的容器。如果想要删除正在运行的容器，则需要添加-f参数强制删除，具体使用方式如下。
```js
$ docker rm -f f0c9a8b6e8c5
```  
  当需要删除的容器过多时，如果还一个个的删除就略显麻烦了，此时可以通过如下指令将全部容器删除。
```js
$ docker rm -f $(docker ps -aq)
```  
  上述指令中，首先会通过$(docker ps -aq)获取所有容器的ID，然后通过docker rm -f指令进行强制删除。如果开发者有自己特殊的删除需求，可以根据前面docker ps指令进行组装来获取需要删除的容器ID。  
  Docker提供的操作指令远不止这些，这里就不一一列举了，想要了解更多Docker的操作指令，可以通过docker --help指令进行查看。


, 2018-12-05, null, 默认分类, Docker,客户端指令, true, null, 21, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20019, rs-50019} Result: [9, 虚拟化容器技术——Docker运行机制介绍,   Docker是一个开源的应用容器引擎，它基于go语言开发，并遵从Apache2.0开源协议。使用Docker可以让开发者封装他们的应用以及依赖包到一个可移植的容器中，然后发布到任意的Linux机器上，也可以实现虚拟化。Docker容器完全使用沙箱机制，相互之间不会有任何接口，这保证了容器之间的安全性。  

**1. Docker的引擎介绍**

  Docker Engine（Docker引擎）是Docker的核心部分，使用的是客户端-服务器（C/S）架构模式，其主要组成部分如下图所示。
![alt](/article_img/docker/1.png)
  从上图可以看出，Docker Engine中包含了三个核心组件（docker CLI、REST API和docker daemon），这三个组件的具体说明如下：  
  ①docker CLI（command line interface）：表示Docker命令行接口，开发者可以在命令行中使用Docker相关指令与Docker守护进程进行交互，从而管理诸如image（镜像）、container（容器）、network（网络）和data volumes（数据卷）等实体。  
  ②REST API：表示应用程序API接口，开发者通过该API接口可以与Docker的守护进程进行交互，从而指示后台进行相关操作。  
  ③docker daemon：表示Docker的服务端组件，他是Docker架构中运行在后台的一个守护进程，可以接收并处理来自命令行接口及API接口的指令，然后进行相应的后台操作。  
  对于开发者而言，既可以使用编写好的脚本文件通过REST API来实现与Docker进程交互，又可以直接使用Docker相关指令通过命令行接口来与Docker进程交互，而其他一些Docker应用则是通过底层的API和CLI进行交互的。

**2. Docker的架构介绍**

  了解了Docker内部引擎及作用后，我们还需要通过Docker的具体架构，来了解Docker的整个运行流程。接下来借助Docker官网的架构图来对Docker架构进行详细说明，如下图所示。
![alt](/article_img/docker/2.jpg)
  从图中可以看出，Docker架构主要包括Client、DOCKER_HOST和Register三部分，关于这三部分的具体说明如下。  
&emsp;&emsp;**（1）Client（客户端）**  
  Client即Docker客户端，也就是上一小节Docker Engine中介绍的docker CLI。开发者通过这个客户端使用Docker的相关指令与Docker守护进程进行交互，从而进行Docker镜像的创建、拉取和运行等操作。  
&emsp;&emsp;**（2）DOCKER_HOST（Docker主机）**  
  DOCKER_HOST即Docker内部引擎运行的主机，主要指Docker daemon（Docker守护进程）。可以通过Docker守护进程与客户端还有Docker的镜像仓库Registry进行交互，从而管理Images（镜像）和Containers（容器）等。  
&emsp;&emsp;**（3）Registry（注册中心）**  
  Registry即Docker注册中心，实质就是Docker镜像仓库，默认使用的是Docker官方远程注册中心Docker Hub，也可以使用开发者搭建的本地仓库。Registry中包含了大量的镜像，这些镜像可以是官网基础镜像，也可以是其他开发者上传的镜像。  
  我们在实际使用Docker时，除了会涉及到图中的三个主要部分外，还会涉及到很多Docker Objects（Docker对象），例如Images（镜像）、Containers（容器）、Networks（网络）、Volumes（数据卷）、Plugins（插件）等。其中常用的两个对象Image和Containers的说明如下。  
  ①Images（镜像）  
  Docker 镜像就是一个只读的模板，包含了一些创建Docker容器的操作指令。通常情况下，一个Docker镜像是基于另一个基础镜像创建的，并且新创建的镜像会额外包含一些功能配置。例如：开发者可以依赖于一个Ubuntu的基础镜像创建一个新镜像，并可以在新镜像中安装Apache等软件或其它应用程序。  
  ②Containers（容器）  
  Docker容器属于镜像的一个可运行实例（镜像与容器的关系其实与Java中的类与对象相似），开发者可以通过API接口或者CLI命令行接口来创建、运行、停止、移动、删除一个容器，也可以将一个容器连接到一个或多个网络中，将数据存储与容器进行关联。



, 2018-12-03, null, 默认分类, 虚拟化容器,Docker,运行机制, true, null, 26, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20019, rs-50019} Result: [8, JDK 8——聚合操作, &emsp;&emsp;在Java8版本中，JDK包含许多聚合操作（如平均值，总和，最小，最大，和计数），返回一个计算流stream的聚合结果。这些聚合操作被称为聚合操作。JDK除返回单个值的聚合操作外，还有很多聚合操作返回一个collection集合实例。很多的reduce操作执行特定的任务，如求平均值或按类别分组元素。  

**1. 聚合操作简介**

  在开发中，多数情况下会涉及到对集合、数组中元素的操作，在JDK 8之前都是通过普通的循环遍历出每一个元素，然后还会穿插一些if条件语句选择性的对元素进行查找、过滤、修改等操作，这种原始的操作方法虽然可行，但是代码量较大并且执行效率较低。  
  为此，JDK 8中新增了一个Stream接口，该接口可以将集合、数组的中的元素转换为Stream流的形式，并结合Lambda表达式的优势来进一步简化集合、数组中元素的查找、过滤、转换等操作，这一新功能就是JDK 8中的聚合操作。  
  在程序中，使用聚合操作没有绝对的语法规范，根据实际操作流程，主要可以分为以下3个步骤：  
  （1）将原始集合或者数组对象转换为Stream流对象；  
  （2）对Stream流对象中的元素进行一系列的过滤、查找等中间操作（Intermediate Operations），然后仍然返回一个Stream流对象；  
  （3）对Stream流进行遍历、统计、收集等终结操作（Terminal Operation），获取想要的结果。  
  接下来，就根据上面聚合操作的3个步骤，通过一个案例来演示聚合操作的基本用法，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example31 {
 4		public static void main(String[] args) {
 5	          // 创建一个List集合对象
 6			List<String> list = new ArrayList<>(); 
 7			list.add("张三");
 8			list.add("李四");
 9			list.add("张小明");
 10			list.add("张阳");
 11			// 1、创建一个Stream流对象
 12			Stream<String> stream = list.stream();
 13			// 2、对Stream流中的元素分别进行过滤、截取操作
 14		       Stream<String> stream2 = stream.filter(i -> i.startsWith("张"));
 15			Stream<String> stream3 = stream2.limit(2);
 16			// 3、对Stream流中的元素进行终结操作，进行遍历输出
 17			stream3.forEach(j -> System.out.println(j));
 18			System.out.println("=======");
 19	         // 通过链式表达式的形式完成聚合操作
 20			list.stream().filter(i -> i.startsWith("张"))
 21						 .limit(2)
 22						 .forEach(j -> System.out.println(j));
 23		}
 24	}
``` 
   运行结果如下图所示。
![alt](/article_img/lambda/3.jpg)
  上述示例代码中，先创建了一个List集合，然后根据聚合操作的3个步骤实现了集合对象的聚合操作，对集合中的元素使用Stream流的形式进行过滤（filter）、截取（limit），并进行遍历输出。其中第12~17行代码分步骤详细展示了聚合操作，而第20~22行代码是使用了链式表达式（调用有返回值的方法时不获取返回值而是直接再调用另一个方法）实现了聚合操作，该表达式的语法格式更简洁、高效，这种链式调用也被称为操作管道流。

**2. 创建Stream流对象**  
  在上一小节中，介绍了聚合操作的主要使用步骤，其中首要解决的问题就是创建Stream流对象。聚合操作针对的就是可迭代数据进行的操作，如集合、数组等，所以创建Stream流对象其实就是将集合、数组等通过一些方法转换为Stream流对象。  
  在Java中，集合对象有对应的集合类，可以通过集合类提供的静态方法创建Stream流对象，而数组数据却没有对应的数组类，所以必须通过其他方法创建Stream流对象。针对不同的源数据，Java提供了多种创建Stream流对象的方式，分别如下：  
  （1）所有的Collections集合都可以使用stream()静态方法获取Stream流对象；  
  （2）Stream接口的of()静态方法可以获取基本类型包装类数组、引用类型数组和单个元素的Stream流对象；  
  （3）Arrays数组工具类的stream()静态方法也可以获取数组元素的Stream流对象。  
  接下来，通过一个案例来学习聚合操作中如何创建Stream流对象，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example32 {
 4		public static void main(String[] args) {
 5	          // 创建一个数组
 6			Integer[] array = { 9, 8, 3, 5, 2 };       
 7	          // 将数组转换为List集合
 8			List<Integer> list = Arrays.asList(array); 
 9			// 1、使用集合对象的stream()静态方法创建Stream流对象
 10			Stream<Integer> stream = list.stream();
 11			stream.forEach(i -> System.out.print(i+" "));
 12			System.out.println();
 13			// 2、使用Stream接口的of()静态方法创建Stream流对象
 14			Stream<Integer> stream2 = Stream.of(array);
 15			stream2.forEach(i -> System.out.print(i+" "));
 16			System.out.println();
 17			// 3、使用Arrays数组工具类的stream()静态方法创建Stream流对象
 18			Stream<Integer> stream3 = Arrays.stream(array);
 19			stream3.forEach(i -> System.out.print(i+" "));
 20		}
 21	}
```  
  运行结果如下图所示。
![alt](/article_img/lambda/4.jpg)
  上述示例代码中，先创建了一个数组和一个集合，然后通过三种方式实现了Stream流对象的创建，并通过Stream流对象的forEach()方法结合Lambda表达式完成了集合和数组中元素的遍历。  

**小提示：**  
  在JDK 8中，只针对单列集合Collections接口对象提供了stream()静态方法获取Stream流对象，并未对Map集合提供相关方法获取Stream流对象，所以想要用Map集合创建Stream流对象必须先通过Map集合的keySet()、values()、entrySet()等方法将Map集合转换为单列Set集合，然后再使用单列集合的stream()静态方法获取对应键、值集合的Stream流对象。

, 2018-12-02, null, 默认分类, JDK 8,聚合操作, true, null, 36, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20019, rs-50019} Result: [7, 函数式接口, &emsp;&emsp;虽然Lambda表达式可以实现匿名内部类的功能，但在使用时却有一个局限，即接口中有且只有一个抽象方法时才能使用Lamdba表达式代替匿名内部类。这是因为Lamdba表达式是基于函数式接口实现的，所谓函数式接口是指有且仅有一个抽象方法的接口，Lambda表达式就是Java中函数式编程的体现，只有确保接口中有且仅有一个抽象方法，Lambda表达式才能顺利地推导出所实现的这个接口中的方法。  
&emsp;&emsp;在JDK 8中，专门为函数式接口引入了一个@FunctionalInterface注解，该注解只是显示的标注了接口是一个函数式接口，并强制编辑器进行更严格的检查，确保该接口是函数式接口，如果不是函数式接口，那么编译器就会报错，而对程序运行并没有实质上的影响。  
&emsp;&emsp;接下来通过一个案例来演示函数式接口的定义与使用，示例代码如下所示。
```js
 1	// 定义无参、无返回值的函数式接口
 2	@FunctionalInterface
 3	interface Animal {
 4		void shout();
 5	}
 6	// 定义有参、有返回值的函数式接口
 7	interface Calculate {
 8		int sum(int a, int b);
 9	}
 10	public class Example23 {
 11		public static void main(String[] args) {
 12		   // 分别两个函数式接口进行测试
 13		   animalShout(() -> System.out.println("无参、无返回值的函数式接口调用"));
 14		   showSum(10, 20, (x, y) -> x + y);
 15		}
 16		// 创建一个动物叫的方法，并传入接口对象Animal作为参数
 17		private static void animalShout(Animal animal) {
 18			animal.shout();
 19		}
 20		// 创建一个求和的方法，并传入两个int类型以及接口Calculate类型的参数
 21		private static void showSum(int x, int y, Calculate calculate) {
 22		   System.out.println(x + "+" + y + "的和为：" + calculate.sum(x, y));
 23		}
 24	}
```  
&emsp;&emsp;运行结果如下图所示。

![alt](/article_img/lambda/2.jpg)
&emsp;&emsp;上述代码示例中，先定义了两个函数式接口Animal和Calculate，然后在测试类中分别编写了两个静态方法，并将这两个函数式接口以参数的形式传入，最后在main()方法中分别调用这两个静态方法，并将所需要的函数式接口参数以Lambda表达式的形式传入。从图中可以看出，程序中函数式接口的定义和使用完全正确。
, 2018-12-01, null, 默认分类, 接口,函数式接口, true, null, 12, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20019, rs-50019} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20019, rs-50019} Result: [6, JDK 8——Lambda表达式介绍,   Lambda表达式是JDK 8中一个重要的新特性，它使用一个清晰简洁的表达式来表达一个接口，同时Lambda表达式也简化了对集合以及数组数据的遍历、过滤和提取等操作。下面，本篇文章就对Lambda表达式进行简要介绍，并进行演示说明。

**1. Lambda表达式入门**  

  匿名内部类存在的一个问题是，如果匿名内部类的实现非常简单，例如只包含一个抽象方法的接口，那么匿名内部类的语法仍然显得比较冗余。为此，JDK 8中新增了一个特性Lambda表达式，这种表达式只针对有一个抽象方法的接口实现，以简洁的表达式形式实现接口功能来作为方法参数。  
  一个Lambda表达式由三个部分组成，分别为参数列表、“->”和表达式主体，其语法格式如下：
```js
 ([数据类型 参数名,数据类型 参数名,...]) -> {表达式主体}
```  
  从上述语法格式上看，Lambda表达式的书写非常简单，下面针对Lambda表达式的组成部分进行简单介绍，具体如下：  
  （1）([数据类型 参数名,数据类型 参数名,...])：用来向表达式主体传递接口方法需要的参数，多个参数名中间必须用英文逗号“,”进行分隔；在编写Lambda表达式时，可以省略参数的数据类型，后面的表达式主体会自动进行校对和匹配；同时，如果只有一个参数，则可以省略括号“()”。  
  （2）->：表示Lambda表达式箭牌，用来指定参数数据指向，不能省略，且必须用英文横线和大于号书写。  
  （3）{表达式主体}：由单个表达式或语句块组成的主体，本质就是接口中抽象方法的具体实现，如果表达式主体只有一条语句，那么可以省略包含主体的大括号；另外，在Lambda表达式主体中允许有返回值，当只有一条return语句时，也可以省略return关键字。  
  了解了Lambda表达式的语法后，接下来编写一个示例文件对Lambda表达式的基本使用进行介绍，具体代码如下所示。
```js
 1	// 定义动物类接口
 2	interface Animal { 
 3		void shout(); // 定义方法shout()
 4	}
 5	public class Example22 {
 6		public static void main(String[] args) {
 7	       String name = "小花"; 
 8	       // 1、匿名内部类作为参数传递给animalShout()方法
 9		  animalShout(new Animal() { 
 10				 public void shout() { 
 11				    System.out.println("匿名内部类输出："+name+"喵喵...");
 12				}
 13		  });
 14		  // 2、使用Lambda表达式作为参数传递给animalShout()方法
 15	       animalShout(()-> System.out.println("Lambda表达式输出："
 16	                                                   +name+"喵喵..."));
 17		}
 18	    // 创建一个animalShout()静态方法，接收接口类型的参数
 19		public static void animalShout(Animal an) {
 20			an.shout();  
 21		}
 22	}
```  
  运行结果下图所示。
![alt](/article_img/lambda/1.jpg)
  上述代码示例中，先定义了只有一个抽象方法的接口Animal，然后分别使用匿名内部类和Lambda表达式的方式实现了接口方法。从图中可以看出，使用匿名内部类和Lambda表达式都能实现接口中方法，但很显然使用Lambda表达式更加简洁和清晰。, 2018-11-27, null, 默认分类, 2018,Lambda表达式, true, null, 18, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20019, rs-50019} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20019, rs-50019} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20019, rs-50019} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20019, rs-50019} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20019, rs-50019} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20019} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20020} created. update t_article
         SET title = ?,
            
            
            
                modified = ?,
            
            
                tags = ?,
            
            
                categories = ?,
            
            
                allow_comment = ?,
            
            
            
                content = ? 
        where id = ?
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20020} Parameters : [Spring Boot 2 权威发布, 2021-05-22 23:15:40.171, Spring Boot 2, 默认分类, true,   如果这两天登录 [https://start.spring.io/ ](https://start.spring.io/ )就会发现，Spring Boot 默认版本已经升到了 2.1.0。这是因为 Spring Boot 刚刚发布了 2.1.0 版本，我们来看下 Spring Boot 2 发布以来第一个子版本都发布了哪些内容？  

**2.1 中的新特性**     
  ●将spring-boot-starter-oauth2-oidc-client重命名为spring-boot-starter-oauth2-client命名更简洁  
  ●添加 OAuth2 资源服务 starter，OAuth2 一个用于认证的组件  
  ●支持 ConditionalOnBean 和 ConditionalOnMissingBean 下的参数化容器  
  ●自动配置 applicationTaskExecutor bean 的延迟加载来避免不必要的日志记录  
  ●将 DatabaseDriver＃SAP 重命名为 DatabaseDriver  
  ●跳过重启器不仅适用于 JUnit4，也适用于 JUnit5  
  ●在 Jest HealthIndicator 中使用集群端点  
  ●当 DevTools 禁用重启时添加日志输出  
  ●添加注解：@ConditionalOnMissingServletFilter提高 Servlet Filters 的自动装配。
  
**2.1 中的组件升级**  
  ●升级 Hibernate 5.3，Hibernate 的支持升级到了 5.3  
  ●升级 Tomcat 9 ，支持最新的 tomcat 9  
  ●支持 Java 11，Java 现在更新越来越快，Spring 快赶不上了    
  ●升级 Thymeleaf Extras Springsecurity 到 3.0.4.RELEASE ，thymeleaf-extras-springsecurity 是 Thymeleaf 提供集成 Spring Security 的组件  
  ●升级 Joda Time 2.10.1，Joda-Time， 面向 Java 应用程序的日期/时间库的替代选择，Joda-Time 令时间和日期值变得易于管理、操作和理解。  
  ●升级 Lettuce 5.1.2.RELEASE ，Lettuce 前面说过，传说中 Redis 最快的客户端。  
  ●升级 Reactor Californium-SR2 ，Californium 是物联网云服务的 Java COAP 实现。因此，它更专注的是可扩展性和可用性而不是像嵌入式设备那样关注资源效率。不过，Californium 也适合嵌入式的 JVM。  
  ●升级 Maven Failsafe Plugin 2.22.1 ，Maven 中的测试插件。  
  ●升级 Flyway 5.2.1 ， Flyway是一款开源的数据库版本管理工具  
  ●升级 Aspectj 1.9.2 ，AspectJ 是 Java 中流行的 AOP（Aspect-oriented Programming）编程扩展框架，是 Eclipse 托管给 Apache 基金会的一个开源项目。  
  ●升级 Mysql 8.0.13 ，Mysql 支持到 8。  
  ●...  
  更多的详细内容可以参考这里：[Spring Boot 2.1 Release Notes](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.1-Release-Notes)
, 12]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20020} Types : [VARCHAR, TIMESTAMP, VARCHAR, VARCHAR, BOOLEAN, VARCHAR, INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20020} executed. 17.341 millis. update t_article
         SET title = ?,
            
            
            
                modified = ?,
            
            
                tags = ?,
            
            
                categories = ?,
            
            
                allow_comment = ?,
            
            
            
                content = ? 
        where id = ?
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20020} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][com.boot.controller.adminController]2021-05-22 23:15:40   用户名：admin修改文章信息成功，修改信息的JSON串为：Article{id=12, title='Spring Boot 2 权威发布', content='  如果这两天登录 [https://start.spring.io/ ](https://start.spring.io/ )就会发现，Spring Boot 默认版本已经升到了 2.1.0。这是因为 Spring Boot 刚刚发布了 2.1.0 版本，我们来看下 Spring Boot 2 发布以来第一个子版本都发布了哪些内容？  

**2.1 中的新特性**     
  ●将spring-boot-starter-oauth2-oidc-client重命名为spring-boot-starter-oauth2-client命名更简洁  
  ●添加 OAuth2 资源服务 starter，OAuth2 一个用于认证的组件  
  ●支持 ConditionalOnBean 和 ConditionalOnMissingBean 下的参数化容器  
  ●自动配置 applicationTaskExecutor bean 的延迟加载来避免不必要的日志记录  
  ●将 DatabaseDriver＃SAP 重命名为 DatabaseDriver  
  ●跳过重启器不仅适用于 JUnit4，也适用于 JUnit5  
  ●在 Jest HealthIndicator 中使用集群端点  
  ●当 DevTools 禁用重启时添加日志输出  
  ●添加注解：@ConditionalOnMissingServletFilter提高 Servlet Filters 的自动装配。
  
**2.1 中的组件升级**  
  ●升级 Hibernate 5.3，Hibernate 的支持升级到了 5.3  
  ●升级 Tomcat 9 ，支持最新的 tomcat 9  
  ●支持 Java 11，Java 现在更新越来越快，Spring 快赶不上了    
  ●升级 Thymeleaf Extras Springsecurity 到 3.0.4.RELEASE ，thymeleaf-extras-springsecurity 是 Thymeleaf 提供集成 Spring Security 的组件  
  ●升级 Joda Time 2.10.1，Joda-Time， 面向 Java 应用程序的日期/时间库的替代选择，Joda-Time 令时间和日期值变得易于管理、操作和理解。  
  ●升级 Lettuce 5.1.2.RELEASE ，Lettuce 前面说过，传说中 Redis 最快的客户端。  
  ●升级 Reactor Californium-SR2 ，Californium 是物联网云服务的 Java COAP 实现。因此，它更专注的是可扩展性和可用性而不是像嵌入式设备那样关注资源效率。不过，Californium 也适合嵌入式的 JVM。  
  ●升级 Maven Failsafe Plugin 2.22.1 ，Maven 中的测试插件。  
  ●升级 Flyway 5.2.1 ， Flyway是一款开源的数据库版本管理工具  
  ●升级 Aspectj 1.9.2 ，AspectJ 是 Java 中流行的 AOP（Aspect-oriented Programming）编程扩展框架，是 Eclipse 托管给 Apache 基金会的一个开源项目。  
  ●升级 Mysql 8.0.13 ，Mysql 支持到 8。  
  ●...  
  更多的详细内容可以参考这里：[Spring Boot 2.1 Release Notes](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.1-Release-Notes)
', created=null, modified=2021-05-22, categories='默认分类', tags='Spring Boot 2', allowComment=true, thumbnail='null', statistic=null, comments=null}
[DEBUG][21-05-22][com.boot.controller.adminController]2021-05-22 23:15:43   用户名：admin查看文章列表
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20021} created. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20021} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20021} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20021} executed. 0.4701 millis. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20021, rs-50020} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20021, rs-50020} Header: [count(0)]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20021, rs-50020} Result: [12]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20021, rs-50020} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20021} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20022} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
	order by created desc LIMIT ? 
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20022} Parameters : [6]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20022} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20022} executed. 0.9455 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
	order by created desc LIMIT ? 
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20022, rs-50021} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20022, rs-50021} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20022, rs-50021} Result: [12, Spring Boot 2 权威发布,   如果这两天登录 [https://start.spring.io/ ](https://start.spring.io/ )就会发现，Spring Boot 默认版本已经升到了 2.1.0。这是因为 Spring Boot 刚刚发布了 2.1.0 版本，我们来看下 Spring Boot 2 发布以来第一个子版本都发布了哪些内容？  

**2.1 中的新特性**     
  ●将spring-boot-starter-oauth2-oidc-client重命名为spring-boot-starter-oauth2-client命名更简洁  
  ●添加 OAuth2 资源服务 starter，OAuth2 一个用于认证的组件  
  ●支持 ConditionalOnBean 和 ConditionalOnMissingBean 下的参数化容器  
  ●自动配置 applicationTaskExecutor bean 的延迟加载来避免不必要的日志记录  
  ●将 DatabaseDriver＃SAP 重命名为 DatabaseDriver  
  ●跳过重启器不仅适用于 JUnit4，也适用于 JUnit5  
  ●在 Jest HealthIndicator 中使用集群端点  
  ●当 DevTools 禁用重启时添加日志输出  
  ●添加注解：@ConditionalOnMissingServletFilter提高 Servlet Filters 的自动装配。
  
**2.1 中的组件升级**  
  ●升级 Hibernate 5.3，Hibernate 的支持升级到了 5.3  
  ●升级 Tomcat 9 ，支持最新的 tomcat 9  
  ●支持 Java 11，Java 现在更新越来越快，Spring 快赶不上了    
  ●升级 Thymeleaf Extras Springsecurity 到 3.0.4.RELEASE ，thymeleaf-extras-springsecurity 是 Thymeleaf 提供集成 Spring Security 的组件  
  ●升级 Joda Time 2.10.1，Joda-Time， 面向 Java 应用程序的日期/时间库的替代选择，Joda-Time 令时间和日期值变得易于管理、操作和理解。  
  ●升级 Lettuce 5.1.2.RELEASE ，Lettuce 前面说过，传说中 Redis 最快的客户端。  
  ●升级 Reactor Californium-SR2 ，Californium 是物联网云服务的 Java COAP 实现。因此，它更专注的是可扩展性和可用性而不是像嵌入式设备那样关注资源效率。不过，Californium 也适合嵌入式的 JVM。  
  ●升级 Maven Failsafe Plugin 2.22.1 ，Maven 中的测试插件。  
  ●升级 Flyway 5.2.1 ， Flyway是一款开源的数据库版本管理工具  
  ●升级 Aspectj 1.9.2 ，AspectJ 是 Java 中流行的 AOP（Aspect-oriented Programming）编程扩展框架，是 Eclipse 托管给 Apache 基金会的一个开源项目。  
  ●升级 Mysql 8.0.13 ，Mysql 支持到 8。  
  ●...  
  更多的详细内容可以参考这里：[Spring Boot 2.1 Release Notes](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.1-Release-Notes)
, 2018-12-12, 2021-05-22, 默认分类, Spring Boot 2, true, null, 62, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20022, rs-50021} Result: [11, Docker数据管理介绍,   当我们对容器进行相关操作时，产生的一系列数据都会存储在容器中，而Docker内部又是如果管理这些数据的呢？本篇文章将针对Docker数据管理的一些知识进行介绍。
  
**1. Docker数据存储机制**  
  使用Docker时，我们操作的都是镜像和由镜像生成的容器，所以想要更好的了解Docker内部的数据存储机制，就必须从镜像、容器与数据存储的关系出发。  
  Docker镜像是通过读取Dockerfile文件中的指令构建的，Dockerfile中的每条指令都会创建一个镜像层，并且每层都是只读的，这一系列的镜像层就构成了Docker镜像。接下来以一个Dockerfile文件为例进行说明，具体如下列代码示例所示。
```js
 1	FROM ubuntu:16.04
 2	COPY . /app
 3	RUN make /app
 4	CMD python /app/app.py
```  
   上述文件示例中的Dockerfile包含了4条指令，每条指令都会创建一个镜像层，其中每一层与前一层都有所不同，并且是层层叠加的。通过镜像构建容器时，会在镜像层上增加一个容器层（即可写层），所有对容器的更改都会写入容器层，这也是Docker默认的数据存储方式。  
  下面通过一个效果图进行说明，具体如下图所示。
![alt](/article_img/docker/6.png)
  从图中可以看出，Docker容器和镜像之间的主要区别是顶部的容器层，而所有对容器中数据的添加、修改等操作都会被存储在容器层中。当容器被删除时，容器层也会被删除，其中存储的数据会被一同删除，而下面的镜像层却保持不变。  
  由于所有的容器都是通过镜像构建的，所以每个容器都有各自的容器层，对于容器数据的更改就会保存在各自的容器层中。也就是说，由同一个镜像构建的多个容器，它们会拥有相同的底部镜像层，而拥有不同的容器层，多个容器可以访问相同的镜像层，并且有自己的独立数据状态。具体说明如下图所示。 
![alt](/article_img/docker/7.png)
  从图中可以看出，基于同一个镜像构建的多个容器可以共享该镜像层，但是多个容器想要共享相同的数据，就需要将这些数据存储到容器之外的地方，而这种方式就是下一节要提到的Docker volume数据外部挂载机制。  

**2. Docker数据存储方式**    
  在默认情况下，Docker中的数据都是存放在容器层的，但是这样存储数据却有较多的缺陷，具体表现如下。    
  ●当容器不再运行时，容器中的数据无法持久化保存，如果另一个进程需要这些数据，那么将很难从容器中获取数据；  
  ●容器层与正在运行的主机紧密耦合，不能轻易地移动数据；  
  ●容器层需要一个存储驱动程序来管理文件系统，存储驱动程序提供了一个使用Linux内核的联合文件系统，这种额外的抽象化降低了性能。  
  基于上述种种原因，多数情况下Docker数据管理都不会直接将数据写入容器层，而是使用另一种叫做Docker volume数据外部挂载的机制进行数据管理。  
  针对Docker volume数据外部挂载机制，Docker提供了三种不同的方式将数据从容器映射到Docker宿主机，他们分别为：volumes（数据卷）、bind mounts（绑定挂载）和tmpfs mounts（tmpfs挂载）。这三种数据管理方式的具体选择，需要结合实际情况进行考虑，其中的volumes数据卷是最常用也是官方推荐的数据管理方式。无论选择使用哪种数据管理方式，数据在容器内看起来都一样的，而在容器外则会被被挂载到文件系统中的某个目录或文件中。    
  下面通过一张图来展示数据卷、绑定挂载和tmpfs挂载之间的差异，如下图所示。  
![alt](/article_img/docker/8.png)
  从图中可以看出，Docker提供的三种数据管理方式略有不同，具体分析如下。  
  ●volumes：存储在主机文件系统中（在Linux系统下是存在于/var/lib/Docker/volumes/目录），并由Docker管理，非Docker进程无法修改文件系统的这个部分。  
  ●bind mounts：可以存储在主机系统的任意位置，甚至可能是重要的系统文件或目录，在Docker主机或容器上的非Docker进程可以对他们进行任意修改。  
  ●tmpfs mounts：只存储在主机系统的内存中，并没有写入到主机的文件系统中。


, 2018-12-07, 2021-05-19, 默认分类, Docker,数据管理, true, null, 19, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20022, rs-50021} Result: [10, Docker常用客户端指令介绍,   在使用Docker之前，首先会为对应的项目编写Dockerfile镜像构建文件，然后通过Docker的相关指令进行镜像构建，完成镜像的构建后，就可以使用这些项目镜像进行启动测试了。所以要想知道如何使用Docker来执行这些Dockerfile镜像构建文件，还需要学习Docker客户端的常用指令，本篇文章将对Docker客户端的常用指令进行详细讲解。  

**1.列出镜像**  
  通过docker images指令可以查看本地镜像列表中已有的镜像，具体使用方式如下。
```js
$ docker images
```  
  执行上述指令后，系统会将所有本地镜像都展示出来，如下图所示。
![alt](/article_img/docker/3.png)
  从图中可以看出，系统终端将本地镜像列表中的3个镜像分5列进行了展示，每一列的具体含义如下。  
  ●REPOSITORY：镜像名称。  
  ●TAG：镜像的参数，类似于版本号，默认是latest。  
  ●IMAGE ID：镜像ID，是唯一值。此处看到的是一个长度为12的字符串，实际上它是64位完整镜像ID的缩写形式。  
  ●CREATED：距今创建镜像的时间。  
  ●SIZE：镜像大小。    

**2.搜索镜像**  
  想知道在Docker Hub中包含了哪些镜像，除了可以登录Docker Hub，在官网中心进行查看外，还可以直接在Docker客户端进行查询。例如想要查询Ubuntu镜像，可以使用如下指令。
```js
$ docker search ubuntu
```  
  执行上述指令后，系统终端就会将搜索到的有关Ubuntu的镜像展示出来，如下图所示。
![alt](/article_img/docker/4.png)
  从图所示的结果可以看出，系统终端分5列将搜索到的Ubuntu相关镜像都列举出来了，这5列的具体含义如下。  
  ●NAME：表示镜像的名称，这里有两种格式的名称，其中不带有“/”的表示官方镜像，而带有“/”的表示其他用户的公开镜像。公开镜像“/”前面是用户在Docker Hub上的用户名（唯一），后面是对应的镜像名；官方镜像与用户镜像，除了从镜像名称上可以区分外，还可以通过第4列的OFFICIAL声明中看出（该列下内容为OK表示官方镜像）。  
  ●DESCRIPTION：表示镜像的描述，这里只显示了一小部分。  
  ●STARS：表示该镜像的收藏数，用户可以在Docker Hub上对镜像进行收藏，一般可以通过该数字反应出该镜像的受欢迎程度。  
  ●OFFICIAL：表示是否为官方镜像。  
  ●AUTOMATED：表示是否自动构建镜像。例如，用户可以将自己的Docker Hub绑定到如Github上，当代码提交更新后，可以自动构建镜像。   
 
**3.拉取镜像**  
  通过docker pull指令可以拉取仓库镜像到本地（默认都是拉取Docker Hub仓库镜像，也可以指定“IP+端口”拉取某个Docker机器上的私有仓库镜像），具体使用方式如下。
```js
$ docker pull ubuntu
```  
  执行上述指令后，Docker会自动从Docker Hub上下载最新版本的Ubuntu到本地，当然也可以使用以下指令拉取指定版本的镜像到本地，具体指令如下。
```js
$ docker pull ubuntu:14.04
```  
**4.构建镜像**  
  除了可以通过docker pull指令从仓库拉取镜像外，还可以通过docker build指令构建Docker镜像，通常情况下都是通过Dockerfile文件来构建镜像的。  
  这里假设linux系统home目录下/shitou/workspace/dockerspace文件夹中编写有对应的Dockerfile文件，则构建镜像直立示例如下所示。 
```js
$ docker build -t hellodocker3 /home/shitou/workspace/dockerspace/.
```
**5.删除镜像**  
  当本地存放过多不需要的镜像时，可以通过docker rmi指令将其删除。在删除镜像时，需要指定镜像名称或镜像ID。删除镜像的使用方式如下。
```js
$ docker rmi -f hellodocker2 hellodocker3
```  
  上述指令中，docker rmi表示删除镜像，-f表示进行强制删除，而hellodocker2和hellodocker3分别表示需要删除的镜像名称，这里同时删除两个镜像。除了根据名称删除镜像外，还也可以根据镜像ID来删除镜像，只是这里如果指定了删除ID为23c617a866d4的镜像后，会同时删除hellodocker、hellodocker2和hellodocker3三个镜像。  
  需要特别强调的是，在进行镜像删除操作时，如果是通过镜像ID进行镜像删除，那么由该镜像创建的容器必须提前删除或停止。另外，在通过镜像名称操作镜像时，如果出现镜像重名的情况，必须在镜像名称后面指定镜像标签tag参数来确保唯一性。

**6.创建并启动容器**  
  Docker镜像主要用于创建容器，可以使用docker run指令创建并启动容器，具体使用方式如下。
```js
$ docker run -d -p 5000:80 --name test hellodocker
```  
  上述创建并启动容器的指令略微复杂，具体分析如下。  
  ●docker run：表示创建并启动一个容器，而后面的hellodocker就表示要启动运行的镜像名称；  
  ●-d：表示容器启动时在后台运行；  
  ●-p 5000:80：表示将容器内暴露的80端口映射到宿主机指定的5000端口，也可以将-p 5000:80更改为-P来映射主机的随机端口（注意p字母的大小写）；  
  ●--name test：表示为创建后的容器指定名称为test，如果没有该参数配置，则生成的容器会设置一个随机名称。  
  docker run命令是Docker操作中较为复杂的一个，它可以携带多个参数和参数，我们可以通过docker run --help指令进行查看，其中有些参数如-e、-v和-w等都可以在Dockerfile文件中预先声明。 
 
**7.列出容器**  
  生成容器后，可以通过docker ps指令查看当前运行的所有容器，具体使用方式如下。
```js
$ docker ps
```  
  执行上述命令后，会将所有当前运行的容器都展示出来，具体如下图所示。
![alt](/article_img/docker/5.png)
  从图中可以看出，系统终端通过7列对当前的正在运行的一个容器进行了展示，图中每一列的具体含义如下。  
  ●CONTAINER ID：表示生成的容器ID；  
  ●IMAGE：表示生成该容器的镜像名称；  
  ●COMMAND：表示启动容器时运行的命令，Docker要求在启动容器时必须运行一个命令；  
  ●CREATED：表示容器创建的时间；  
  ●STATUS：表示容器运行状态，例如Up表示运行中，Exited表示已停止；  
  ●PORTS：表示容器内部暴露的端口映射到主机的端口；  
  ●NAMES：表示生成容器的名称，由Docker引擎自动生成，可以像上述示例中使用--name参数指定生成容器的名称。  
  另外，docker ps指令运行过程中可以指定多个参数，还可以通过docker ps --help指令对ps指令的其他信息进行查看。

**8.删除容器**  
  当不需要使用容器时，则可以使用docker rm指令删除已停止的容器，具体使用方式如下。
```js
$ docker rm f0c9a8b6e8c5
```  
  需要注意的是，上述指令只能删除已经停止运行的容器，而不能删除正在运行的容器。如果想要删除正在运行的容器，则需要添加-f参数强制删除，具体使用方式如下。
```js
$ docker rm -f f0c9a8b6e8c5
```  
  当需要删除的容器过多时，如果还一个个的删除就略显麻烦了，此时可以通过如下指令将全部容器删除。
```js
$ docker rm -f $(docker ps -aq)
```  
  上述指令中，首先会通过$(docker ps -aq)获取所有容器的ID，然后通过docker rm -f指令进行强制删除。如果开发者有自己特殊的删除需求，可以根据前面docker ps指令进行组装来获取需要删除的容器ID。  
  Docker提供的操作指令远不止这些，这里就不一一列举了，想要了解更多Docker的操作指令，可以通过docker --help指令进行查看。


, 2018-12-05, null, 默认分类, Docker,客户端指令, true, null, 21, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20022, rs-50021} Result: [9, 虚拟化容器技术——Docker运行机制介绍,   Docker是一个开源的应用容器引擎，它基于go语言开发，并遵从Apache2.0开源协议。使用Docker可以让开发者封装他们的应用以及依赖包到一个可移植的容器中，然后发布到任意的Linux机器上，也可以实现虚拟化。Docker容器完全使用沙箱机制，相互之间不会有任何接口，这保证了容器之间的安全性。  

**1. Docker的引擎介绍**

  Docker Engine（Docker引擎）是Docker的核心部分，使用的是客户端-服务器（C/S）架构模式，其主要组成部分如下图所示。
![alt](/article_img/docker/1.png)
  从上图可以看出，Docker Engine中包含了三个核心组件（docker CLI、REST API和docker daemon），这三个组件的具体说明如下：  
  ①docker CLI（command line interface）：表示Docker命令行接口，开发者可以在命令行中使用Docker相关指令与Docker守护进程进行交互，从而管理诸如image（镜像）、container（容器）、network（网络）和data volumes（数据卷）等实体。  
  ②REST API：表示应用程序API接口，开发者通过该API接口可以与Docker的守护进程进行交互，从而指示后台进行相关操作。  
  ③docker daemon：表示Docker的服务端组件，他是Docker架构中运行在后台的一个守护进程，可以接收并处理来自命令行接口及API接口的指令，然后进行相应的后台操作。  
  对于开发者而言，既可以使用编写好的脚本文件通过REST API来实现与Docker进程交互，又可以直接使用Docker相关指令通过命令行接口来与Docker进程交互，而其他一些Docker应用则是通过底层的API和CLI进行交互的。

**2. Docker的架构介绍**

  了解了Docker内部引擎及作用后，我们还需要通过Docker的具体架构，来了解Docker的整个运行流程。接下来借助Docker官网的架构图来对Docker架构进行详细说明，如下图所示。
![alt](/article_img/docker/2.jpg)
  从图中可以看出，Docker架构主要包括Client、DOCKER_HOST和Register三部分，关于这三部分的具体说明如下。  
&emsp;&emsp;**（1）Client（客户端）**  
  Client即Docker客户端，也就是上一小节Docker Engine中介绍的docker CLI。开发者通过这个客户端使用Docker的相关指令与Docker守护进程进行交互，从而进行Docker镜像的创建、拉取和运行等操作。  
&emsp;&emsp;**（2）DOCKER_HOST（Docker主机）**  
  DOCKER_HOST即Docker内部引擎运行的主机，主要指Docker daemon（Docker守护进程）。可以通过Docker守护进程与客户端还有Docker的镜像仓库Registry进行交互，从而管理Images（镜像）和Containers（容器）等。  
&emsp;&emsp;**（3）Registry（注册中心）**  
  Registry即Docker注册中心，实质就是Docker镜像仓库，默认使用的是Docker官方远程注册中心Docker Hub，也可以使用开发者搭建的本地仓库。Registry中包含了大量的镜像，这些镜像可以是官网基础镜像，也可以是其他开发者上传的镜像。  
  我们在实际使用Docker时，除了会涉及到图中的三个主要部分外，还会涉及到很多Docker Objects（Docker对象），例如Images（镜像）、Containers（容器）、Networks（网络）、Volumes（数据卷）、Plugins（插件）等。其中常用的两个对象Image和Containers的说明如下。  
  ①Images（镜像）  
  Docker 镜像就是一个只读的模板，包含了一些创建Docker容器的操作指令。通常情况下，一个Docker镜像是基于另一个基础镜像创建的，并且新创建的镜像会额外包含一些功能配置。例如：开发者可以依赖于一个Ubuntu的基础镜像创建一个新镜像，并可以在新镜像中安装Apache等软件或其它应用程序。  
  ②Containers（容器）  
  Docker容器属于镜像的一个可运行实例（镜像与容器的关系其实与Java中的类与对象相似），开发者可以通过API接口或者CLI命令行接口来创建、运行、停止、移动、删除一个容器，也可以将一个容器连接到一个或多个网络中，将数据存储与容器进行关联。



, 2018-12-03, null, 默认分类, 虚拟化容器,Docker,运行机制, true, null, 26, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20022, rs-50021} Result: [8, JDK 8——聚合操作, &emsp;&emsp;在Java8版本中，JDK包含许多聚合操作（如平均值，总和，最小，最大，和计数），返回一个计算流stream的聚合结果。这些聚合操作被称为聚合操作。JDK除返回单个值的聚合操作外，还有很多聚合操作返回一个collection集合实例。很多的reduce操作执行特定的任务，如求平均值或按类别分组元素。  

**1. 聚合操作简介**

  在开发中，多数情况下会涉及到对集合、数组中元素的操作，在JDK 8之前都是通过普通的循环遍历出每一个元素，然后还会穿插一些if条件语句选择性的对元素进行查找、过滤、修改等操作，这种原始的操作方法虽然可行，但是代码量较大并且执行效率较低。  
  为此，JDK 8中新增了一个Stream接口，该接口可以将集合、数组的中的元素转换为Stream流的形式，并结合Lambda表达式的优势来进一步简化集合、数组中元素的查找、过滤、转换等操作，这一新功能就是JDK 8中的聚合操作。  
  在程序中，使用聚合操作没有绝对的语法规范，根据实际操作流程，主要可以分为以下3个步骤：  
  （1）将原始集合或者数组对象转换为Stream流对象；  
  （2）对Stream流对象中的元素进行一系列的过滤、查找等中间操作（Intermediate Operations），然后仍然返回一个Stream流对象；  
  （3）对Stream流进行遍历、统计、收集等终结操作（Terminal Operation），获取想要的结果。  
  接下来，就根据上面聚合操作的3个步骤，通过一个案例来演示聚合操作的基本用法，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example31 {
 4		public static void main(String[] args) {
 5	          // 创建一个List集合对象
 6			List<String> list = new ArrayList<>(); 
 7			list.add("张三");
 8			list.add("李四");
 9			list.add("张小明");
 10			list.add("张阳");
 11			// 1、创建一个Stream流对象
 12			Stream<String> stream = list.stream();
 13			// 2、对Stream流中的元素分别进行过滤、截取操作
 14		       Stream<String> stream2 = stream.filter(i -> i.startsWith("张"));
 15			Stream<String> stream3 = stream2.limit(2);
 16			// 3、对Stream流中的元素进行终结操作，进行遍历输出
 17			stream3.forEach(j -> System.out.println(j));
 18			System.out.println("=======");
 19	         // 通过链式表达式的形式完成聚合操作
 20			list.stream().filter(i -> i.startsWith("张"))
 21						 .limit(2)
 22						 .forEach(j -> System.out.println(j));
 23		}
 24	}
``` 
   运行结果如下图所示。
![alt](/article_img/lambda/3.jpg)
  上述示例代码中，先创建了一个List集合，然后根据聚合操作的3个步骤实现了集合对象的聚合操作，对集合中的元素使用Stream流的形式进行过滤（filter）、截取（limit），并进行遍历输出。其中第12~17行代码分步骤详细展示了聚合操作，而第20~22行代码是使用了链式表达式（调用有返回值的方法时不获取返回值而是直接再调用另一个方法）实现了聚合操作，该表达式的语法格式更简洁、高效，这种链式调用也被称为操作管道流。

**2. 创建Stream流对象**  
  在上一小节中，介绍了聚合操作的主要使用步骤，其中首要解决的问题就是创建Stream流对象。聚合操作针对的就是可迭代数据进行的操作，如集合、数组等，所以创建Stream流对象其实就是将集合、数组等通过一些方法转换为Stream流对象。  
  在Java中，集合对象有对应的集合类，可以通过集合类提供的静态方法创建Stream流对象，而数组数据却没有对应的数组类，所以必须通过其他方法创建Stream流对象。针对不同的源数据，Java提供了多种创建Stream流对象的方式，分别如下：  
  （1）所有的Collections集合都可以使用stream()静态方法获取Stream流对象；  
  （2）Stream接口的of()静态方法可以获取基本类型包装类数组、引用类型数组和单个元素的Stream流对象；  
  （3）Arrays数组工具类的stream()静态方法也可以获取数组元素的Stream流对象。  
  接下来，通过一个案例来学习聚合操作中如何创建Stream流对象，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example32 {
 4		public static void main(String[] args) {
 5	          // 创建一个数组
 6			Integer[] array = { 9, 8, 3, 5, 2 };       
 7	          // 将数组转换为List集合
 8			List<Integer> list = Arrays.asList(array); 
 9			// 1、使用集合对象的stream()静态方法创建Stream流对象
 10			Stream<Integer> stream = list.stream();
 11			stream.forEach(i -> System.out.print(i+" "));
 12			System.out.println();
 13			// 2、使用Stream接口的of()静态方法创建Stream流对象
 14			Stream<Integer> stream2 = Stream.of(array);
 15			stream2.forEach(i -> System.out.print(i+" "));
 16			System.out.println();
 17			// 3、使用Arrays数组工具类的stream()静态方法创建Stream流对象
 18			Stream<Integer> stream3 = Arrays.stream(array);
 19			stream3.forEach(i -> System.out.print(i+" "));
 20		}
 21	}
```  
  运行结果如下图所示。
![alt](/article_img/lambda/4.jpg)
  上述示例代码中，先创建了一个数组和一个集合，然后通过三种方式实现了Stream流对象的创建，并通过Stream流对象的forEach()方法结合Lambda表达式完成了集合和数组中元素的遍历。  

**小提示：**  
  在JDK 8中，只针对单列集合Collections接口对象提供了stream()静态方法获取Stream流对象，并未对Map集合提供相关方法获取Stream流对象，所以想要用Map集合创建Stream流对象必须先通过Map集合的keySet()、values()、entrySet()等方法将Map集合转换为单列Set集合，然后再使用单列集合的stream()静态方法获取对应键、值集合的Stream流对象。

, 2018-12-02, null, 默认分类, JDK 8,聚合操作, true, null, 36, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20022, rs-50021} Result: [7, 函数式接口, &emsp;&emsp;虽然Lambda表达式可以实现匿名内部类的功能，但在使用时却有一个局限，即接口中有且只有一个抽象方法时才能使用Lamdba表达式代替匿名内部类。这是因为Lamdba表达式是基于函数式接口实现的，所谓函数式接口是指有且仅有一个抽象方法的接口，Lambda表达式就是Java中函数式编程的体现，只有确保接口中有且仅有一个抽象方法，Lambda表达式才能顺利地推导出所实现的这个接口中的方法。  
&emsp;&emsp;在JDK 8中，专门为函数式接口引入了一个@FunctionalInterface注解，该注解只是显示的标注了接口是一个函数式接口，并强制编辑器进行更严格的检查，确保该接口是函数式接口，如果不是函数式接口，那么编译器就会报错，而对程序运行并没有实质上的影响。  
&emsp;&emsp;接下来通过一个案例来演示函数式接口的定义与使用，示例代码如下所示。
```js
 1	// 定义无参、无返回值的函数式接口
 2	@FunctionalInterface
 3	interface Animal {
 4		void shout();
 5	}
 6	// 定义有参、有返回值的函数式接口
 7	interface Calculate {
 8		int sum(int a, int b);
 9	}
 10	public class Example23 {
 11		public static void main(String[] args) {
 12		   // 分别两个函数式接口进行测试
 13		   animalShout(() -> System.out.println("无参、无返回值的函数式接口调用"));
 14		   showSum(10, 20, (x, y) -> x + y);
 15		}
 16		// 创建一个动物叫的方法，并传入接口对象Animal作为参数
 17		private static void animalShout(Animal animal) {
 18			animal.shout();
 19		}
 20		// 创建一个求和的方法，并传入两个int类型以及接口Calculate类型的参数
 21		private static void showSum(int x, int y, Calculate calculate) {
 22		   System.out.println(x + "+" + y + "的和为：" + calculate.sum(x, y));
 23		}
 24	}
```  
&emsp;&emsp;运行结果如下图所示。

![alt](/article_img/lambda/2.jpg)
&emsp;&emsp;上述代码示例中，先定义了两个函数式接口Animal和Calculate，然后在测试类中分别编写了两个静态方法，并将这两个函数式接口以参数的形式传入，最后在main()方法中分别调用这两个静态方法，并将所需要的函数式接口参数以Lambda表达式的形式传入。从图中可以看出，程序中函数式接口的定义和使用完全正确。
, 2018-12-01, null, 默认分类, 接口,函数式接口, true, null, 12, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20022, rs-50021} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20022} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][com.boot.controller.adminController]2021-05-22 23:15:55   用户名：admin进入后台发布页面
[DEBUG][21-05-22][com.boot.controller.adminController]2021-05-22 23:16:05   用户名：admin进入admim后台
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20023} created. SELECT count(0) FROM t_article, t_comment WHERE t_article.id = t_comment.article_id
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20023} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20023} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20023} executed. 0.4693 millis. SELECT count(0) FROM t_article, t_comment WHERE t_article.id = t_comment.article_id
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20023, rs-50022} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20023, rs-50022} Header: [count(0)]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20023, rs-50022} Result: [12]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20023, rs-50022} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20023} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20024} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_comment.article_id,
	t_comment.c_content,
	t_comment.created,
	t_comment.author,
	t_comment.ip,
	t_comment.status
    FROM
    t_article,
	t_comment
    WHERE
	t_article.id = t_comment.article_id
	order by t_article.created desc LIMIT ? 
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20024} Parameters : [5]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20024} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20024} executed. 2.607 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_comment.article_id,
	t_comment.c_content,
	t_comment.created,
	t_comment.author,
	t_comment.ip,
	t_comment.status
    FROM
    t_article,
	t_comment
    WHERE
	t_article.id = t_comment.article_id
	order by t_article.created desc LIMIT ? 
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20024, rs-50023} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20024, rs-50023} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, article_id, c_content, created, author, ip, status]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20024, rs-50023} Result: [12, Spring Boot 2 权威发布,   如果这两天登录 [https://start.spring.io/ ](https://start.spring.io/ )就会发现，Spring Boot 默认版本已经升到了 2.1.0。这是因为 Spring Boot 刚刚发布了 2.1.0 版本，我们来看下 Spring Boot 2 发布以来第一个子版本都发布了哪些内容？  

**2.1 中的新特性**     
  ●将spring-boot-starter-oauth2-oidc-client重命名为spring-boot-starter-oauth2-client命名更简洁  
  ●添加 OAuth2 资源服务 starter，OAuth2 一个用于认证的组件  
  ●支持 ConditionalOnBean 和 ConditionalOnMissingBean 下的参数化容器  
  ●自动配置 applicationTaskExecutor bean 的延迟加载来避免不必要的日志记录  
  ●将 DatabaseDriver＃SAP 重命名为 DatabaseDriver  
  ●跳过重启器不仅适用于 JUnit4，也适用于 JUnit5  
  ●在 Jest HealthIndicator 中使用集群端点  
  ●当 DevTools 禁用重启时添加日志输出  
  ●添加注解：@ConditionalOnMissingServletFilter提高 Servlet Filters 的自动装配。
  
**2.1 中的组件升级**  
  ●升级 Hibernate 5.3，Hibernate 的支持升级到了 5.3  
  ●升级 Tomcat 9 ，支持最新的 tomcat 9  
  ●支持 Java 11，Java 现在更新越来越快，Spring 快赶不上了    
  ●升级 Thymeleaf Extras Springsecurity 到 3.0.4.RELEASE ，thymeleaf-extras-springsecurity 是 Thymeleaf 提供集成 Spring Security 的组件  
  ●升级 Joda Time 2.10.1，Joda-Time， 面向 Java 应用程序的日期/时间库的替代选择，Joda-Time 令时间和日期值变得易于管理、操作和理解。  
  ●升级 Lettuce 5.1.2.RELEASE ，Lettuce 前面说过，传说中 Redis 最快的客户端。  
  ●升级 Reactor Californium-SR2 ，Californium 是物联网云服务的 Java COAP 实现。因此，它更专注的是可扩展性和可用性而不是像嵌入式设备那样关注资源效率。不过，Californium 也适合嵌入式的 JVM。  
  ●升级 Maven Failsafe Plugin 2.22.1 ，Maven 中的测试插件。  
  ●升级 Flyway 5.2.1 ， Flyway是一款开源的数据库版本管理工具  
  ●升级 Aspectj 1.9.2 ，AspectJ 是 Java 中流行的 AOP（Aspect-oriented Programming）编程扩展框架，是 Eclipse 托管给 Apache 基金会的一个开源项目。  
  ●升级 Mysql 8.0.13 ，Mysql 支持到 8。  
  ●...  
  更多的详细内容可以参考这里：[Spring Boot 2.1 Release Notes](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.1-Release-Notes)
, 2018-12-12, 2021-05-22, 默认分类, Spring Boot 2, true, null, 12, 很不错，不过这文章排版不太好看啊, 2018-12-13, 李四, 0:0:0:0:0:0:0:1, approved]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20024, rs-50023} Result: [12, Spring Boot 2 权威发布,   如果这两天登录 [https://start.spring.io/ ](https://start.spring.io/ )就会发现，Spring Boot 默认版本已经升到了 2.1.0。这是因为 Spring Boot 刚刚发布了 2.1.0 版本，我们来看下 Spring Boot 2 发布以来第一个子版本都发布了哪些内容？  

**2.1 中的新特性**     
  ●将spring-boot-starter-oauth2-oidc-client重命名为spring-boot-starter-oauth2-client命名更简洁  
  ●添加 OAuth2 资源服务 starter，OAuth2 一个用于认证的组件  
  ●支持 ConditionalOnBean 和 ConditionalOnMissingBean 下的参数化容器  
  ●自动配置 applicationTaskExecutor bean 的延迟加载来避免不必要的日志记录  
  ●将 DatabaseDriver＃SAP 重命名为 DatabaseDriver  
  ●跳过重启器不仅适用于 JUnit4，也适用于 JUnit5  
  ●在 Jest HealthIndicator 中使用集群端点  
  ●当 DevTools 禁用重启时添加日志输出  
  ●添加注解：@ConditionalOnMissingServletFilter提高 Servlet Filters 的自动装配。
  
**2.1 中的组件升级**  
  ●升级 Hibernate 5.3，Hibernate 的支持升级到了 5.3  
  ●升级 Tomcat 9 ，支持最新的 tomcat 9  
  ●支持 Java 11，Java 现在更新越来越快，Spring 快赶不上了    
  ●升级 Thymeleaf Extras Springsecurity 到 3.0.4.RELEASE ，thymeleaf-extras-springsecurity 是 Thymeleaf 提供集成 Spring Security 的组件  
  ●升级 Joda Time 2.10.1，Joda-Time， 面向 Java 应用程序的日期/时间库的替代选择，Joda-Time 令时间和日期值变得易于管理、操作和理解。  
  ●升级 Lettuce 5.1.2.RELEASE ，Lettuce 前面说过，传说中 Redis 最快的客户端。  
  ●升级 Reactor Californium-SR2 ，Californium 是物联网云服务的 Java COAP 实现。因此，它更专注的是可扩展性和可用性而不是像嵌入式设备那样关注资源效率。不过，Californium 也适合嵌入式的 JVM。  
  ●升级 Maven Failsafe Plugin 2.22.1 ，Maven 中的测试插件。  
  ●升级 Flyway 5.2.1 ， Flyway是一款开源的数据库版本管理工具  
  ●升级 Aspectj 1.9.2 ，AspectJ 是 Java 中流行的 AOP（Aspect-oriented Programming）编程扩展框架，是 Eclipse 托管给 Apache 基金会的一个开源项目。  
  ●升级 Mysql 8.0.13 ，Mysql 支持到 8。  
  ●...  
  更多的详细内容可以参考这里：[Spring Boot 2.1 Release Notes](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.1-Release-Notes)
, 2018-12-12, 2021-05-22, 默认分类, Spring Boot 2, true, null, 12, 000111, 2021-05-21, admin, 0:0:0:0:0:0:0:1, approved]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20024, rs-50023} Result: [11, Docker数据管理介绍,   当我们对容器进行相关操作时，产生的一系列数据都会存储在容器中，而Docker内部又是如果管理这些数据的呢？本篇文章将针对Docker数据管理的一些知识进行介绍。
  
**1. Docker数据存储机制**  
  使用Docker时，我们操作的都是镜像和由镜像生成的容器，所以想要更好的了解Docker内部的数据存储机制，就必须从镜像、容器与数据存储的关系出发。  
  Docker镜像是通过读取Dockerfile文件中的指令构建的，Dockerfile中的每条指令都会创建一个镜像层，并且每层都是只读的，这一系列的镜像层就构成了Docker镜像。接下来以一个Dockerfile文件为例进行说明，具体如下列代码示例所示。
```js
 1	FROM ubuntu:16.04
 2	COPY . /app
 3	RUN make /app
 4	CMD python /app/app.py
```  
   上述文件示例中的Dockerfile包含了4条指令，每条指令都会创建一个镜像层，其中每一层与前一层都有所不同，并且是层层叠加的。通过镜像构建容器时，会在镜像层上增加一个容器层（即可写层），所有对容器的更改都会写入容器层，这也是Docker默认的数据存储方式。  
  下面通过一个效果图进行说明，具体如下图所示。
![alt](/article_img/docker/6.png)
  从图中可以看出，Docker容器和镜像之间的主要区别是顶部的容器层，而所有对容器中数据的添加、修改等操作都会被存储在容器层中。当容器被删除时，容器层也会被删除，其中存储的数据会被一同删除，而下面的镜像层却保持不变。  
  由于所有的容器都是通过镜像构建的，所以每个容器都有各自的容器层，对于容器数据的更改就会保存在各自的容器层中。也就是说，由同一个镜像构建的多个容器，它们会拥有相同的底部镜像层，而拥有不同的容器层，多个容器可以访问相同的镜像层，并且有自己的独立数据状态。具体说明如下图所示。 
![alt](/article_img/docker/7.png)
  从图中可以看出，基于同一个镜像构建的多个容器可以共享该镜像层，但是多个容器想要共享相同的数据，就需要将这些数据存储到容器之外的地方，而这种方式就是下一节要提到的Docker volume数据外部挂载机制。  

**2. Docker数据存储方式**    
  在默认情况下，Docker中的数据都是存放在容器层的，但是这样存储数据却有较多的缺陷，具体表现如下。    
  ●当容器不再运行时，容器中的数据无法持久化保存，如果另一个进程需要这些数据，那么将很难从容器中获取数据；  
  ●容器层与正在运行的主机紧密耦合，不能轻易地移动数据；  
  ●容器层需要一个存储驱动程序来管理文件系统，存储驱动程序提供了一个使用Linux内核的联合文件系统，这种额外的抽象化降低了性能。  
  基于上述种种原因，多数情况下Docker数据管理都不会直接将数据写入容器层，而是使用另一种叫做Docker volume数据外部挂载的机制进行数据管理。  
  针对Docker volume数据外部挂载机制，Docker提供了三种不同的方式将数据从容器映射到Docker宿主机，他们分别为：volumes（数据卷）、bind mounts（绑定挂载）和tmpfs mounts（tmpfs挂载）。这三种数据管理方式的具体选择，需要结合实际情况进行考虑，其中的volumes数据卷是最常用也是官方推荐的数据管理方式。无论选择使用哪种数据管理方式，数据在容器内看起来都一样的，而在容器外则会被被挂载到文件系统中的某个目录或文件中。    
  下面通过一张图来展示数据卷、绑定挂载和tmpfs挂载之间的差异，如下图所示。  
![alt](/article_img/docker/8.png)
  从图中可以看出，Docker提供的三种数据管理方式略有不同，具体分析如下。  
  ●volumes：存储在主机文件系统中（在Linux系统下是存在于/var/lib/Docker/volumes/目录），并由Docker管理，非Docker进程无法修改文件系统的这个部分。  
  ●bind mounts：可以存储在主机系统的任意位置，甚至可能是重要的系统文件或目录，在Docker主机或容器上的非Docker进程可以对他们进行任意修改。  
  ●tmpfs mounts：只存储在主机系统的内存中，并没有写入到主机的文件系统中。


, 2018-12-07, 2021-05-19, 默认分类, Docker,数据管理, true, null, 11, 很不错的原理分析，受用了！, 2018-12-13, 李四, 0:0:0:0:0:0:0:1, approved]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20024, rs-50023} Result: [10, Docker常用客户端指令介绍,   在使用Docker之前，首先会为对应的项目编写Dockerfile镜像构建文件，然后通过Docker的相关指令进行镜像构建，完成镜像的构建后，就可以使用这些项目镜像进行启动测试了。所以要想知道如何使用Docker来执行这些Dockerfile镜像构建文件，还需要学习Docker客户端的常用指令，本篇文章将对Docker客户端的常用指令进行详细讲解。  

**1.列出镜像**  
  通过docker images指令可以查看本地镜像列表中已有的镜像，具体使用方式如下。
```js
$ docker images
```  
  执行上述指令后，系统会将所有本地镜像都展示出来，如下图所示。
![alt](/article_img/docker/3.png)
  从图中可以看出，系统终端将本地镜像列表中的3个镜像分5列进行了展示，每一列的具体含义如下。  
  ●REPOSITORY：镜像名称。  
  ●TAG：镜像的参数，类似于版本号，默认是latest。  
  ●IMAGE ID：镜像ID，是唯一值。此处看到的是一个长度为12的字符串，实际上它是64位完整镜像ID的缩写形式。  
  ●CREATED：距今创建镜像的时间。  
  ●SIZE：镜像大小。    

**2.搜索镜像**  
  想知道在Docker Hub中包含了哪些镜像，除了可以登录Docker Hub，在官网中心进行查看外，还可以直接在Docker客户端进行查询。例如想要查询Ubuntu镜像，可以使用如下指令。
```js
$ docker search ubuntu
```  
  执行上述指令后，系统终端就会将搜索到的有关Ubuntu的镜像展示出来，如下图所示。
![alt](/article_img/docker/4.png)
  从图所示的结果可以看出，系统终端分5列将搜索到的Ubuntu相关镜像都列举出来了，这5列的具体含义如下。  
  ●NAME：表示镜像的名称，这里有两种格式的名称，其中不带有“/”的表示官方镜像，而带有“/”的表示其他用户的公开镜像。公开镜像“/”前面是用户在Docker Hub上的用户名（唯一），后面是对应的镜像名；官方镜像与用户镜像，除了从镜像名称上可以区分外，还可以通过第4列的OFFICIAL声明中看出（该列下内容为OK表示官方镜像）。  
  ●DESCRIPTION：表示镜像的描述，这里只显示了一小部分。  
  ●STARS：表示该镜像的收藏数，用户可以在Docker Hub上对镜像进行收藏，一般可以通过该数字反应出该镜像的受欢迎程度。  
  ●OFFICIAL：表示是否为官方镜像。  
  ●AUTOMATED：表示是否自动构建镜像。例如，用户可以将自己的Docker Hub绑定到如Github上，当代码提交更新后，可以自动构建镜像。   
 
**3.拉取镜像**  
  通过docker pull指令可以拉取仓库镜像到本地（默认都是拉取Docker Hub仓库镜像，也可以指定“IP+端口”拉取某个Docker机器上的私有仓库镜像），具体使用方式如下。
```js
$ docker pull ubuntu
```  
  执行上述指令后，Docker会自动从Docker Hub上下载最新版本的Ubuntu到本地，当然也可以使用以下指令拉取指定版本的镜像到本地，具体指令如下。
```js
$ docker pull ubuntu:14.04
```  
**4.构建镜像**  
  除了可以通过docker pull指令从仓库拉取镜像外，还可以通过docker build指令构建Docker镜像，通常情况下都是通过Dockerfile文件来构建镜像的。  
  这里假设linux系统home目录下/shitou/workspace/dockerspace文件夹中编写有对应的Dockerfile文件，则构建镜像直立示例如下所示。 
```js
$ docker build -t hellodocker3 /home/shitou/workspace/dockerspace/.
```
**5.删除镜像**  
  当本地存放过多不需要的镜像时，可以通过docker rmi指令将其删除。在删除镜像时，需要指定镜像名称或镜像ID。删除镜像的使用方式如下。
```js
$ docker rmi -f hellodocker2 hellodocker3
```  
  上述指令中，docker rmi表示删除镜像，-f表示进行强制删除，而hellodocker2和hellodocker3分别表示需要删除的镜像名称，这里同时删除两个镜像。除了根据名称删除镜像外，还也可以根据镜像ID来删除镜像，只是这里如果指定了删除ID为23c617a866d4的镜像后，会同时删除hellodocker、hellodocker2和hellodocker3三个镜像。  
  需要特别强调的是，在进行镜像删除操作时，如果是通过镜像ID进行镜像删除，那么由该镜像创建的容器必须提前删除或停止。另外，在通过镜像名称操作镜像时，如果出现镜像重名的情况，必须在镜像名称后面指定镜像标签tag参数来确保唯一性。

**6.创建并启动容器**  
  Docker镜像主要用于创建容器，可以使用docker run指令创建并启动容器，具体使用方式如下。
```js
$ docker run -d -p 5000:80 --name test hellodocker
```  
  上述创建并启动容器的指令略微复杂，具体分析如下。  
  ●docker run：表示创建并启动一个容器，而后面的hellodocker就表示要启动运行的镜像名称；  
  ●-d：表示容器启动时在后台运行；  
  ●-p 5000:80：表示将容器内暴露的80端口映射到宿主机指定的5000端口，也可以将-p 5000:80更改为-P来映射主机的随机端口（注意p字母的大小写）；  
  ●--name test：表示为创建后的容器指定名称为test，如果没有该参数配置，则生成的容器会设置一个随机名称。  
  docker run命令是Docker操作中较为复杂的一个，它可以携带多个参数和参数，我们可以通过docker run --help指令进行查看，其中有些参数如-e、-v和-w等都可以在Dockerfile文件中预先声明。 
 
**7.列出容器**  
  生成容器后，可以通过docker ps指令查看当前运行的所有容器，具体使用方式如下。
```js
$ docker ps
```  
  执行上述命令后，会将所有当前运行的容器都展示出来，具体如下图所示。
![alt](/article_img/docker/5.png)
  从图中可以看出，系统终端通过7列对当前的正在运行的一个容器进行了展示，图中每一列的具体含义如下。  
  ●CONTAINER ID：表示生成的容器ID；  
  ●IMAGE：表示生成该容器的镜像名称；  
  ●COMMAND：表示启动容器时运行的命令，Docker要求在启动容器时必须运行一个命令；  
  ●CREATED：表示容器创建的时间；  
  ●STATUS：表示容器运行状态，例如Up表示运行中，Exited表示已停止；  
  ●PORTS：表示容器内部暴露的端口映射到主机的端口；  
  ●NAMES：表示生成容器的名称，由Docker引擎自动生成，可以像上述示例中使用--name参数指定生成容器的名称。  
  另外，docker ps指令运行过程中可以指定多个参数，还可以通过docker ps --help指令对ps指令的其他信息进行查看。

**8.删除容器**  
  当不需要使用容器时，则可以使用docker rm指令删除已停止的容器，具体使用方式如下。
```js
$ docker rm f0c9a8b6e8c5
```  
  需要注意的是，上述指令只能删除已经停止运行的容器，而不能删除正在运行的容器。如果想要删除正在运行的容器，则需要添加-f参数强制删除，具体使用方式如下。
```js
$ docker rm -f f0c9a8b6e8c5
```  
  当需要删除的容器过多时，如果还一个个的删除就略显麻烦了，此时可以通过如下指令将全部容器删除。
```js
$ docker rm -f $(docker ps -aq)
```  
  上述指令中，首先会通过$(docker ps -aq)获取所有容器的ID，然后通过docker rm -f指令进行强制删除。如果开发者有自己特殊的删除需求，可以根据前面docker ps指令进行组装来获取需要删除的容器ID。  
  Docker提供的操作指令远不止这些，这里就不一一列举了，想要了解更多Docker的操作指令，可以通过docker --help指令进行查看。


, 2018-12-05, null, 默认分类, Docker,客户端指令, true, null, 10, 关于Docker虚拟容器的讲解挺好的额，学习中, 2018-12-13, 李四, 0:0:0:0:0:0:0:1, approved]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20024, rs-50023} Result: [9, 虚拟化容器技术——Docker运行机制介绍,   Docker是一个开源的应用容器引擎，它基于go语言开发，并遵从Apache2.0开源协议。使用Docker可以让开发者封装他们的应用以及依赖包到一个可移植的容器中，然后发布到任意的Linux机器上，也可以实现虚拟化。Docker容器完全使用沙箱机制，相互之间不会有任何接口，这保证了容器之间的安全性。  

**1. Docker的引擎介绍**

  Docker Engine（Docker引擎）是Docker的核心部分，使用的是客户端-服务器（C/S）架构模式，其主要组成部分如下图所示。
![alt](/article_img/docker/1.png)
  从上图可以看出，Docker Engine中包含了三个核心组件（docker CLI、REST API和docker daemon），这三个组件的具体说明如下：  
  ①docker CLI（command line interface）：表示Docker命令行接口，开发者可以在命令行中使用Docker相关指令与Docker守护进程进行交互，从而管理诸如image（镜像）、container（容器）、network（网络）和data volumes（数据卷）等实体。  
  ②REST API：表示应用程序API接口，开发者通过该API接口可以与Docker的守护进程进行交互，从而指示后台进行相关操作。  
  ③docker daemon：表示Docker的服务端组件，他是Docker架构中运行在后台的一个守护进程，可以接收并处理来自命令行接口及API接口的指令，然后进行相应的后台操作。  
  对于开发者而言，既可以使用编写好的脚本文件通过REST API来实现与Docker进程交互，又可以直接使用Docker相关指令通过命令行接口来与Docker进程交互，而其他一些Docker应用则是通过底层的API和CLI进行交互的。

**2. Docker的架构介绍**

  了解了Docker内部引擎及作用后，我们还需要通过Docker的具体架构，来了解Docker的整个运行流程。接下来借助Docker官网的架构图来对Docker架构进行详细说明，如下图所示。
![alt](/article_img/docker/2.jpg)
  从图中可以看出，Docker架构主要包括Client、DOCKER_HOST和Register三部分，关于这三部分的具体说明如下。  
&emsp;&emsp;**（1）Client（客户端）**  
  Client即Docker客户端，也就是上一小节Docker Engine中介绍的docker CLI。开发者通过这个客户端使用Docker的相关指令与Docker守护进程进行交互，从而进行Docker镜像的创建、拉取和运行等操作。  
&emsp;&emsp;**（2）DOCKER_HOST（Docker主机）**  
  DOCKER_HOST即Docker内部引擎运行的主机，主要指Docker daemon（Docker守护进程）。可以通过Docker守护进程与客户端还有Docker的镜像仓库Registry进行交互，从而管理Images（镜像）和Containers（容器）等。  
&emsp;&emsp;**（3）Registry（注册中心）**  
  Registry即Docker注册中心，实质就是Docker镜像仓库，默认使用的是Docker官方远程注册中心Docker Hub，也可以使用开发者搭建的本地仓库。Registry中包含了大量的镜像，这些镜像可以是官网基础镜像，也可以是其他开发者上传的镜像。  
  我们在实际使用Docker时，除了会涉及到图中的三个主要部分外，还会涉及到很多Docker Objects（Docker对象），例如Images（镜像）、Containers（容器）、Networks（网络）、Volumes（数据卷）、Plugins（插件）等。其中常用的两个对象Image和Containers的说明如下。  
  ①Images（镜像）  
  Docker 镜像就是一个只读的模板，包含了一些创建Docker容器的操作指令。通常情况下，一个Docker镜像是基于另一个基础镜像创建的，并且新创建的镜像会额外包含一些功能配置。例如：开发者可以依赖于一个Ubuntu的基础镜像创建一个新镜像，并可以在新镜像中安装Apache等软件或其它应用程序。  
  ②Containers（容器）  
  Docker容器属于镜像的一个可运行实例（镜像与容器的关系其实与Java中的类与对象相似），开发者可以通过API接口或者CLI命令行接口来创建、运行、停止、移动、删除一个容器，也可以将一个容器连接到一个或多个网络中，将数据存储与容器进行关联。



, 2018-12-03, null, 默认分类, 虚拟化容器,Docker,运行机制, true, null, 9, asdaa阿斯顿, 2019-03-30, tom, 0:0:0:0:0:0:0:1, approved]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20024, rs-50023} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20024} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20025} created. SELECT count(0) FROM t_comment
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20025} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20025} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20025} executed. 0.564 millis. SELECT count(0) FROM t_comment
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20025, rs-50024} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20025, rs-50024} Header: [count(0)]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20025, rs-50024} Result: [12]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20025, rs-50024} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20025} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20026} created. select * from t_comment order by created desc LIMIT ? 
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20026} Parameters : [5]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20026} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20026} executed. 0.4086 millis. select * from t_comment order by created desc LIMIT ? 
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20026, rs-50025} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20026, rs-50025} Header: [id, article_id, created, ip, c_content, status, author]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20026, rs-50025} Result: [18, 12, 2021-05-21, 0:0:0:0:0:0:0:1, 000111, approved, admin]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20026, rs-50025} Result: [17, 2, 2021-05-20, 0:0:0:0:0:0:0:1, 111222, approved, tom]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20026, rs-50025} Result: [15, 9, 2019-03-30, 0:0:0:0:0:0:0:1, asdaa阿斯顿, approved, tom]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20026, rs-50025} Result: [1, 12, 2018-12-13, 0:0:0:0:0:0:0:1, 很不错，不过这文章排版不太好看啊, approved, 李四]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20026, rs-50025} Result: [2, 11, 2018-12-13, 0:0:0:0:0:0:0:1, 很不错的原理分析，受用了！, approved, 李四]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20026, rs-50025} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20026} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20027} created. select count('article_id') from t_article;
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20027} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20027} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20027} executed. 0.3074 millis. select count('article_id') from t_article;
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20027, rs-50026} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20027, rs-50026} Header: [count('article_id')]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20027, rs-50026} Result: [12]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20027, rs-50026} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20027} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][com.boot.controller.adminController]2021-05-22 23:16:07   用户名：admin进入后台发布页面
[DEBUG][21-05-22][com.boot.controller.adminController]2021-05-22 23:16:07   用户名：admin查看文章列表
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20028} created. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20028} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20028} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20028} executed. 0.5855 millis. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20028, rs-50027} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20028, rs-50027} Header: [count(0)]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20028, rs-50027} Result: [12]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20028, rs-50027} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20028} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20029} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
	order by created desc LIMIT ? 
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20029} Parameters : [6]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20029} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20029} executed. 0.9755 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
	order by created desc LIMIT ? 
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20029, rs-50028} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20029, rs-50028} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20029, rs-50028} Result: [12, Spring Boot 2 权威发布,   如果这两天登录 [https://start.spring.io/ ](https://start.spring.io/ )就会发现，Spring Boot 默认版本已经升到了 2.1.0。这是因为 Spring Boot 刚刚发布了 2.1.0 版本，我们来看下 Spring Boot 2 发布以来第一个子版本都发布了哪些内容？  

**2.1 中的新特性**     
  ●将spring-boot-starter-oauth2-oidc-client重命名为spring-boot-starter-oauth2-client命名更简洁  
  ●添加 OAuth2 资源服务 starter，OAuth2 一个用于认证的组件  
  ●支持 ConditionalOnBean 和 ConditionalOnMissingBean 下的参数化容器  
  ●自动配置 applicationTaskExecutor bean 的延迟加载来避免不必要的日志记录  
  ●将 DatabaseDriver＃SAP 重命名为 DatabaseDriver  
  ●跳过重启器不仅适用于 JUnit4，也适用于 JUnit5  
  ●在 Jest HealthIndicator 中使用集群端点  
  ●当 DevTools 禁用重启时添加日志输出  
  ●添加注解：@ConditionalOnMissingServletFilter提高 Servlet Filters 的自动装配。
  
**2.1 中的组件升级**  
  ●升级 Hibernate 5.3，Hibernate 的支持升级到了 5.3  
  ●升级 Tomcat 9 ，支持最新的 tomcat 9  
  ●支持 Java 11，Java 现在更新越来越快，Spring 快赶不上了    
  ●升级 Thymeleaf Extras Springsecurity 到 3.0.4.RELEASE ，thymeleaf-extras-springsecurity 是 Thymeleaf 提供集成 Spring Security 的组件  
  ●升级 Joda Time 2.10.1，Joda-Time， 面向 Java 应用程序的日期/时间库的替代选择，Joda-Time 令时间和日期值变得易于管理、操作和理解。  
  ●升级 Lettuce 5.1.2.RELEASE ，Lettuce 前面说过，传说中 Redis 最快的客户端。  
  ●升级 Reactor Californium-SR2 ，Californium 是物联网云服务的 Java COAP 实现。因此，它更专注的是可扩展性和可用性而不是像嵌入式设备那样关注资源效率。不过，Californium 也适合嵌入式的 JVM。  
  ●升级 Maven Failsafe Plugin 2.22.1 ，Maven 中的测试插件。  
  ●升级 Flyway 5.2.1 ， Flyway是一款开源的数据库版本管理工具  
  ●升级 Aspectj 1.9.2 ，AspectJ 是 Java 中流行的 AOP（Aspect-oriented Programming）编程扩展框架，是 Eclipse 托管给 Apache 基金会的一个开源项目。  
  ●升级 Mysql 8.0.13 ，Mysql 支持到 8。  
  ●...  
  更多的详细内容可以参考这里：[Spring Boot 2.1 Release Notes](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.1-Release-Notes)
, 2018-12-12, 2021-05-22, 默认分类, Spring Boot 2, true, null, 62, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20029, rs-50028} Result: [11, Docker数据管理介绍,   当我们对容器进行相关操作时，产生的一系列数据都会存储在容器中，而Docker内部又是如果管理这些数据的呢？本篇文章将针对Docker数据管理的一些知识进行介绍。
  
**1. Docker数据存储机制**  
  使用Docker时，我们操作的都是镜像和由镜像生成的容器，所以想要更好的了解Docker内部的数据存储机制，就必须从镜像、容器与数据存储的关系出发。  
  Docker镜像是通过读取Dockerfile文件中的指令构建的，Dockerfile中的每条指令都会创建一个镜像层，并且每层都是只读的，这一系列的镜像层就构成了Docker镜像。接下来以一个Dockerfile文件为例进行说明，具体如下列代码示例所示。
```js
 1	FROM ubuntu:16.04
 2	COPY . /app
 3	RUN make /app
 4	CMD python /app/app.py
```  
   上述文件示例中的Dockerfile包含了4条指令，每条指令都会创建一个镜像层，其中每一层与前一层都有所不同，并且是层层叠加的。通过镜像构建容器时，会在镜像层上增加一个容器层（即可写层），所有对容器的更改都会写入容器层，这也是Docker默认的数据存储方式。  
  下面通过一个效果图进行说明，具体如下图所示。
![alt](/article_img/docker/6.png)
  从图中可以看出，Docker容器和镜像之间的主要区别是顶部的容器层，而所有对容器中数据的添加、修改等操作都会被存储在容器层中。当容器被删除时，容器层也会被删除，其中存储的数据会被一同删除，而下面的镜像层却保持不变。  
  由于所有的容器都是通过镜像构建的，所以每个容器都有各自的容器层，对于容器数据的更改就会保存在各自的容器层中。也就是说，由同一个镜像构建的多个容器，它们会拥有相同的底部镜像层，而拥有不同的容器层，多个容器可以访问相同的镜像层，并且有自己的独立数据状态。具体说明如下图所示。 
![alt](/article_img/docker/7.png)
  从图中可以看出，基于同一个镜像构建的多个容器可以共享该镜像层，但是多个容器想要共享相同的数据，就需要将这些数据存储到容器之外的地方，而这种方式就是下一节要提到的Docker volume数据外部挂载机制。  

**2. Docker数据存储方式**    
  在默认情况下，Docker中的数据都是存放在容器层的，但是这样存储数据却有较多的缺陷，具体表现如下。    
  ●当容器不再运行时，容器中的数据无法持久化保存，如果另一个进程需要这些数据，那么将很难从容器中获取数据；  
  ●容器层与正在运行的主机紧密耦合，不能轻易地移动数据；  
  ●容器层需要一个存储驱动程序来管理文件系统，存储驱动程序提供了一个使用Linux内核的联合文件系统，这种额外的抽象化降低了性能。  
  基于上述种种原因，多数情况下Docker数据管理都不会直接将数据写入容器层，而是使用另一种叫做Docker volume数据外部挂载的机制进行数据管理。  
  针对Docker volume数据外部挂载机制，Docker提供了三种不同的方式将数据从容器映射到Docker宿主机，他们分别为：volumes（数据卷）、bind mounts（绑定挂载）和tmpfs mounts（tmpfs挂载）。这三种数据管理方式的具体选择，需要结合实际情况进行考虑，其中的volumes数据卷是最常用也是官方推荐的数据管理方式。无论选择使用哪种数据管理方式，数据在容器内看起来都一样的，而在容器外则会被被挂载到文件系统中的某个目录或文件中。    
  下面通过一张图来展示数据卷、绑定挂载和tmpfs挂载之间的差异，如下图所示。  
![alt](/article_img/docker/8.png)
  从图中可以看出，Docker提供的三种数据管理方式略有不同，具体分析如下。  
  ●volumes：存储在主机文件系统中（在Linux系统下是存在于/var/lib/Docker/volumes/目录），并由Docker管理，非Docker进程无法修改文件系统的这个部分。  
  ●bind mounts：可以存储在主机系统的任意位置，甚至可能是重要的系统文件或目录，在Docker主机或容器上的非Docker进程可以对他们进行任意修改。  
  ●tmpfs mounts：只存储在主机系统的内存中，并没有写入到主机的文件系统中。


, 2018-12-07, 2021-05-19, 默认分类, Docker,数据管理, true, null, 19, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20029, rs-50028} Result: [10, Docker常用客户端指令介绍,   在使用Docker之前，首先会为对应的项目编写Dockerfile镜像构建文件，然后通过Docker的相关指令进行镜像构建，完成镜像的构建后，就可以使用这些项目镜像进行启动测试了。所以要想知道如何使用Docker来执行这些Dockerfile镜像构建文件，还需要学习Docker客户端的常用指令，本篇文章将对Docker客户端的常用指令进行详细讲解。  

**1.列出镜像**  
  通过docker images指令可以查看本地镜像列表中已有的镜像，具体使用方式如下。
```js
$ docker images
```  
  执行上述指令后，系统会将所有本地镜像都展示出来，如下图所示。
![alt](/article_img/docker/3.png)
  从图中可以看出，系统终端将本地镜像列表中的3个镜像分5列进行了展示，每一列的具体含义如下。  
  ●REPOSITORY：镜像名称。  
  ●TAG：镜像的参数，类似于版本号，默认是latest。  
  ●IMAGE ID：镜像ID，是唯一值。此处看到的是一个长度为12的字符串，实际上它是64位完整镜像ID的缩写形式。  
  ●CREATED：距今创建镜像的时间。  
  ●SIZE：镜像大小。    

**2.搜索镜像**  
  想知道在Docker Hub中包含了哪些镜像，除了可以登录Docker Hub，在官网中心进行查看外，还可以直接在Docker客户端进行查询。例如想要查询Ubuntu镜像，可以使用如下指令。
```js
$ docker search ubuntu
```  
  执行上述指令后，系统终端就会将搜索到的有关Ubuntu的镜像展示出来，如下图所示。
![alt](/article_img/docker/4.png)
  从图所示的结果可以看出，系统终端分5列将搜索到的Ubuntu相关镜像都列举出来了，这5列的具体含义如下。  
  ●NAME：表示镜像的名称，这里有两种格式的名称，其中不带有“/”的表示官方镜像，而带有“/”的表示其他用户的公开镜像。公开镜像“/”前面是用户在Docker Hub上的用户名（唯一），后面是对应的镜像名；官方镜像与用户镜像，除了从镜像名称上可以区分外，还可以通过第4列的OFFICIAL声明中看出（该列下内容为OK表示官方镜像）。  
  ●DESCRIPTION：表示镜像的描述，这里只显示了一小部分。  
  ●STARS：表示该镜像的收藏数，用户可以在Docker Hub上对镜像进行收藏，一般可以通过该数字反应出该镜像的受欢迎程度。  
  ●OFFICIAL：表示是否为官方镜像。  
  ●AUTOMATED：表示是否自动构建镜像。例如，用户可以将自己的Docker Hub绑定到如Github上，当代码提交更新后，可以自动构建镜像。   
 
**3.拉取镜像**  
  通过docker pull指令可以拉取仓库镜像到本地（默认都是拉取Docker Hub仓库镜像，也可以指定“IP+端口”拉取某个Docker机器上的私有仓库镜像），具体使用方式如下。
```js
$ docker pull ubuntu
```  
  执行上述指令后，Docker会自动从Docker Hub上下载最新版本的Ubuntu到本地，当然也可以使用以下指令拉取指定版本的镜像到本地，具体指令如下。
```js
$ docker pull ubuntu:14.04
```  
**4.构建镜像**  
  除了可以通过docker pull指令从仓库拉取镜像外，还可以通过docker build指令构建Docker镜像，通常情况下都是通过Dockerfile文件来构建镜像的。  
  这里假设linux系统home目录下/shitou/workspace/dockerspace文件夹中编写有对应的Dockerfile文件，则构建镜像直立示例如下所示。 
```js
$ docker build -t hellodocker3 /home/shitou/workspace/dockerspace/.
```
**5.删除镜像**  
  当本地存放过多不需要的镜像时，可以通过docker rmi指令将其删除。在删除镜像时，需要指定镜像名称或镜像ID。删除镜像的使用方式如下。
```js
$ docker rmi -f hellodocker2 hellodocker3
```  
  上述指令中，docker rmi表示删除镜像，-f表示进行强制删除，而hellodocker2和hellodocker3分别表示需要删除的镜像名称，这里同时删除两个镜像。除了根据名称删除镜像外，还也可以根据镜像ID来删除镜像，只是这里如果指定了删除ID为23c617a866d4的镜像后，会同时删除hellodocker、hellodocker2和hellodocker3三个镜像。  
  需要特别强调的是，在进行镜像删除操作时，如果是通过镜像ID进行镜像删除，那么由该镜像创建的容器必须提前删除或停止。另外，在通过镜像名称操作镜像时，如果出现镜像重名的情况，必须在镜像名称后面指定镜像标签tag参数来确保唯一性。

**6.创建并启动容器**  
  Docker镜像主要用于创建容器，可以使用docker run指令创建并启动容器，具体使用方式如下。
```js
$ docker run -d -p 5000:80 --name test hellodocker
```  
  上述创建并启动容器的指令略微复杂，具体分析如下。  
  ●docker run：表示创建并启动一个容器，而后面的hellodocker就表示要启动运行的镜像名称；  
  ●-d：表示容器启动时在后台运行；  
  ●-p 5000:80：表示将容器内暴露的80端口映射到宿主机指定的5000端口，也可以将-p 5000:80更改为-P来映射主机的随机端口（注意p字母的大小写）；  
  ●--name test：表示为创建后的容器指定名称为test，如果没有该参数配置，则生成的容器会设置一个随机名称。  
  docker run命令是Docker操作中较为复杂的一个，它可以携带多个参数和参数，我们可以通过docker run --help指令进行查看，其中有些参数如-e、-v和-w等都可以在Dockerfile文件中预先声明。 
 
**7.列出容器**  
  生成容器后，可以通过docker ps指令查看当前运行的所有容器，具体使用方式如下。
```js
$ docker ps
```  
  执行上述命令后，会将所有当前运行的容器都展示出来，具体如下图所示。
![alt](/article_img/docker/5.png)
  从图中可以看出，系统终端通过7列对当前的正在运行的一个容器进行了展示，图中每一列的具体含义如下。  
  ●CONTAINER ID：表示生成的容器ID；  
  ●IMAGE：表示生成该容器的镜像名称；  
  ●COMMAND：表示启动容器时运行的命令，Docker要求在启动容器时必须运行一个命令；  
  ●CREATED：表示容器创建的时间；  
  ●STATUS：表示容器运行状态，例如Up表示运行中，Exited表示已停止；  
  ●PORTS：表示容器内部暴露的端口映射到主机的端口；  
  ●NAMES：表示生成容器的名称，由Docker引擎自动生成，可以像上述示例中使用--name参数指定生成容器的名称。  
  另外，docker ps指令运行过程中可以指定多个参数，还可以通过docker ps --help指令对ps指令的其他信息进行查看。

**8.删除容器**  
  当不需要使用容器时，则可以使用docker rm指令删除已停止的容器，具体使用方式如下。
```js
$ docker rm f0c9a8b6e8c5
```  
  需要注意的是，上述指令只能删除已经停止运行的容器，而不能删除正在运行的容器。如果想要删除正在运行的容器，则需要添加-f参数强制删除，具体使用方式如下。
```js
$ docker rm -f f0c9a8b6e8c5
```  
  当需要删除的容器过多时，如果还一个个的删除就略显麻烦了，此时可以通过如下指令将全部容器删除。
```js
$ docker rm -f $(docker ps -aq)
```  
  上述指令中，首先会通过$(docker ps -aq)获取所有容器的ID，然后通过docker rm -f指令进行强制删除。如果开发者有自己特殊的删除需求，可以根据前面docker ps指令进行组装来获取需要删除的容器ID。  
  Docker提供的操作指令远不止这些，这里就不一一列举了，想要了解更多Docker的操作指令，可以通过docker --help指令进行查看。


, 2018-12-05, null, 默认分类, Docker,客户端指令, true, null, 21, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20029, rs-50028} Result: [9, 虚拟化容器技术——Docker运行机制介绍,   Docker是一个开源的应用容器引擎，它基于go语言开发，并遵从Apache2.0开源协议。使用Docker可以让开发者封装他们的应用以及依赖包到一个可移植的容器中，然后发布到任意的Linux机器上，也可以实现虚拟化。Docker容器完全使用沙箱机制，相互之间不会有任何接口，这保证了容器之间的安全性。  

**1. Docker的引擎介绍**

  Docker Engine（Docker引擎）是Docker的核心部分，使用的是客户端-服务器（C/S）架构模式，其主要组成部分如下图所示。
![alt](/article_img/docker/1.png)
  从上图可以看出，Docker Engine中包含了三个核心组件（docker CLI、REST API和docker daemon），这三个组件的具体说明如下：  
  ①docker CLI（command line interface）：表示Docker命令行接口，开发者可以在命令行中使用Docker相关指令与Docker守护进程进行交互，从而管理诸如image（镜像）、container（容器）、network（网络）和data volumes（数据卷）等实体。  
  ②REST API：表示应用程序API接口，开发者通过该API接口可以与Docker的守护进程进行交互，从而指示后台进行相关操作。  
  ③docker daemon：表示Docker的服务端组件，他是Docker架构中运行在后台的一个守护进程，可以接收并处理来自命令行接口及API接口的指令，然后进行相应的后台操作。  
  对于开发者而言，既可以使用编写好的脚本文件通过REST API来实现与Docker进程交互，又可以直接使用Docker相关指令通过命令行接口来与Docker进程交互，而其他一些Docker应用则是通过底层的API和CLI进行交互的。

**2. Docker的架构介绍**

  了解了Docker内部引擎及作用后，我们还需要通过Docker的具体架构，来了解Docker的整个运行流程。接下来借助Docker官网的架构图来对Docker架构进行详细说明，如下图所示。
![alt](/article_img/docker/2.jpg)
  从图中可以看出，Docker架构主要包括Client、DOCKER_HOST和Register三部分，关于这三部分的具体说明如下。  
&emsp;&emsp;**（1）Client（客户端）**  
  Client即Docker客户端，也就是上一小节Docker Engine中介绍的docker CLI。开发者通过这个客户端使用Docker的相关指令与Docker守护进程进行交互，从而进行Docker镜像的创建、拉取和运行等操作。  
&emsp;&emsp;**（2）DOCKER_HOST（Docker主机）**  
  DOCKER_HOST即Docker内部引擎运行的主机，主要指Docker daemon（Docker守护进程）。可以通过Docker守护进程与客户端还有Docker的镜像仓库Registry进行交互，从而管理Images（镜像）和Containers（容器）等。  
&emsp;&emsp;**（3）Registry（注册中心）**  
  Registry即Docker注册中心，实质就是Docker镜像仓库，默认使用的是Docker官方远程注册中心Docker Hub，也可以使用开发者搭建的本地仓库。Registry中包含了大量的镜像，这些镜像可以是官网基础镜像，也可以是其他开发者上传的镜像。  
  我们在实际使用Docker时，除了会涉及到图中的三个主要部分外，还会涉及到很多Docker Objects（Docker对象），例如Images（镜像）、Containers（容器）、Networks（网络）、Volumes（数据卷）、Plugins（插件）等。其中常用的两个对象Image和Containers的说明如下。  
  ①Images（镜像）  
  Docker 镜像就是一个只读的模板，包含了一些创建Docker容器的操作指令。通常情况下，一个Docker镜像是基于另一个基础镜像创建的，并且新创建的镜像会额外包含一些功能配置。例如：开发者可以依赖于一个Ubuntu的基础镜像创建一个新镜像，并可以在新镜像中安装Apache等软件或其它应用程序。  
  ②Containers（容器）  
  Docker容器属于镜像的一个可运行实例（镜像与容器的关系其实与Java中的类与对象相似），开发者可以通过API接口或者CLI命令行接口来创建、运行、停止、移动、删除一个容器，也可以将一个容器连接到一个或多个网络中，将数据存储与容器进行关联。



, 2018-12-03, null, 默认分类, 虚拟化容器,Docker,运行机制, true, null, 26, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20029, rs-50028} Result: [8, JDK 8——聚合操作, &emsp;&emsp;在Java8版本中，JDK包含许多聚合操作（如平均值，总和，最小，最大，和计数），返回一个计算流stream的聚合结果。这些聚合操作被称为聚合操作。JDK除返回单个值的聚合操作外，还有很多聚合操作返回一个collection集合实例。很多的reduce操作执行特定的任务，如求平均值或按类别分组元素。  

**1. 聚合操作简介**

  在开发中，多数情况下会涉及到对集合、数组中元素的操作，在JDK 8之前都是通过普通的循环遍历出每一个元素，然后还会穿插一些if条件语句选择性的对元素进行查找、过滤、修改等操作，这种原始的操作方法虽然可行，但是代码量较大并且执行效率较低。  
  为此，JDK 8中新增了一个Stream接口，该接口可以将集合、数组的中的元素转换为Stream流的形式，并结合Lambda表达式的优势来进一步简化集合、数组中元素的查找、过滤、转换等操作，这一新功能就是JDK 8中的聚合操作。  
  在程序中，使用聚合操作没有绝对的语法规范，根据实际操作流程，主要可以分为以下3个步骤：  
  （1）将原始集合或者数组对象转换为Stream流对象；  
  （2）对Stream流对象中的元素进行一系列的过滤、查找等中间操作（Intermediate Operations），然后仍然返回一个Stream流对象；  
  （3）对Stream流进行遍历、统计、收集等终结操作（Terminal Operation），获取想要的结果。  
  接下来，就根据上面聚合操作的3个步骤，通过一个案例来演示聚合操作的基本用法，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example31 {
 4		public static void main(String[] args) {
 5	          // 创建一个List集合对象
 6			List<String> list = new ArrayList<>(); 
 7			list.add("张三");
 8			list.add("李四");
 9			list.add("张小明");
 10			list.add("张阳");
 11			// 1、创建一个Stream流对象
 12			Stream<String> stream = list.stream();
 13			// 2、对Stream流中的元素分别进行过滤、截取操作
 14		       Stream<String> stream2 = stream.filter(i -> i.startsWith("张"));
 15			Stream<String> stream3 = stream2.limit(2);
 16			// 3、对Stream流中的元素进行终结操作，进行遍历输出
 17			stream3.forEach(j -> System.out.println(j));
 18			System.out.println("=======");
 19	         // 通过链式表达式的形式完成聚合操作
 20			list.stream().filter(i -> i.startsWith("张"))
 21						 .limit(2)
 22						 .forEach(j -> System.out.println(j));
 23		}
 24	}
``` 
   运行结果如下图所示。
![alt](/article_img/lambda/3.jpg)
  上述示例代码中，先创建了一个List集合，然后根据聚合操作的3个步骤实现了集合对象的聚合操作，对集合中的元素使用Stream流的形式进行过滤（filter）、截取（limit），并进行遍历输出。其中第12~17行代码分步骤详细展示了聚合操作，而第20~22行代码是使用了链式表达式（调用有返回值的方法时不获取返回值而是直接再调用另一个方法）实现了聚合操作，该表达式的语法格式更简洁、高效，这种链式调用也被称为操作管道流。

**2. 创建Stream流对象**  
  在上一小节中，介绍了聚合操作的主要使用步骤，其中首要解决的问题就是创建Stream流对象。聚合操作针对的就是可迭代数据进行的操作，如集合、数组等，所以创建Stream流对象其实就是将集合、数组等通过一些方法转换为Stream流对象。  
  在Java中，集合对象有对应的集合类，可以通过集合类提供的静态方法创建Stream流对象，而数组数据却没有对应的数组类，所以必须通过其他方法创建Stream流对象。针对不同的源数据，Java提供了多种创建Stream流对象的方式，分别如下：  
  （1）所有的Collections集合都可以使用stream()静态方法获取Stream流对象；  
  （2）Stream接口的of()静态方法可以获取基本类型包装类数组、引用类型数组和单个元素的Stream流对象；  
  （3）Arrays数组工具类的stream()静态方法也可以获取数组元素的Stream流对象。  
  接下来，通过一个案例来学习聚合操作中如何创建Stream流对象，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example32 {
 4		public static void main(String[] args) {
 5	          // 创建一个数组
 6			Integer[] array = { 9, 8, 3, 5, 2 };       
 7	          // 将数组转换为List集合
 8			List<Integer> list = Arrays.asList(array); 
 9			// 1、使用集合对象的stream()静态方法创建Stream流对象
 10			Stream<Integer> stream = list.stream();
 11			stream.forEach(i -> System.out.print(i+" "));
 12			System.out.println();
 13			// 2、使用Stream接口的of()静态方法创建Stream流对象
 14			Stream<Integer> stream2 = Stream.of(array);
 15			stream2.forEach(i -> System.out.print(i+" "));
 16			System.out.println();
 17			// 3、使用Arrays数组工具类的stream()静态方法创建Stream流对象
 18			Stream<Integer> stream3 = Arrays.stream(array);
 19			stream3.forEach(i -> System.out.print(i+" "));
 20		}
 21	}
```  
  运行结果如下图所示。
![alt](/article_img/lambda/4.jpg)
  上述示例代码中，先创建了一个数组和一个集合，然后通过三种方式实现了Stream流对象的创建，并通过Stream流对象的forEach()方法结合Lambda表达式完成了集合和数组中元素的遍历。  

**小提示：**  
  在JDK 8中，只针对单列集合Collections接口对象提供了stream()静态方法获取Stream流对象，并未对Map集合提供相关方法获取Stream流对象，所以想要用Map集合创建Stream流对象必须先通过Map集合的keySet()、values()、entrySet()等方法将Map集合转换为单列Set集合，然后再使用单列集合的stream()静态方法获取对应键、值集合的Stream流对象。

, 2018-12-02, null, 默认分类, JDK 8,聚合操作, true, null, 36, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20029, rs-50028} Result: [7, 函数式接口, &emsp;&emsp;虽然Lambda表达式可以实现匿名内部类的功能，但在使用时却有一个局限，即接口中有且只有一个抽象方法时才能使用Lamdba表达式代替匿名内部类。这是因为Lamdba表达式是基于函数式接口实现的，所谓函数式接口是指有且仅有一个抽象方法的接口，Lambda表达式就是Java中函数式编程的体现，只有确保接口中有且仅有一个抽象方法，Lambda表达式才能顺利地推导出所实现的这个接口中的方法。  
&emsp;&emsp;在JDK 8中，专门为函数式接口引入了一个@FunctionalInterface注解，该注解只是显示的标注了接口是一个函数式接口，并强制编辑器进行更严格的检查，确保该接口是函数式接口，如果不是函数式接口，那么编译器就会报错，而对程序运行并没有实质上的影响。  
&emsp;&emsp;接下来通过一个案例来演示函数式接口的定义与使用，示例代码如下所示。
```js
 1	// 定义无参、无返回值的函数式接口
 2	@FunctionalInterface
 3	interface Animal {
 4		void shout();
 5	}
 6	// 定义有参、有返回值的函数式接口
 7	interface Calculate {
 8		int sum(int a, int b);
 9	}
 10	public class Example23 {
 11		public static void main(String[] args) {
 12		   // 分别两个函数式接口进行测试
 13		   animalShout(() -> System.out.println("无参、无返回值的函数式接口调用"));
 14		   showSum(10, 20, (x, y) -> x + y);
 15		}
 16		// 创建一个动物叫的方法，并传入接口对象Animal作为参数
 17		private static void animalShout(Animal animal) {
 18			animal.shout();
 19		}
 20		// 创建一个求和的方法，并传入两个int类型以及接口Calculate类型的参数
 21		private static void showSum(int x, int y, Calculate calculate) {
 22		   System.out.println(x + "+" + y + "的和为：" + calculate.sum(x, y));
 23		}
 24	}
```  
&emsp;&emsp;运行结果如下图所示。

![alt](/article_img/lambda/2.jpg)
&emsp;&emsp;上述代码示例中，先定义了两个函数式接口Animal和Calculate，然后在测试类中分别编写了两个静态方法，并将这两个函数式接口以参数的形式传入，最后在main()方法中分别调用这两个静态方法，并将所需要的函数式接口参数以Lambda表达式的形式传入。从图中可以看出，程序中函数式接口的定义和使用完全正确。
, 2018-12-01, null, 默认分类, 接口,函数式接口, true, null, 12, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20029, rs-50028} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20029} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][com.boot.controller.adminController]2021-05-22 23:16:07   用户名：admin进入文章编辑页面
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20030} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail
    FROM
    t_article
    WHERE
	t_article.id = ?
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20030} Parameters : [12]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20030} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20030} executed. 0.7737 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail
    FROM
    t_article
    WHERE
	t_article.id = ?
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20030, rs-50029} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20030, rs-50029} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20030, rs-50029} Result: [12, Spring Boot 2 权威发布,   如果这两天登录 [https://start.spring.io/ ](https://start.spring.io/ )就会发现，Spring Boot 默认版本已经升到了 2.1.0。这是因为 Spring Boot 刚刚发布了 2.1.0 版本，我们来看下 Spring Boot 2 发布以来第一个子版本都发布了哪些内容？  

**2.1 中的新特性**     
  ●将spring-boot-starter-oauth2-oidc-client重命名为spring-boot-starter-oauth2-client命名更简洁  
  ●添加 OAuth2 资源服务 starter，OAuth2 一个用于认证的组件  
  ●支持 ConditionalOnBean 和 ConditionalOnMissingBean 下的参数化容器  
  ●自动配置 applicationTaskExecutor bean 的延迟加载来避免不必要的日志记录  
  ●将 DatabaseDriver＃SAP 重命名为 DatabaseDriver  
  ●跳过重启器不仅适用于 JUnit4，也适用于 JUnit5  
  ●在 Jest HealthIndicator 中使用集群端点  
  ●当 DevTools 禁用重启时添加日志输出  
  ●添加注解：@ConditionalOnMissingServletFilter提高 Servlet Filters 的自动装配。
  
**2.1 中的组件升级**  
  ●升级 Hibernate 5.3，Hibernate 的支持升级到了 5.3  
  ●升级 Tomcat 9 ，支持最新的 tomcat 9  
  ●支持 Java 11，Java 现在更新越来越快，Spring 快赶不上了    
  ●升级 Thymeleaf Extras Springsecurity 到 3.0.4.RELEASE ，thymeleaf-extras-springsecurity 是 Thymeleaf 提供集成 Spring Security 的组件  
  ●升级 Joda Time 2.10.1，Joda-Time， 面向 Java 应用程序的日期/时间库的替代选择，Joda-Time 令时间和日期值变得易于管理、操作和理解。  
  ●升级 Lettuce 5.1.2.RELEASE ，Lettuce 前面说过，传说中 Redis 最快的客户端。  
  ●升级 Reactor Californium-SR2 ，Californium 是物联网云服务的 Java COAP 实现。因此，它更专注的是可扩展性和可用性而不是像嵌入式设备那样关注资源效率。不过，Californium 也适合嵌入式的 JVM。  
  ●升级 Maven Failsafe Plugin 2.22.1 ，Maven 中的测试插件。  
  ●升级 Flyway 5.2.1 ， Flyway是一款开源的数据库版本管理工具  
  ●升级 Aspectj 1.9.2 ，AspectJ 是 Java 中流行的 AOP（Aspect-oriented Programming）编程扩展框架，是 Eclipse 托管给 Apache 基金会的一个开源项目。  
  ●升级 Mysql 8.0.13 ，Mysql 支持到 8。  
  ●...  
  更多的详细内容可以参考这里：[Spring Boot 2.1 Release Notes](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.1-Release-Notes)
, 2018-12-12, 2021-05-22, 默认分类, Spring Boot 2, true, null]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20030, rs-50029} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20030} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][com.boot.controller.adminController]2021-05-22 23:16:08   用户名：admin查看文章列表
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20031} created. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20031} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20031} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20031} executed. 0.4787 millis. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20031, rs-50030} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20031, rs-50030} Header: [count(0)]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20031, rs-50030} Result: [12]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20031, rs-50030} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20031} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20032} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
	order by created desc LIMIT ? 
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20032} Parameters : [6]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20032} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20032} executed. 0.7813 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
	order by created desc LIMIT ? 
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20032, rs-50031} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20032, rs-50031} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20032, rs-50031} Result: [12, Spring Boot 2 权威发布,   如果这两天登录 [https://start.spring.io/ ](https://start.spring.io/ )就会发现，Spring Boot 默认版本已经升到了 2.1.0。这是因为 Spring Boot 刚刚发布了 2.1.0 版本，我们来看下 Spring Boot 2 发布以来第一个子版本都发布了哪些内容？  

**2.1 中的新特性**     
  ●将spring-boot-starter-oauth2-oidc-client重命名为spring-boot-starter-oauth2-client命名更简洁  
  ●添加 OAuth2 资源服务 starter，OAuth2 一个用于认证的组件  
  ●支持 ConditionalOnBean 和 ConditionalOnMissingBean 下的参数化容器  
  ●自动配置 applicationTaskExecutor bean 的延迟加载来避免不必要的日志记录  
  ●将 DatabaseDriver＃SAP 重命名为 DatabaseDriver  
  ●跳过重启器不仅适用于 JUnit4，也适用于 JUnit5  
  ●在 Jest HealthIndicator 中使用集群端点  
  ●当 DevTools 禁用重启时添加日志输出  
  ●添加注解：@ConditionalOnMissingServletFilter提高 Servlet Filters 的自动装配。
  
**2.1 中的组件升级**  
  ●升级 Hibernate 5.3，Hibernate 的支持升级到了 5.3  
  ●升级 Tomcat 9 ，支持最新的 tomcat 9  
  ●支持 Java 11，Java 现在更新越来越快，Spring 快赶不上了    
  ●升级 Thymeleaf Extras Springsecurity 到 3.0.4.RELEASE ，thymeleaf-extras-springsecurity 是 Thymeleaf 提供集成 Spring Security 的组件  
  ●升级 Joda Time 2.10.1，Joda-Time， 面向 Java 应用程序的日期/时间库的替代选择，Joda-Time 令时间和日期值变得易于管理、操作和理解。  
  ●升级 Lettuce 5.1.2.RELEASE ，Lettuce 前面说过，传说中 Redis 最快的客户端。  
  ●升级 Reactor Californium-SR2 ，Californium 是物联网云服务的 Java COAP 实现。因此，它更专注的是可扩展性和可用性而不是像嵌入式设备那样关注资源效率。不过，Californium 也适合嵌入式的 JVM。  
  ●升级 Maven Failsafe Plugin 2.22.1 ，Maven 中的测试插件。  
  ●升级 Flyway 5.2.1 ， Flyway是一款开源的数据库版本管理工具  
  ●升级 Aspectj 1.9.2 ，AspectJ 是 Java 中流行的 AOP（Aspect-oriented Programming）编程扩展框架，是 Eclipse 托管给 Apache 基金会的一个开源项目。  
  ●升级 Mysql 8.0.13 ，Mysql 支持到 8。  
  ●...  
  更多的详细内容可以参考这里：[Spring Boot 2.1 Release Notes](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.1-Release-Notes)
, 2018-12-12, 2021-05-22, 默认分类, Spring Boot 2, true, null, 62, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20032, rs-50031} Result: [11, Docker数据管理介绍,   当我们对容器进行相关操作时，产生的一系列数据都会存储在容器中，而Docker内部又是如果管理这些数据的呢？本篇文章将针对Docker数据管理的一些知识进行介绍。
  
**1. Docker数据存储机制**  
  使用Docker时，我们操作的都是镜像和由镜像生成的容器，所以想要更好的了解Docker内部的数据存储机制，就必须从镜像、容器与数据存储的关系出发。  
  Docker镜像是通过读取Dockerfile文件中的指令构建的，Dockerfile中的每条指令都会创建一个镜像层，并且每层都是只读的，这一系列的镜像层就构成了Docker镜像。接下来以一个Dockerfile文件为例进行说明，具体如下列代码示例所示。
```js
 1	FROM ubuntu:16.04
 2	COPY . /app
 3	RUN make /app
 4	CMD python /app/app.py
```  
   上述文件示例中的Dockerfile包含了4条指令，每条指令都会创建一个镜像层，其中每一层与前一层都有所不同，并且是层层叠加的。通过镜像构建容器时，会在镜像层上增加一个容器层（即可写层），所有对容器的更改都会写入容器层，这也是Docker默认的数据存储方式。  
  下面通过一个效果图进行说明，具体如下图所示。
![alt](/article_img/docker/6.png)
  从图中可以看出，Docker容器和镜像之间的主要区别是顶部的容器层，而所有对容器中数据的添加、修改等操作都会被存储在容器层中。当容器被删除时，容器层也会被删除，其中存储的数据会被一同删除，而下面的镜像层却保持不变。  
  由于所有的容器都是通过镜像构建的，所以每个容器都有各自的容器层，对于容器数据的更改就会保存在各自的容器层中。也就是说，由同一个镜像构建的多个容器，它们会拥有相同的底部镜像层，而拥有不同的容器层，多个容器可以访问相同的镜像层，并且有自己的独立数据状态。具体说明如下图所示。 
![alt](/article_img/docker/7.png)
  从图中可以看出，基于同一个镜像构建的多个容器可以共享该镜像层，但是多个容器想要共享相同的数据，就需要将这些数据存储到容器之外的地方，而这种方式就是下一节要提到的Docker volume数据外部挂载机制。  

**2. Docker数据存储方式**    
  在默认情况下，Docker中的数据都是存放在容器层的，但是这样存储数据却有较多的缺陷，具体表现如下。    
  ●当容器不再运行时，容器中的数据无法持久化保存，如果另一个进程需要这些数据，那么将很难从容器中获取数据；  
  ●容器层与正在运行的主机紧密耦合，不能轻易地移动数据；  
  ●容器层需要一个存储驱动程序来管理文件系统，存储驱动程序提供了一个使用Linux内核的联合文件系统，这种额外的抽象化降低了性能。  
  基于上述种种原因，多数情况下Docker数据管理都不会直接将数据写入容器层，而是使用另一种叫做Docker volume数据外部挂载的机制进行数据管理。  
  针对Docker volume数据外部挂载机制，Docker提供了三种不同的方式将数据从容器映射到Docker宿主机，他们分别为：volumes（数据卷）、bind mounts（绑定挂载）和tmpfs mounts（tmpfs挂载）。这三种数据管理方式的具体选择，需要结合实际情况进行考虑，其中的volumes数据卷是最常用也是官方推荐的数据管理方式。无论选择使用哪种数据管理方式，数据在容器内看起来都一样的，而在容器外则会被被挂载到文件系统中的某个目录或文件中。    
  下面通过一张图来展示数据卷、绑定挂载和tmpfs挂载之间的差异，如下图所示。  
![alt](/article_img/docker/8.png)
  从图中可以看出，Docker提供的三种数据管理方式略有不同，具体分析如下。  
  ●volumes：存储在主机文件系统中（在Linux系统下是存在于/var/lib/Docker/volumes/目录），并由Docker管理，非Docker进程无法修改文件系统的这个部分。  
  ●bind mounts：可以存储在主机系统的任意位置，甚至可能是重要的系统文件或目录，在Docker主机或容器上的非Docker进程可以对他们进行任意修改。  
  ●tmpfs mounts：只存储在主机系统的内存中，并没有写入到主机的文件系统中。


, 2018-12-07, 2021-05-19, 默认分类, Docker,数据管理, true, null, 19, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20032, rs-50031} Result: [10, Docker常用客户端指令介绍,   在使用Docker之前，首先会为对应的项目编写Dockerfile镜像构建文件，然后通过Docker的相关指令进行镜像构建，完成镜像的构建后，就可以使用这些项目镜像进行启动测试了。所以要想知道如何使用Docker来执行这些Dockerfile镜像构建文件，还需要学习Docker客户端的常用指令，本篇文章将对Docker客户端的常用指令进行详细讲解。  

**1.列出镜像**  
  通过docker images指令可以查看本地镜像列表中已有的镜像，具体使用方式如下。
```js
$ docker images
```  
  执行上述指令后，系统会将所有本地镜像都展示出来，如下图所示。
![alt](/article_img/docker/3.png)
  从图中可以看出，系统终端将本地镜像列表中的3个镜像分5列进行了展示，每一列的具体含义如下。  
  ●REPOSITORY：镜像名称。  
  ●TAG：镜像的参数，类似于版本号，默认是latest。  
  ●IMAGE ID：镜像ID，是唯一值。此处看到的是一个长度为12的字符串，实际上它是64位完整镜像ID的缩写形式。  
  ●CREATED：距今创建镜像的时间。  
  ●SIZE：镜像大小。    

**2.搜索镜像**  
  想知道在Docker Hub中包含了哪些镜像，除了可以登录Docker Hub，在官网中心进行查看外，还可以直接在Docker客户端进行查询。例如想要查询Ubuntu镜像，可以使用如下指令。
```js
$ docker search ubuntu
```  
  执行上述指令后，系统终端就会将搜索到的有关Ubuntu的镜像展示出来，如下图所示。
![alt](/article_img/docker/4.png)
  从图所示的结果可以看出，系统终端分5列将搜索到的Ubuntu相关镜像都列举出来了，这5列的具体含义如下。  
  ●NAME：表示镜像的名称，这里有两种格式的名称，其中不带有“/”的表示官方镜像，而带有“/”的表示其他用户的公开镜像。公开镜像“/”前面是用户在Docker Hub上的用户名（唯一），后面是对应的镜像名；官方镜像与用户镜像，除了从镜像名称上可以区分外，还可以通过第4列的OFFICIAL声明中看出（该列下内容为OK表示官方镜像）。  
  ●DESCRIPTION：表示镜像的描述，这里只显示了一小部分。  
  ●STARS：表示该镜像的收藏数，用户可以在Docker Hub上对镜像进行收藏，一般可以通过该数字反应出该镜像的受欢迎程度。  
  ●OFFICIAL：表示是否为官方镜像。  
  ●AUTOMATED：表示是否自动构建镜像。例如，用户可以将自己的Docker Hub绑定到如Github上，当代码提交更新后，可以自动构建镜像。   
 
**3.拉取镜像**  
  通过docker pull指令可以拉取仓库镜像到本地（默认都是拉取Docker Hub仓库镜像，也可以指定“IP+端口”拉取某个Docker机器上的私有仓库镜像），具体使用方式如下。
```js
$ docker pull ubuntu
```  
  执行上述指令后，Docker会自动从Docker Hub上下载最新版本的Ubuntu到本地，当然也可以使用以下指令拉取指定版本的镜像到本地，具体指令如下。
```js
$ docker pull ubuntu:14.04
```  
**4.构建镜像**  
  除了可以通过docker pull指令从仓库拉取镜像外，还可以通过docker build指令构建Docker镜像，通常情况下都是通过Dockerfile文件来构建镜像的。  
  这里假设linux系统home目录下/shitou/workspace/dockerspace文件夹中编写有对应的Dockerfile文件，则构建镜像直立示例如下所示。 
```js
$ docker build -t hellodocker3 /home/shitou/workspace/dockerspace/.
```
**5.删除镜像**  
  当本地存放过多不需要的镜像时，可以通过docker rmi指令将其删除。在删除镜像时，需要指定镜像名称或镜像ID。删除镜像的使用方式如下。
```js
$ docker rmi -f hellodocker2 hellodocker3
```  
  上述指令中，docker rmi表示删除镜像，-f表示进行强制删除，而hellodocker2和hellodocker3分别表示需要删除的镜像名称，这里同时删除两个镜像。除了根据名称删除镜像外，还也可以根据镜像ID来删除镜像，只是这里如果指定了删除ID为23c617a866d4的镜像后，会同时删除hellodocker、hellodocker2和hellodocker3三个镜像。  
  需要特别强调的是，在进行镜像删除操作时，如果是通过镜像ID进行镜像删除，那么由该镜像创建的容器必须提前删除或停止。另外，在通过镜像名称操作镜像时，如果出现镜像重名的情况，必须在镜像名称后面指定镜像标签tag参数来确保唯一性。

**6.创建并启动容器**  
  Docker镜像主要用于创建容器，可以使用docker run指令创建并启动容器，具体使用方式如下。
```js
$ docker run -d -p 5000:80 --name test hellodocker
```  
  上述创建并启动容器的指令略微复杂，具体分析如下。  
  ●docker run：表示创建并启动一个容器，而后面的hellodocker就表示要启动运行的镜像名称；  
  ●-d：表示容器启动时在后台运行；  
  ●-p 5000:80：表示将容器内暴露的80端口映射到宿主机指定的5000端口，也可以将-p 5000:80更改为-P来映射主机的随机端口（注意p字母的大小写）；  
  ●--name test：表示为创建后的容器指定名称为test，如果没有该参数配置，则生成的容器会设置一个随机名称。  
  docker run命令是Docker操作中较为复杂的一个，它可以携带多个参数和参数，我们可以通过docker run --help指令进行查看，其中有些参数如-e、-v和-w等都可以在Dockerfile文件中预先声明。 
 
**7.列出容器**  
  生成容器后，可以通过docker ps指令查看当前运行的所有容器，具体使用方式如下。
```js
$ docker ps
```  
  执行上述命令后，会将所有当前运行的容器都展示出来，具体如下图所示。
![alt](/article_img/docker/5.png)
  从图中可以看出，系统终端通过7列对当前的正在运行的一个容器进行了展示，图中每一列的具体含义如下。  
  ●CONTAINER ID：表示生成的容器ID；  
  ●IMAGE：表示生成该容器的镜像名称；  
  ●COMMAND：表示启动容器时运行的命令，Docker要求在启动容器时必须运行一个命令；  
  ●CREATED：表示容器创建的时间；  
  ●STATUS：表示容器运行状态，例如Up表示运行中，Exited表示已停止；  
  ●PORTS：表示容器内部暴露的端口映射到主机的端口；  
  ●NAMES：表示生成容器的名称，由Docker引擎自动生成，可以像上述示例中使用--name参数指定生成容器的名称。  
  另外，docker ps指令运行过程中可以指定多个参数，还可以通过docker ps --help指令对ps指令的其他信息进行查看。

**8.删除容器**  
  当不需要使用容器时，则可以使用docker rm指令删除已停止的容器，具体使用方式如下。
```js
$ docker rm f0c9a8b6e8c5
```  
  需要注意的是，上述指令只能删除已经停止运行的容器，而不能删除正在运行的容器。如果想要删除正在运行的容器，则需要添加-f参数强制删除，具体使用方式如下。
```js
$ docker rm -f f0c9a8b6e8c5
```  
  当需要删除的容器过多时，如果还一个个的删除就略显麻烦了，此时可以通过如下指令将全部容器删除。
```js
$ docker rm -f $(docker ps -aq)
```  
  上述指令中，首先会通过$(docker ps -aq)获取所有容器的ID，然后通过docker rm -f指令进行强制删除。如果开发者有自己特殊的删除需求，可以根据前面docker ps指令进行组装来获取需要删除的容器ID。  
  Docker提供的操作指令远不止这些，这里就不一一列举了，想要了解更多Docker的操作指令，可以通过docker --help指令进行查看。


, 2018-12-05, null, 默认分类, Docker,客户端指令, true, null, 21, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20032, rs-50031} Result: [9, 虚拟化容器技术——Docker运行机制介绍,   Docker是一个开源的应用容器引擎，它基于go语言开发，并遵从Apache2.0开源协议。使用Docker可以让开发者封装他们的应用以及依赖包到一个可移植的容器中，然后发布到任意的Linux机器上，也可以实现虚拟化。Docker容器完全使用沙箱机制，相互之间不会有任何接口，这保证了容器之间的安全性。  

**1. Docker的引擎介绍**

  Docker Engine（Docker引擎）是Docker的核心部分，使用的是客户端-服务器（C/S）架构模式，其主要组成部分如下图所示。
![alt](/article_img/docker/1.png)
  从上图可以看出，Docker Engine中包含了三个核心组件（docker CLI、REST API和docker daemon），这三个组件的具体说明如下：  
  ①docker CLI（command line interface）：表示Docker命令行接口，开发者可以在命令行中使用Docker相关指令与Docker守护进程进行交互，从而管理诸如image（镜像）、container（容器）、network（网络）和data volumes（数据卷）等实体。  
  ②REST API：表示应用程序API接口，开发者通过该API接口可以与Docker的守护进程进行交互，从而指示后台进行相关操作。  
  ③docker daemon：表示Docker的服务端组件，他是Docker架构中运行在后台的一个守护进程，可以接收并处理来自命令行接口及API接口的指令，然后进行相应的后台操作。  
  对于开发者而言，既可以使用编写好的脚本文件通过REST API来实现与Docker进程交互，又可以直接使用Docker相关指令通过命令行接口来与Docker进程交互，而其他一些Docker应用则是通过底层的API和CLI进行交互的。

**2. Docker的架构介绍**

  了解了Docker内部引擎及作用后，我们还需要通过Docker的具体架构，来了解Docker的整个运行流程。接下来借助Docker官网的架构图来对Docker架构进行详细说明，如下图所示。
![alt](/article_img/docker/2.jpg)
  从图中可以看出，Docker架构主要包括Client、DOCKER_HOST和Register三部分，关于这三部分的具体说明如下。  
&emsp;&emsp;**（1）Client（客户端）**  
  Client即Docker客户端，也就是上一小节Docker Engine中介绍的docker CLI。开发者通过这个客户端使用Docker的相关指令与Docker守护进程进行交互，从而进行Docker镜像的创建、拉取和运行等操作。  
&emsp;&emsp;**（2）DOCKER_HOST（Docker主机）**  
  DOCKER_HOST即Docker内部引擎运行的主机，主要指Docker daemon（Docker守护进程）。可以通过Docker守护进程与客户端还有Docker的镜像仓库Registry进行交互，从而管理Images（镜像）和Containers（容器）等。  
&emsp;&emsp;**（3）Registry（注册中心）**  
  Registry即Docker注册中心，实质就是Docker镜像仓库，默认使用的是Docker官方远程注册中心Docker Hub，也可以使用开发者搭建的本地仓库。Registry中包含了大量的镜像，这些镜像可以是官网基础镜像，也可以是其他开发者上传的镜像。  
  我们在实际使用Docker时，除了会涉及到图中的三个主要部分外，还会涉及到很多Docker Objects（Docker对象），例如Images（镜像）、Containers（容器）、Networks（网络）、Volumes（数据卷）、Plugins（插件）等。其中常用的两个对象Image和Containers的说明如下。  
  ①Images（镜像）  
  Docker 镜像就是一个只读的模板，包含了一些创建Docker容器的操作指令。通常情况下，一个Docker镜像是基于另一个基础镜像创建的，并且新创建的镜像会额外包含一些功能配置。例如：开发者可以依赖于一个Ubuntu的基础镜像创建一个新镜像，并可以在新镜像中安装Apache等软件或其它应用程序。  
  ②Containers（容器）  
  Docker容器属于镜像的一个可运行实例（镜像与容器的关系其实与Java中的类与对象相似），开发者可以通过API接口或者CLI命令行接口来创建、运行、停止、移动、删除一个容器，也可以将一个容器连接到一个或多个网络中，将数据存储与容器进行关联。



, 2018-12-03, null, 默认分类, 虚拟化容器,Docker,运行机制, true, null, 26, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20032, rs-50031} Result: [8, JDK 8——聚合操作, &emsp;&emsp;在Java8版本中，JDK包含许多聚合操作（如平均值，总和，最小，最大，和计数），返回一个计算流stream的聚合结果。这些聚合操作被称为聚合操作。JDK除返回单个值的聚合操作外，还有很多聚合操作返回一个collection集合实例。很多的reduce操作执行特定的任务，如求平均值或按类别分组元素。  

**1. 聚合操作简介**

  在开发中，多数情况下会涉及到对集合、数组中元素的操作，在JDK 8之前都是通过普通的循环遍历出每一个元素，然后还会穿插一些if条件语句选择性的对元素进行查找、过滤、修改等操作，这种原始的操作方法虽然可行，但是代码量较大并且执行效率较低。  
  为此，JDK 8中新增了一个Stream接口，该接口可以将集合、数组的中的元素转换为Stream流的形式，并结合Lambda表达式的优势来进一步简化集合、数组中元素的查找、过滤、转换等操作，这一新功能就是JDK 8中的聚合操作。  
  在程序中，使用聚合操作没有绝对的语法规范，根据实际操作流程，主要可以分为以下3个步骤：  
  （1）将原始集合或者数组对象转换为Stream流对象；  
  （2）对Stream流对象中的元素进行一系列的过滤、查找等中间操作（Intermediate Operations），然后仍然返回一个Stream流对象；  
  （3）对Stream流进行遍历、统计、收集等终结操作（Terminal Operation），获取想要的结果。  
  接下来，就根据上面聚合操作的3个步骤，通过一个案例来演示聚合操作的基本用法，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example31 {
 4		public static void main(String[] args) {
 5	          // 创建一个List集合对象
 6			List<String> list = new ArrayList<>(); 
 7			list.add("张三");
 8			list.add("李四");
 9			list.add("张小明");
 10			list.add("张阳");
 11			// 1、创建一个Stream流对象
 12			Stream<String> stream = list.stream();
 13			// 2、对Stream流中的元素分别进行过滤、截取操作
 14		       Stream<String> stream2 = stream.filter(i -> i.startsWith("张"));
 15			Stream<String> stream3 = stream2.limit(2);
 16			// 3、对Stream流中的元素进行终结操作，进行遍历输出
 17			stream3.forEach(j -> System.out.println(j));
 18			System.out.println("=======");
 19	         // 通过链式表达式的形式完成聚合操作
 20			list.stream().filter(i -> i.startsWith("张"))
 21						 .limit(2)
 22						 .forEach(j -> System.out.println(j));
 23		}
 24	}
``` 
   运行结果如下图所示。
![alt](/article_img/lambda/3.jpg)
  上述示例代码中，先创建了一个List集合，然后根据聚合操作的3个步骤实现了集合对象的聚合操作，对集合中的元素使用Stream流的形式进行过滤（filter）、截取（limit），并进行遍历输出。其中第12~17行代码分步骤详细展示了聚合操作，而第20~22行代码是使用了链式表达式（调用有返回值的方法时不获取返回值而是直接再调用另一个方法）实现了聚合操作，该表达式的语法格式更简洁、高效，这种链式调用也被称为操作管道流。

**2. 创建Stream流对象**  
  在上一小节中，介绍了聚合操作的主要使用步骤，其中首要解决的问题就是创建Stream流对象。聚合操作针对的就是可迭代数据进行的操作，如集合、数组等，所以创建Stream流对象其实就是将集合、数组等通过一些方法转换为Stream流对象。  
  在Java中，集合对象有对应的集合类，可以通过集合类提供的静态方法创建Stream流对象，而数组数据却没有对应的数组类，所以必须通过其他方法创建Stream流对象。针对不同的源数据，Java提供了多种创建Stream流对象的方式，分别如下：  
  （1）所有的Collections集合都可以使用stream()静态方法获取Stream流对象；  
  （2）Stream接口的of()静态方法可以获取基本类型包装类数组、引用类型数组和单个元素的Stream流对象；  
  （3）Arrays数组工具类的stream()静态方法也可以获取数组元素的Stream流对象。  
  接下来，通过一个案例来学习聚合操作中如何创建Stream流对象，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example32 {
 4		public static void main(String[] args) {
 5	          // 创建一个数组
 6			Integer[] array = { 9, 8, 3, 5, 2 };       
 7	          // 将数组转换为List集合
 8			List<Integer> list = Arrays.asList(array); 
 9			// 1、使用集合对象的stream()静态方法创建Stream流对象
 10			Stream<Integer> stream = list.stream();
 11			stream.forEach(i -> System.out.print(i+" "));
 12			System.out.println();
 13			// 2、使用Stream接口的of()静态方法创建Stream流对象
 14			Stream<Integer> stream2 = Stream.of(array);
 15			stream2.forEach(i -> System.out.print(i+" "));
 16			System.out.println();
 17			// 3、使用Arrays数组工具类的stream()静态方法创建Stream流对象
 18			Stream<Integer> stream3 = Arrays.stream(array);
 19			stream3.forEach(i -> System.out.print(i+" "));
 20		}
 21	}
```  
  运行结果如下图所示。
![alt](/article_img/lambda/4.jpg)
  上述示例代码中，先创建了一个数组和一个集合，然后通过三种方式实现了Stream流对象的创建，并通过Stream流对象的forEach()方法结合Lambda表达式完成了集合和数组中元素的遍历。  

**小提示：**  
  在JDK 8中，只针对单列集合Collections接口对象提供了stream()静态方法获取Stream流对象，并未对Map集合提供相关方法获取Stream流对象，所以想要用Map集合创建Stream流对象必须先通过Map集合的keySet()、values()、entrySet()等方法将Map集合转换为单列Set集合，然后再使用单列集合的stream()静态方法获取对应键、值集合的Stream流对象。

, 2018-12-02, null, 默认分类, JDK 8,聚合操作, true, null, 36, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20032, rs-50031} Result: [7, 函数式接口, &emsp;&emsp;虽然Lambda表达式可以实现匿名内部类的功能，但在使用时却有一个局限，即接口中有且只有一个抽象方法时才能使用Lamdba表达式代替匿名内部类。这是因为Lamdba表达式是基于函数式接口实现的，所谓函数式接口是指有且仅有一个抽象方法的接口，Lambda表达式就是Java中函数式编程的体现，只有确保接口中有且仅有一个抽象方法，Lambda表达式才能顺利地推导出所实现的这个接口中的方法。  
&emsp;&emsp;在JDK 8中，专门为函数式接口引入了一个@FunctionalInterface注解，该注解只是显示的标注了接口是一个函数式接口，并强制编辑器进行更严格的检查，确保该接口是函数式接口，如果不是函数式接口，那么编译器就会报错，而对程序运行并没有实质上的影响。  
&emsp;&emsp;接下来通过一个案例来演示函数式接口的定义与使用，示例代码如下所示。
```js
 1	// 定义无参、无返回值的函数式接口
 2	@FunctionalInterface
 3	interface Animal {
 4		void shout();
 5	}
 6	// 定义有参、有返回值的函数式接口
 7	interface Calculate {
 8		int sum(int a, int b);
 9	}
 10	public class Example23 {
 11		public static void main(String[] args) {
 12		   // 分别两个函数式接口进行测试
 13		   animalShout(() -> System.out.println("无参、无返回值的函数式接口调用"));
 14		   showSum(10, 20, (x, y) -> x + y);
 15		}
 16		// 创建一个动物叫的方法，并传入接口对象Animal作为参数
 17		private static void animalShout(Animal animal) {
 18			animal.shout();
 19		}
 20		// 创建一个求和的方法，并传入两个int类型以及接口Calculate类型的参数
 21		private static void showSum(int x, int y, Calculate calculate) {
 22		   System.out.println(x + "+" + y + "的和为：" + calculate.sum(x, y));
 23		}
 24	}
```  
&emsp;&emsp;运行结果如下图所示。

![alt](/article_img/lambda/2.jpg)
&emsp;&emsp;上述代码示例中，先定义了两个函数式接口Animal和Calculate，然后在测试类中分别编写了两个静态方法，并将这两个函数式接口以参数的形式传入，最后在main()方法中分别调用这两个静态方法，并将所需要的函数式接口参数以Lambda表达式的形式传入。从图中可以看出，程序中函数式接口的定义和使用完全正确。
, 2018-12-01, null, 默认分类, 接口,函数式接口, true, null, 12, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20032, rs-50031} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20032} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20033} created. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20033} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20033} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20033} executed. 0.4639 millis. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20033, rs-50032} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20033, rs-50032} Header: [count(0)]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20033, rs-50032} Result: [12]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20033, rs-50032} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20033} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20034} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20034} Parameters : [5]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20034} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20034} executed. 0.3617 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20034, rs-50033} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20034, rs-50033} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20034, rs-50033} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20034, rs-50033} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20034, rs-50033} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20034, rs-50033} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20034, rs-50033} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20034, rs-50033} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20034} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20035} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20035} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20035} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20035} executed. 0.533 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20035, rs-50034} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20035, rs-50034} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20035, rs-50034} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20035, rs-50034} Result: [12, Spring Boot 2 权威发布,   如果这两天登录 [https://start.spring.io/ ](https://start.spring.io/ )就会发现，Spring Boot 默认版本已经升到了 2.1.0。这是因为 Spring Boot 刚刚发布了 2.1.0 版本，我们来看下 Spring Boot 2 发布以来第一个子版本都发布了哪些内容？  

**2.1 中的新特性**     
  ●将spring-boot-starter-oauth2-oidc-client重命名为spring-boot-starter-oauth2-client命名更简洁  
  ●添加 OAuth2 资源服务 starter，OAuth2 一个用于认证的组件  
  ●支持 ConditionalOnBean 和 ConditionalOnMissingBean 下的参数化容器  
  ●自动配置 applicationTaskExecutor bean 的延迟加载来避免不必要的日志记录  
  ●将 DatabaseDriver＃SAP 重命名为 DatabaseDriver  
  ●跳过重启器不仅适用于 JUnit4，也适用于 JUnit5  
  ●在 Jest HealthIndicator 中使用集群端点  
  ●当 DevTools 禁用重启时添加日志输出  
  ●添加注解：@ConditionalOnMissingServletFilter提高 Servlet Filters 的自动装配。
  
**2.1 中的组件升级**  
  ●升级 Hibernate 5.3，Hibernate 的支持升级到了 5.3  
  ●升级 Tomcat 9 ，支持最新的 tomcat 9  
  ●支持 Java 11，Java 现在更新越来越快，Spring 快赶不上了    
  ●升级 Thymeleaf Extras Springsecurity 到 3.0.4.RELEASE ，thymeleaf-extras-springsecurity 是 Thymeleaf 提供集成 Spring Security 的组件  
  ●升级 Joda Time 2.10.1，Joda-Time， 面向 Java 应用程序的日期/时间库的替代选择，Joda-Time 令时间和日期值变得易于管理、操作和理解。  
  ●升级 Lettuce 5.1.2.RELEASE ，Lettuce 前面说过，传说中 Redis 最快的客户端。  
  ●升级 Reactor Californium-SR2 ，Californium 是物联网云服务的 Java COAP 实现。因此，它更专注的是可扩展性和可用性而不是像嵌入式设备那样关注资源效率。不过，Californium 也适合嵌入式的 JVM。  
  ●升级 Maven Failsafe Plugin 2.22.1 ，Maven 中的测试插件。  
  ●升级 Flyway 5.2.1 ， Flyway是一款开源的数据库版本管理工具  
  ●升级 Aspectj 1.9.2 ，AspectJ 是 Java 中流行的 AOP（Aspect-oriented Programming）编程扩展框架，是 Eclipse 托管给 Apache 基金会的一个开源项目。  
  ●升级 Mysql 8.0.13 ，Mysql 支持到 8。  
  ●...  
  更多的详细内容可以参考这里：[Spring Boot 2.1 Release Notes](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.1-Release-Notes)
, 2018-12-12, 2021-05-22, 默认分类, Spring Boot 2, true, null, 62, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20035, rs-50034} Result: [8, JDK 8——聚合操作, &emsp;&emsp;在Java8版本中，JDK包含许多聚合操作（如平均值，总和，最小，最大，和计数），返回一个计算流stream的聚合结果。这些聚合操作被称为聚合操作。JDK除返回单个值的聚合操作外，还有很多聚合操作返回一个collection集合实例。很多的reduce操作执行特定的任务，如求平均值或按类别分组元素。  

**1. 聚合操作简介**

  在开发中，多数情况下会涉及到对集合、数组中元素的操作，在JDK 8之前都是通过普通的循环遍历出每一个元素，然后还会穿插一些if条件语句选择性的对元素进行查找、过滤、修改等操作，这种原始的操作方法虽然可行，但是代码量较大并且执行效率较低。  
  为此，JDK 8中新增了一个Stream接口，该接口可以将集合、数组的中的元素转换为Stream流的形式，并结合Lambda表达式的优势来进一步简化集合、数组中元素的查找、过滤、转换等操作，这一新功能就是JDK 8中的聚合操作。  
  在程序中，使用聚合操作没有绝对的语法规范，根据实际操作流程，主要可以分为以下3个步骤：  
  （1）将原始集合或者数组对象转换为Stream流对象；  
  （2）对Stream流对象中的元素进行一系列的过滤、查找等中间操作（Intermediate Operations），然后仍然返回一个Stream流对象；  
  （3）对Stream流进行遍历、统计、收集等终结操作（Terminal Operation），获取想要的结果。  
  接下来，就根据上面聚合操作的3个步骤，通过一个案例来演示聚合操作的基本用法，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example31 {
 4		public static void main(String[] args) {
 5	          // 创建一个List集合对象
 6			List<String> list = new ArrayList<>(); 
 7			list.add("张三");
 8			list.add("李四");
 9			list.add("张小明");
 10			list.add("张阳");
 11			// 1、创建一个Stream流对象
 12			Stream<String> stream = list.stream();
 13			// 2、对Stream流中的元素分别进行过滤、截取操作
 14		       Stream<String> stream2 = stream.filter(i -> i.startsWith("张"));
 15			Stream<String> stream3 = stream2.limit(2);
 16			// 3、对Stream流中的元素进行终结操作，进行遍历输出
 17			stream3.forEach(j -> System.out.println(j));
 18			System.out.println("=======");
 19	         // 通过链式表达式的形式完成聚合操作
 20			list.stream().filter(i -> i.startsWith("张"))
 21						 .limit(2)
 22						 .forEach(j -> System.out.println(j));
 23		}
 24	}
``` 
   运行结果如下图所示。
![alt](/article_img/lambda/3.jpg)
  上述示例代码中，先创建了一个List集合，然后根据聚合操作的3个步骤实现了集合对象的聚合操作，对集合中的元素使用Stream流的形式进行过滤（filter）、截取（limit），并进行遍历输出。其中第12~17行代码分步骤详细展示了聚合操作，而第20~22行代码是使用了链式表达式（调用有返回值的方法时不获取返回值而是直接再调用另一个方法）实现了聚合操作，该表达式的语法格式更简洁、高效，这种链式调用也被称为操作管道流。

**2. 创建Stream流对象**  
  在上一小节中，介绍了聚合操作的主要使用步骤，其中首要解决的问题就是创建Stream流对象。聚合操作针对的就是可迭代数据进行的操作，如集合、数组等，所以创建Stream流对象其实就是将集合、数组等通过一些方法转换为Stream流对象。  
  在Java中，集合对象有对应的集合类，可以通过集合类提供的静态方法创建Stream流对象，而数组数据却没有对应的数组类，所以必须通过其他方法创建Stream流对象。针对不同的源数据，Java提供了多种创建Stream流对象的方式，分别如下：  
  （1）所有的Collections集合都可以使用stream()静态方法获取Stream流对象；  
  （2）Stream接口的of()静态方法可以获取基本类型包装类数组、引用类型数组和单个元素的Stream流对象；  
  （3）Arrays数组工具类的stream()静态方法也可以获取数组元素的Stream流对象。  
  接下来，通过一个案例来学习聚合操作中如何创建Stream流对象，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example32 {
 4		public static void main(String[] args) {
 5	          // 创建一个数组
 6			Integer[] array = { 9, 8, 3, 5, 2 };       
 7	          // 将数组转换为List集合
 8			List<Integer> list = Arrays.asList(array); 
 9			// 1、使用集合对象的stream()静态方法创建Stream流对象
 10			Stream<Integer> stream = list.stream();
 11			stream.forEach(i -> System.out.print(i+" "));
 12			System.out.println();
 13			// 2、使用Stream接口的of()静态方法创建Stream流对象
 14			Stream<Integer> stream2 = Stream.of(array);
 15			stream2.forEach(i -> System.out.print(i+" "));
 16			System.out.println();
 17			// 3、使用Arrays数组工具类的stream()静态方法创建Stream流对象
 18			Stream<Integer> stream3 = Arrays.stream(array);
 19			stream3.forEach(i -> System.out.print(i+" "));
 20		}
 21	}
```  
  运行结果如下图所示。
![alt](/article_img/lambda/4.jpg)
  上述示例代码中，先创建了一个数组和一个集合，然后通过三种方式实现了Stream流对象的创建，并通过Stream流对象的forEach()方法结合Lambda表达式完成了集合和数组中元素的遍历。  

**小提示：**  
  在JDK 8中，只针对单列集合Collections接口对象提供了stream()静态方法获取Stream流对象，并未对Map集合提供相关方法获取Stream流对象，所以想要用Map集合创建Stream流对象必须先通过Map集合的keySet()、values()、entrySet()等方法将Map集合转换为单列Set集合，然后再使用单列集合的stream()静态方法获取对应键、值集合的Stream流对象。

, 2018-12-02, null, 默认分类, JDK 8,聚合操作, true, null, 36, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20035, rs-50034} Result: [9, 虚拟化容器技术——Docker运行机制介绍,   Docker是一个开源的应用容器引擎，它基于go语言开发，并遵从Apache2.0开源协议。使用Docker可以让开发者封装他们的应用以及依赖包到一个可移植的容器中，然后发布到任意的Linux机器上，也可以实现虚拟化。Docker容器完全使用沙箱机制，相互之间不会有任何接口，这保证了容器之间的安全性。  

**1. Docker的引擎介绍**

  Docker Engine（Docker引擎）是Docker的核心部分，使用的是客户端-服务器（C/S）架构模式，其主要组成部分如下图所示。
![alt](/article_img/docker/1.png)
  从上图可以看出，Docker Engine中包含了三个核心组件（docker CLI、REST API和docker daemon），这三个组件的具体说明如下：  
  ①docker CLI（command line interface）：表示Docker命令行接口，开发者可以在命令行中使用Docker相关指令与Docker守护进程进行交互，从而管理诸如image（镜像）、container（容器）、network（网络）和data volumes（数据卷）等实体。  
  ②REST API：表示应用程序API接口，开发者通过该API接口可以与Docker的守护进程进行交互，从而指示后台进行相关操作。  
  ③docker daemon：表示Docker的服务端组件，他是Docker架构中运行在后台的一个守护进程，可以接收并处理来自命令行接口及API接口的指令，然后进行相应的后台操作。  
  对于开发者而言，既可以使用编写好的脚本文件通过REST API来实现与Docker进程交互，又可以直接使用Docker相关指令通过命令行接口来与Docker进程交互，而其他一些Docker应用则是通过底层的API和CLI进行交互的。

**2. Docker的架构介绍**

  了解了Docker内部引擎及作用后，我们还需要通过Docker的具体架构，来了解Docker的整个运行流程。接下来借助Docker官网的架构图来对Docker架构进行详细说明，如下图所示。
![alt](/article_img/docker/2.jpg)
  从图中可以看出，Docker架构主要包括Client、DOCKER_HOST和Register三部分，关于这三部分的具体说明如下。  
&emsp;&emsp;**（1）Client（客户端）**  
  Client即Docker客户端，也就是上一小节Docker Engine中介绍的docker CLI。开发者通过这个客户端使用Docker的相关指令与Docker守护进程进行交互，从而进行Docker镜像的创建、拉取和运行等操作。  
&emsp;&emsp;**（2）DOCKER_HOST（Docker主机）**  
  DOCKER_HOST即Docker内部引擎运行的主机，主要指Docker daemon（Docker守护进程）。可以通过Docker守护进程与客户端还有Docker的镜像仓库Registry进行交互，从而管理Images（镜像）和Containers（容器）等。  
&emsp;&emsp;**（3）Registry（注册中心）**  
  Registry即Docker注册中心，实质就是Docker镜像仓库，默认使用的是Docker官方远程注册中心Docker Hub，也可以使用开发者搭建的本地仓库。Registry中包含了大量的镜像，这些镜像可以是官网基础镜像，也可以是其他开发者上传的镜像。  
  我们在实际使用Docker时，除了会涉及到图中的三个主要部分外，还会涉及到很多Docker Objects（Docker对象），例如Images（镜像）、Containers（容器）、Networks（网络）、Volumes（数据卷）、Plugins（插件）等。其中常用的两个对象Image和Containers的说明如下。  
  ①Images（镜像）  
  Docker 镜像就是一个只读的模板，包含了一些创建Docker容器的操作指令。通常情况下，一个Docker镜像是基于另一个基础镜像创建的，并且新创建的镜像会额外包含一些功能配置。例如：开发者可以依赖于一个Ubuntu的基础镜像创建一个新镜像，并可以在新镜像中安装Apache等软件或其它应用程序。  
  ②Containers（容器）  
  Docker容器属于镜像的一个可运行实例（镜像与容器的关系其实与Java中的类与对象相似），开发者可以通过API接口或者CLI命令行接口来创建、运行、停止、移动、删除一个容器，也可以将一个容器连接到一个或多个网络中，将数据存储与容器进行关联。



, 2018-12-03, null, 默认分类, 虚拟化容器,Docker,运行机制, true, null, 26, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20035, rs-50034} Result: [10, Docker常用客户端指令介绍,   在使用Docker之前，首先会为对应的项目编写Dockerfile镜像构建文件，然后通过Docker的相关指令进行镜像构建，完成镜像的构建后，就可以使用这些项目镜像进行启动测试了。所以要想知道如何使用Docker来执行这些Dockerfile镜像构建文件，还需要学习Docker客户端的常用指令，本篇文章将对Docker客户端的常用指令进行详细讲解。  

**1.列出镜像**  
  通过docker images指令可以查看本地镜像列表中已有的镜像，具体使用方式如下。
```js
$ docker images
```  
  执行上述指令后，系统会将所有本地镜像都展示出来，如下图所示。
![alt](/article_img/docker/3.png)
  从图中可以看出，系统终端将本地镜像列表中的3个镜像分5列进行了展示，每一列的具体含义如下。  
  ●REPOSITORY：镜像名称。  
  ●TAG：镜像的参数，类似于版本号，默认是latest。  
  ●IMAGE ID：镜像ID，是唯一值。此处看到的是一个长度为12的字符串，实际上它是64位完整镜像ID的缩写形式。  
  ●CREATED：距今创建镜像的时间。  
  ●SIZE：镜像大小。    

**2.搜索镜像**  
  想知道在Docker Hub中包含了哪些镜像，除了可以登录Docker Hub，在官网中心进行查看外，还可以直接在Docker客户端进行查询。例如想要查询Ubuntu镜像，可以使用如下指令。
```js
$ docker search ubuntu
```  
  执行上述指令后，系统终端就会将搜索到的有关Ubuntu的镜像展示出来，如下图所示。
![alt](/article_img/docker/4.png)
  从图所示的结果可以看出，系统终端分5列将搜索到的Ubuntu相关镜像都列举出来了，这5列的具体含义如下。  
  ●NAME：表示镜像的名称，这里有两种格式的名称，其中不带有“/”的表示官方镜像，而带有“/”的表示其他用户的公开镜像。公开镜像“/”前面是用户在Docker Hub上的用户名（唯一），后面是对应的镜像名；官方镜像与用户镜像，除了从镜像名称上可以区分外，还可以通过第4列的OFFICIAL声明中看出（该列下内容为OK表示官方镜像）。  
  ●DESCRIPTION：表示镜像的描述，这里只显示了一小部分。  
  ●STARS：表示该镜像的收藏数，用户可以在Docker Hub上对镜像进行收藏，一般可以通过该数字反应出该镜像的受欢迎程度。  
  ●OFFICIAL：表示是否为官方镜像。  
  ●AUTOMATED：表示是否自动构建镜像。例如，用户可以将自己的Docker Hub绑定到如Github上，当代码提交更新后，可以自动构建镜像。   
 
**3.拉取镜像**  
  通过docker pull指令可以拉取仓库镜像到本地（默认都是拉取Docker Hub仓库镜像，也可以指定“IP+端口”拉取某个Docker机器上的私有仓库镜像），具体使用方式如下。
```js
$ docker pull ubuntu
```  
  执行上述指令后，Docker会自动从Docker Hub上下载最新版本的Ubuntu到本地，当然也可以使用以下指令拉取指定版本的镜像到本地，具体指令如下。
```js
$ docker pull ubuntu:14.04
```  
**4.构建镜像**  
  除了可以通过docker pull指令从仓库拉取镜像外，还可以通过docker build指令构建Docker镜像，通常情况下都是通过Dockerfile文件来构建镜像的。  
  这里假设linux系统home目录下/shitou/workspace/dockerspace文件夹中编写有对应的Dockerfile文件，则构建镜像直立示例如下所示。 
```js
$ docker build -t hellodocker3 /home/shitou/workspace/dockerspace/.
```
**5.删除镜像**  
  当本地存放过多不需要的镜像时，可以通过docker rmi指令将其删除。在删除镜像时，需要指定镜像名称或镜像ID。删除镜像的使用方式如下。
```js
$ docker rmi -f hellodocker2 hellodocker3
```  
  上述指令中，docker rmi表示删除镜像，-f表示进行强制删除，而hellodocker2和hellodocker3分别表示需要删除的镜像名称，这里同时删除两个镜像。除了根据名称删除镜像外，还也可以根据镜像ID来删除镜像，只是这里如果指定了删除ID为23c617a866d4的镜像后，会同时删除hellodocker、hellodocker2和hellodocker3三个镜像。  
  需要特别强调的是，在进行镜像删除操作时，如果是通过镜像ID进行镜像删除，那么由该镜像创建的容器必须提前删除或停止。另外，在通过镜像名称操作镜像时，如果出现镜像重名的情况，必须在镜像名称后面指定镜像标签tag参数来确保唯一性。

**6.创建并启动容器**  
  Docker镜像主要用于创建容器，可以使用docker run指令创建并启动容器，具体使用方式如下。
```js
$ docker run -d -p 5000:80 --name test hellodocker
```  
  上述创建并启动容器的指令略微复杂，具体分析如下。  
  ●docker run：表示创建并启动一个容器，而后面的hellodocker就表示要启动运行的镜像名称；  
  ●-d：表示容器启动时在后台运行；  
  ●-p 5000:80：表示将容器内暴露的80端口映射到宿主机指定的5000端口，也可以将-p 5000:80更改为-P来映射主机的随机端口（注意p字母的大小写）；  
  ●--name test：表示为创建后的容器指定名称为test，如果没有该参数配置，则生成的容器会设置一个随机名称。  
  docker run命令是Docker操作中较为复杂的一个，它可以携带多个参数和参数，我们可以通过docker run --help指令进行查看，其中有些参数如-e、-v和-w等都可以在Dockerfile文件中预先声明。 
 
**7.列出容器**  
  生成容器后，可以通过docker ps指令查看当前运行的所有容器，具体使用方式如下。
```js
$ docker ps
```  
  执行上述命令后，会将所有当前运行的容器都展示出来，具体如下图所示。
![alt](/article_img/docker/5.png)
  从图中可以看出，系统终端通过7列对当前的正在运行的一个容器进行了展示，图中每一列的具体含义如下。  
  ●CONTAINER ID：表示生成的容器ID；  
  ●IMAGE：表示生成该容器的镜像名称；  
  ●COMMAND：表示启动容器时运行的命令，Docker要求在启动容器时必须运行一个命令；  
  ●CREATED：表示容器创建的时间；  
  ●STATUS：表示容器运行状态，例如Up表示运行中，Exited表示已停止；  
  ●PORTS：表示容器内部暴露的端口映射到主机的端口；  
  ●NAMES：表示生成容器的名称，由Docker引擎自动生成，可以像上述示例中使用--name参数指定生成容器的名称。  
  另外，docker ps指令运行过程中可以指定多个参数，还可以通过docker ps --help指令对ps指令的其他信息进行查看。

**8.删除容器**  
  当不需要使用容器时，则可以使用docker rm指令删除已停止的容器，具体使用方式如下。
```js
$ docker rm f0c9a8b6e8c5
```  
  需要注意的是，上述指令只能删除已经停止运行的容器，而不能删除正在运行的容器。如果想要删除正在运行的容器，则需要添加-f参数强制删除，具体使用方式如下。
```js
$ docker rm -f f0c9a8b6e8c5
```  
  当需要删除的容器过多时，如果还一个个的删除就略显麻烦了，此时可以通过如下指令将全部容器删除。
```js
$ docker rm -f $(docker ps -aq)
```  
  上述指令中，首先会通过$(docker ps -aq)获取所有容器的ID，然后通过docker rm -f指令进行强制删除。如果开发者有自己特殊的删除需求，可以根据前面docker ps指令进行组装来获取需要删除的容器ID。  
  Docker提供的操作指令远不止这些，这里就不一一列举了，想要了解更多Docker的操作指令，可以通过docker --help指令进行查看。


, 2018-12-05, null, 默认分类, Docker,客户端指令, true, null, 21, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20035, rs-50034} Result: [11, Docker数据管理介绍,   当我们对容器进行相关操作时，产生的一系列数据都会存储在容器中，而Docker内部又是如果管理这些数据的呢？本篇文章将针对Docker数据管理的一些知识进行介绍。
  
**1. Docker数据存储机制**  
  使用Docker时，我们操作的都是镜像和由镜像生成的容器，所以想要更好的了解Docker内部的数据存储机制，就必须从镜像、容器与数据存储的关系出发。  
  Docker镜像是通过读取Dockerfile文件中的指令构建的，Dockerfile中的每条指令都会创建一个镜像层，并且每层都是只读的，这一系列的镜像层就构成了Docker镜像。接下来以一个Dockerfile文件为例进行说明，具体如下列代码示例所示。
```js
 1	FROM ubuntu:16.04
 2	COPY . /app
 3	RUN make /app
 4	CMD python /app/app.py
```  
   上述文件示例中的Dockerfile包含了4条指令，每条指令都会创建一个镜像层，其中每一层与前一层都有所不同，并且是层层叠加的。通过镜像构建容器时，会在镜像层上增加一个容器层（即可写层），所有对容器的更改都会写入容器层，这也是Docker默认的数据存储方式。  
  下面通过一个效果图进行说明，具体如下图所示。
![alt](/article_img/docker/6.png)
  从图中可以看出，Docker容器和镜像之间的主要区别是顶部的容器层，而所有对容器中数据的添加、修改等操作都会被存储在容器层中。当容器被删除时，容器层也会被删除，其中存储的数据会被一同删除，而下面的镜像层却保持不变。  
  由于所有的容器都是通过镜像构建的，所以每个容器都有各自的容器层，对于容器数据的更改就会保存在各自的容器层中。也就是说，由同一个镜像构建的多个容器，它们会拥有相同的底部镜像层，而拥有不同的容器层，多个容器可以访问相同的镜像层，并且有自己的独立数据状态。具体说明如下图所示。 
![alt](/article_img/docker/7.png)
  从图中可以看出，基于同一个镜像构建的多个容器可以共享该镜像层，但是多个容器想要共享相同的数据，就需要将这些数据存储到容器之外的地方，而这种方式就是下一节要提到的Docker volume数据外部挂载机制。  

**2. Docker数据存储方式**    
  在默认情况下，Docker中的数据都是存放在容器层的，但是这样存储数据却有较多的缺陷，具体表现如下。    
  ●当容器不再运行时，容器中的数据无法持久化保存，如果另一个进程需要这些数据，那么将很难从容器中获取数据；  
  ●容器层与正在运行的主机紧密耦合，不能轻易地移动数据；  
  ●容器层需要一个存储驱动程序来管理文件系统，存储驱动程序提供了一个使用Linux内核的联合文件系统，这种额外的抽象化降低了性能。  
  基于上述种种原因，多数情况下Docker数据管理都不会直接将数据写入容器层，而是使用另一种叫做Docker volume数据外部挂载的机制进行数据管理。  
  针对Docker volume数据外部挂载机制，Docker提供了三种不同的方式将数据从容器映射到Docker宿主机，他们分别为：volumes（数据卷）、bind mounts（绑定挂载）和tmpfs mounts（tmpfs挂载）。这三种数据管理方式的具体选择，需要结合实际情况进行考虑，其中的volumes数据卷是最常用也是官方推荐的数据管理方式。无论选择使用哪种数据管理方式，数据在容器内看起来都一样的，而在容器外则会被被挂载到文件系统中的某个目录或文件中。    
  下面通过一张图来展示数据卷、绑定挂载和tmpfs挂载之间的差异，如下图所示。  
![alt](/article_img/docker/8.png)
  从图中可以看出，Docker提供的三种数据管理方式略有不同，具体分析如下。  
  ●volumes：存储在主机文件系统中（在Linux系统下是存在于/var/lib/Docker/volumes/目录），并由Docker管理，非Docker进程无法修改文件系统的这个部分。  
  ●bind mounts：可以存储在主机系统的任意位置，甚至可能是重要的系统文件或目录，在Docker主机或容器上的非Docker进程可以对他们进行任意修改。  
  ●tmpfs mounts：只存储在主机系统的内存中，并没有写入到主机的文件系统中。


, 2018-12-07, 2021-05-19, 默认分类, Docker,数据管理, true, null, 19, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20035, rs-50034} Result: [6, JDK 8——Lambda表达式介绍,   Lambda表达式是JDK 8中一个重要的新特性，它使用一个清晰简洁的表达式来表达一个接口，同时Lambda表达式也简化了对集合以及数组数据的遍历、过滤和提取等操作。下面，本篇文章就对Lambda表达式进行简要介绍，并进行演示说明。

**1. Lambda表达式入门**  

  匿名内部类存在的一个问题是，如果匿名内部类的实现非常简单，例如只包含一个抽象方法的接口，那么匿名内部类的语法仍然显得比较冗余。为此，JDK 8中新增了一个特性Lambda表达式，这种表达式只针对有一个抽象方法的接口实现，以简洁的表达式形式实现接口功能来作为方法参数。  
  一个Lambda表达式由三个部分组成，分别为参数列表、“->”和表达式主体，其语法格式如下：
```js
 ([数据类型 参数名,数据类型 参数名,...]) -> {表达式主体}
```  
  从上述语法格式上看，Lambda表达式的书写非常简单，下面针对Lambda表达式的组成部分进行简单介绍，具体如下：  
  （1）([数据类型 参数名,数据类型 参数名,...])：用来向表达式主体传递接口方法需要的参数，多个参数名中间必须用英文逗号“,”进行分隔；在编写Lambda表达式时，可以省略参数的数据类型，后面的表达式主体会自动进行校对和匹配；同时，如果只有一个参数，则可以省略括号“()”。  
  （2）->：表示Lambda表达式箭牌，用来指定参数数据指向，不能省略，且必须用英文横线和大于号书写。  
  （3）{表达式主体}：由单个表达式或语句块组成的主体，本质就是接口中抽象方法的具体实现，如果表达式主体只有一条语句，那么可以省略包含主体的大括号；另外，在Lambda表达式主体中允许有返回值，当只有一条return语句时，也可以省略return关键字。  
  了解了Lambda表达式的语法后，接下来编写一个示例文件对Lambda表达式的基本使用进行介绍，具体代码如下所示。
```js
 1	// 定义动物类接口
 2	interface Animal { 
 3		void shout(); // 定义方法shout()
 4	}
 5	public class Example22 {
 6		public static void main(String[] args) {
 7	       String name = "小花"; 
 8	       // 1、匿名内部类作为参数传递给animalShout()方法
 9		  animalShout(new Animal() { 
 10				 public void shout() { 
 11				    System.out.println("匿名内部类输出："+name+"喵喵...");
 12				}
 13		  });
 14		  // 2、使用Lambda表达式作为参数传递给animalShout()方法
 15	       animalShout(()-> System.out.println("Lambda表达式输出："
 16	                                                   +name+"喵喵..."));
 17		}
 18	    // 创建一个animalShout()静态方法，接收接口类型的参数
 19		public static void animalShout(Animal an) {
 20			an.shout();  
 21		}
 22	}
```  
  运行结果下图所示。
![alt](/article_img/lambda/1.jpg)
  上述代码示例中，先定义了只有一个抽象方法的接口Animal，然后分别使用匿名内部类和Lambda表达式的方式实现了接口方法。从图中可以看出，使用匿名内部类和Lambda表达式都能实现接口中方法，但很显然使用Lambda表达式更加简洁和清晰。, 2018-11-27, null, 默认分类, 2018,Lambda表达式, true, null, 18, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20035, rs-50034} Result: [7, 函数式接口, &emsp;&emsp;虽然Lambda表达式可以实现匿名内部类的功能，但在使用时却有一个局限，即接口中有且只有一个抽象方法时才能使用Lamdba表达式代替匿名内部类。这是因为Lamdba表达式是基于函数式接口实现的，所谓函数式接口是指有且仅有一个抽象方法的接口，Lambda表达式就是Java中函数式编程的体现，只有确保接口中有且仅有一个抽象方法，Lambda表达式才能顺利地推导出所实现的这个接口中的方法。  
&emsp;&emsp;在JDK 8中，专门为函数式接口引入了一个@FunctionalInterface注解，该注解只是显示的标注了接口是一个函数式接口，并强制编辑器进行更严格的检查，确保该接口是函数式接口，如果不是函数式接口，那么编译器就会报错，而对程序运行并没有实质上的影响。  
&emsp;&emsp;接下来通过一个案例来演示函数式接口的定义与使用，示例代码如下所示。
```js
 1	// 定义无参、无返回值的函数式接口
 2	@FunctionalInterface
 3	interface Animal {
 4		void shout();
 5	}
 6	// 定义有参、有返回值的函数式接口
 7	interface Calculate {
 8		int sum(int a, int b);
 9	}
 10	public class Example23 {
 11		public static void main(String[] args) {
 12		   // 分别两个函数式接口进行测试
 13		   animalShout(() -> System.out.println("无参、无返回值的函数式接口调用"));
 14		   showSum(10, 20, (x, y) -> x + y);
 15		}
 16		// 创建一个动物叫的方法，并传入接口对象Animal作为参数
 17		private static void animalShout(Animal animal) {
 18			animal.shout();
 19		}
 20		// 创建一个求和的方法，并传入两个int类型以及接口Calculate类型的参数
 21		private static void showSum(int x, int y, Calculate calculate) {
 22		   System.out.println(x + "+" + y + "的和为：" + calculate.sum(x, y));
 23		}
 24	}
```  
&emsp;&emsp;运行结果如下图所示。

![alt](/article_img/lambda/2.jpg)
&emsp;&emsp;上述代码示例中，先定义了两个函数式接口Animal和Calculate，然后在测试类中分别编写了两个静态方法，并将这两个函数式接口以参数的形式传入，最后在main()方法中分别调用这两个静态方法，并将所需要的函数式接口参数以Lambda表达式的形式传入。从图中可以看出，程序中函数式接口的定义和使用完全正确。
, 2018-12-01, null, 默认分类, 接口,函数式接口, true, null, 12, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20035, rs-50034} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20035, rs-50034} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20035, rs-50034} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20035, rs-50034} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20035, rs-50034} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20035} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} connected
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} created. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} executed. 11.3838 millis. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Header: [count(0)]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [12]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} Parameters : [5]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} executed. 2.0797 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} Parameters : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} Types : []
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} executed. 1.3086 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [12, Spring Boot 2 权威发布,   如果这两天登录 [https://start.spring.io/ ](https://start.spring.io/ )就会发现，Spring Boot 默认版本已经升到了 2.1.0。这是因为 Spring Boot 刚刚发布了 2.1.0 版本，我们来看下 Spring Boot 2 发布以来第一个子版本都发布了哪些内容？  

**2.1 中的新特性**     
  ●将spring-boot-starter-oauth2-oidc-client重命名为spring-boot-starter-oauth2-client命名更简洁  
  ●添加 OAuth2 资源服务 starter，OAuth2 一个用于认证的组件  
  ●支持 ConditionalOnBean 和 ConditionalOnMissingBean 下的参数化容器  
  ●自动配置 applicationTaskExecutor bean 的延迟加载来避免不必要的日志记录  
  ●将 DatabaseDriver＃SAP 重命名为 DatabaseDriver  
  ●跳过重启器不仅适用于 JUnit4，也适用于 JUnit5  
  ●在 Jest HealthIndicator 中使用集群端点  
  ●当 DevTools 禁用重启时添加日志输出  
  ●添加注解：@ConditionalOnMissingServletFilter提高 Servlet Filters 的自动装配。
  
**2.1 中的组件升级**  
  ●升级 Hibernate 5.3，Hibernate 的支持升级到了 5.3  
  ●升级 Tomcat 9 ，支持最新的 tomcat 9  
  ●支持 Java 11，Java 现在更新越来越快，Spring 快赶不上了    
  ●升级 Thymeleaf Extras Springsecurity 到 3.0.4.RELEASE ，thymeleaf-extras-springsecurity 是 Thymeleaf 提供集成 Spring Security 的组件  
  ●升级 Joda Time 2.10.1，Joda-Time， 面向 Java 应用程序的日期/时间库的替代选择，Joda-Time 令时间和日期值变得易于管理、操作和理解。  
  ●升级 Lettuce 5.1.2.RELEASE ，Lettuce 前面说过，传说中 Redis 最快的客户端。  
  ●升级 Reactor Californium-SR2 ，Californium 是物联网云服务的 Java COAP 实现。因此，它更专注的是可扩展性和可用性而不是像嵌入式设备那样关注资源效率。不过，Californium 也适合嵌入式的 JVM。  
  ●升级 Maven Failsafe Plugin 2.22.1 ，Maven 中的测试插件。  
  ●升级 Flyway 5.2.1 ， Flyway是一款开源的数据库版本管理工具  
  ●升级 Aspectj 1.9.2 ，AspectJ 是 Java 中流行的 AOP（Aspect-oriented Programming）编程扩展框架，是 Eclipse 托管给 Apache 基金会的一个开源项目。  
  ●升级 Mysql 8.0.13 ，Mysql 支持到 8。  
  ●...  
  更多的详细内容可以参考这里：[Spring Boot 2.1 Release Notes](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.1-Release-Notes)
, 2018-12-12, 2021-05-22, 默认分类, Spring Boot 2, true, null, 62, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [8, JDK 8——聚合操作, &emsp;&emsp;在Java8版本中，JDK包含许多聚合操作（如平均值，总和，最小，最大，和计数），返回一个计算流stream的聚合结果。这些聚合操作被称为聚合操作。JDK除返回单个值的聚合操作外，还有很多聚合操作返回一个collection集合实例。很多的reduce操作执行特定的任务，如求平均值或按类别分组元素。  

**1. 聚合操作简介**

  在开发中，多数情况下会涉及到对集合、数组中元素的操作，在JDK 8之前都是通过普通的循环遍历出每一个元素，然后还会穿插一些if条件语句选择性的对元素进行查找、过滤、修改等操作，这种原始的操作方法虽然可行，但是代码量较大并且执行效率较低。  
  为此，JDK 8中新增了一个Stream接口，该接口可以将集合、数组的中的元素转换为Stream流的形式，并结合Lambda表达式的优势来进一步简化集合、数组中元素的查找、过滤、转换等操作，这一新功能就是JDK 8中的聚合操作。  
  在程序中，使用聚合操作没有绝对的语法规范，根据实际操作流程，主要可以分为以下3个步骤：  
  （1）将原始集合或者数组对象转换为Stream流对象；  
  （2）对Stream流对象中的元素进行一系列的过滤、查找等中间操作（Intermediate Operations），然后仍然返回一个Stream流对象；  
  （3）对Stream流进行遍历、统计、收集等终结操作（Terminal Operation），获取想要的结果。  
  接下来，就根据上面聚合操作的3个步骤，通过一个案例来演示聚合操作的基本用法，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example31 {
 4		public static void main(String[] args) {
 5	          // 创建一个List集合对象
 6			List<String> list = new ArrayList<>(); 
 7			list.add("张三");
 8			list.add("李四");
 9			list.add("张小明");
 10			list.add("张阳");
 11			// 1、创建一个Stream流对象
 12			Stream<String> stream = list.stream();
 13			// 2、对Stream流中的元素分别进行过滤、截取操作
 14		       Stream<String> stream2 = stream.filter(i -> i.startsWith("张"));
 15			Stream<String> stream3 = stream2.limit(2);
 16			// 3、对Stream流中的元素进行终结操作，进行遍历输出
 17			stream3.forEach(j -> System.out.println(j));
 18			System.out.println("=======");
 19	         // 通过链式表达式的形式完成聚合操作
 20			list.stream().filter(i -> i.startsWith("张"))
 21						 .limit(2)
 22						 .forEach(j -> System.out.println(j));
 23		}
 24	}
``` 
   运行结果如下图所示。
![alt](/article_img/lambda/3.jpg)
  上述示例代码中，先创建了一个List集合，然后根据聚合操作的3个步骤实现了集合对象的聚合操作，对集合中的元素使用Stream流的形式进行过滤（filter）、截取（limit），并进行遍历输出。其中第12~17行代码分步骤详细展示了聚合操作，而第20~22行代码是使用了链式表达式（调用有返回值的方法时不获取返回值而是直接再调用另一个方法）实现了聚合操作，该表达式的语法格式更简洁、高效，这种链式调用也被称为操作管道流。

**2. 创建Stream流对象**  
  在上一小节中，介绍了聚合操作的主要使用步骤，其中首要解决的问题就是创建Stream流对象。聚合操作针对的就是可迭代数据进行的操作，如集合、数组等，所以创建Stream流对象其实就是将集合、数组等通过一些方法转换为Stream流对象。  
  在Java中，集合对象有对应的集合类，可以通过集合类提供的静态方法创建Stream流对象，而数组数据却没有对应的数组类，所以必须通过其他方法创建Stream流对象。针对不同的源数据，Java提供了多种创建Stream流对象的方式，分别如下：  
  （1）所有的Collections集合都可以使用stream()静态方法获取Stream流对象；  
  （2）Stream接口的of()静态方法可以获取基本类型包装类数组、引用类型数组和单个元素的Stream流对象；  
  （3）Arrays数组工具类的stream()静态方法也可以获取数组元素的Stream流对象。  
  接下来，通过一个案例来学习聚合操作中如何创建Stream流对象，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example32 {
 4		public static void main(String[] args) {
 5	          // 创建一个数组
 6			Integer[] array = { 9, 8, 3, 5, 2 };       
 7	          // 将数组转换为List集合
 8			List<Integer> list = Arrays.asList(array); 
 9			// 1、使用集合对象的stream()静态方法创建Stream流对象
 10			Stream<Integer> stream = list.stream();
 11			stream.forEach(i -> System.out.print(i+" "));
 12			System.out.println();
 13			// 2、使用Stream接口的of()静态方法创建Stream流对象
 14			Stream<Integer> stream2 = Stream.of(array);
 15			stream2.forEach(i -> System.out.print(i+" "));
 16			System.out.println();
 17			// 3、使用Arrays数组工具类的stream()静态方法创建Stream流对象
 18			Stream<Integer> stream3 = Arrays.stream(array);
 19			stream3.forEach(i -> System.out.print(i+" "));
 20		}
 21	}
```  
  运行结果如下图所示。
![alt](/article_img/lambda/4.jpg)
  上述示例代码中，先创建了一个数组和一个集合，然后通过三种方式实现了Stream流对象的创建，并通过Stream流对象的forEach()方法结合Lambda表达式完成了集合和数组中元素的遍历。  

**小提示：**  
  在JDK 8中，只针对单列集合Collections接口对象提供了stream()静态方法获取Stream流对象，并未对Map集合提供相关方法获取Stream流对象，所以想要用Map集合创建Stream流对象必须先通过Map集合的keySet()、values()、entrySet()等方法将Map集合转换为单列Set集合，然后再使用单列集合的stream()静态方法获取对应键、值集合的Stream流对象。

, 2018-12-02, null, 默认分类, JDK 8,聚合操作, true, null, 36, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [9, 虚拟化容器技术——Docker运行机制介绍,   Docker是一个开源的应用容器引擎，它基于go语言开发，并遵从Apache2.0开源协议。使用Docker可以让开发者封装他们的应用以及依赖包到一个可移植的容器中，然后发布到任意的Linux机器上，也可以实现虚拟化。Docker容器完全使用沙箱机制，相互之间不会有任何接口，这保证了容器之间的安全性。  

**1. Docker的引擎介绍**

  Docker Engine（Docker引擎）是Docker的核心部分，使用的是客户端-服务器（C/S）架构模式，其主要组成部分如下图所示。
![alt](/article_img/docker/1.png)
  从上图可以看出，Docker Engine中包含了三个核心组件（docker CLI、REST API和docker daemon），这三个组件的具体说明如下：  
  ①docker CLI（command line interface）：表示Docker命令行接口，开发者可以在命令行中使用Docker相关指令与Docker守护进程进行交互，从而管理诸如image（镜像）、container（容器）、network（网络）和data volumes（数据卷）等实体。  
  ②REST API：表示应用程序API接口，开发者通过该API接口可以与Docker的守护进程进行交互，从而指示后台进行相关操作。  
  ③docker daemon：表示Docker的服务端组件，他是Docker架构中运行在后台的一个守护进程，可以接收并处理来自命令行接口及API接口的指令，然后进行相应的后台操作。  
  对于开发者而言，既可以使用编写好的脚本文件通过REST API来实现与Docker进程交互，又可以直接使用Docker相关指令通过命令行接口来与Docker进程交互，而其他一些Docker应用则是通过底层的API和CLI进行交互的。

**2. Docker的架构介绍**

  了解了Docker内部引擎及作用后，我们还需要通过Docker的具体架构，来了解Docker的整个运行流程。接下来借助Docker官网的架构图来对Docker架构进行详细说明，如下图所示。
![alt](/article_img/docker/2.jpg)
  从图中可以看出，Docker架构主要包括Client、DOCKER_HOST和Register三部分，关于这三部分的具体说明如下。  
&emsp;&emsp;**（1）Client（客户端）**  
  Client即Docker客户端，也就是上一小节Docker Engine中介绍的docker CLI。开发者通过这个客户端使用Docker的相关指令与Docker守护进程进行交互，从而进行Docker镜像的创建、拉取和运行等操作。  
&emsp;&emsp;**（2）DOCKER_HOST（Docker主机）**  
  DOCKER_HOST即Docker内部引擎运行的主机，主要指Docker daemon（Docker守护进程）。可以通过Docker守护进程与客户端还有Docker的镜像仓库Registry进行交互，从而管理Images（镜像）和Containers（容器）等。  
&emsp;&emsp;**（3）Registry（注册中心）**  
  Registry即Docker注册中心，实质就是Docker镜像仓库，默认使用的是Docker官方远程注册中心Docker Hub，也可以使用开发者搭建的本地仓库。Registry中包含了大量的镜像，这些镜像可以是官网基础镜像，也可以是其他开发者上传的镜像。  
  我们在实际使用Docker时，除了会涉及到图中的三个主要部分外，还会涉及到很多Docker Objects（Docker对象），例如Images（镜像）、Containers（容器）、Networks（网络）、Volumes（数据卷）、Plugins（插件）等。其中常用的两个对象Image和Containers的说明如下。  
  ①Images（镜像）  
  Docker 镜像就是一个只读的模板，包含了一些创建Docker容器的操作指令。通常情况下，一个Docker镜像是基于另一个基础镜像创建的，并且新创建的镜像会额外包含一些功能配置。例如：开发者可以依赖于一个Ubuntu的基础镜像创建一个新镜像，并可以在新镜像中安装Apache等软件或其它应用程序。  
  ②Containers（容器）  
  Docker容器属于镜像的一个可运行实例（镜像与容器的关系其实与Java中的类与对象相似），开发者可以通过API接口或者CLI命令行接口来创建、运行、停止、移动、删除一个容器，也可以将一个容器连接到一个或多个网络中，将数据存储与容器进行关联。



, 2018-12-03, null, 默认分类, 虚拟化容器,Docker,运行机制, true, null, 26, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [10, Docker常用客户端指令介绍,   在使用Docker之前，首先会为对应的项目编写Dockerfile镜像构建文件，然后通过Docker的相关指令进行镜像构建，完成镜像的构建后，就可以使用这些项目镜像进行启动测试了。所以要想知道如何使用Docker来执行这些Dockerfile镜像构建文件，还需要学习Docker客户端的常用指令，本篇文章将对Docker客户端的常用指令进行详细讲解。  

**1.列出镜像**  
  通过docker images指令可以查看本地镜像列表中已有的镜像，具体使用方式如下。
```js
$ docker images
```  
  执行上述指令后，系统会将所有本地镜像都展示出来，如下图所示。
![alt](/article_img/docker/3.png)
  从图中可以看出，系统终端将本地镜像列表中的3个镜像分5列进行了展示，每一列的具体含义如下。  
  ●REPOSITORY：镜像名称。  
  ●TAG：镜像的参数，类似于版本号，默认是latest。  
  ●IMAGE ID：镜像ID，是唯一值。此处看到的是一个长度为12的字符串，实际上它是64位完整镜像ID的缩写形式。  
  ●CREATED：距今创建镜像的时间。  
  ●SIZE：镜像大小。    

**2.搜索镜像**  
  想知道在Docker Hub中包含了哪些镜像，除了可以登录Docker Hub，在官网中心进行查看外，还可以直接在Docker客户端进行查询。例如想要查询Ubuntu镜像，可以使用如下指令。
```js
$ docker search ubuntu
```  
  执行上述指令后，系统终端就会将搜索到的有关Ubuntu的镜像展示出来，如下图所示。
![alt](/article_img/docker/4.png)
  从图所示的结果可以看出，系统终端分5列将搜索到的Ubuntu相关镜像都列举出来了，这5列的具体含义如下。  
  ●NAME：表示镜像的名称，这里有两种格式的名称，其中不带有“/”的表示官方镜像，而带有“/”的表示其他用户的公开镜像。公开镜像“/”前面是用户在Docker Hub上的用户名（唯一），后面是对应的镜像名；官方镜像与用户镜像，除了从镜像名称上可以区分外，还可以通过第4列的OFFICIAL声明中看出（该列下内容为OK表示官方镜像）。  
  ●DESCRIPTION：表示镜像的描述，这里只显示了一小部分。  
  ●STARS：表示该镜像的收藏数，用户可以在Docker Hub上对镜像进行收藏，一般可以通过该数字反应出该镜像的受欢迎程度。  
  ●OFFICIAL：表示是否为官方镜像。  
  ●AUTOMATED：表示是否自动构建镜像。例如，用户可以将自己的Docker Hub绑定到如Github上，当代码提交更新后，可以自动构建镜像。   
 
**3.拉取镜像**  
  通过docker pull指令可以拉取仓库镜像到本地（默认都是拉取Docker Hub仓库镜像，也可以指定“IP+端口”拉取某个Docker机器上的私有仓库镜像），具体使用方式如下。
```js
$ docker pull ubuntu
```  
  执行上述指令后，Docker会自动从Docker Hub上下载最新版本的Ubuntu到本地，当然也可以使用以下指令拉取指定版本的镜像到本地，具体指令如下。
```js
$ docker pull ubuntu:14.04
```  
**4.构建镜像**  
  除了可以通过docker pull指令从仓库拉取镜像外，还可以通过docker build指令构建Docker镜像，通常情况下都是通过Dockerfile文件来构建镜像的。  
  这里假设linux系统home目录下/shitou/workspace/dockerspace文件夹中编写有对应的Dockerfile文件，则构建镜像直立示例如下所示。 
```js
$ docker build -t hellodocker3 /home/shitou/workspace/dockerspace/.
```
**5.删除镜像**  
  当本地存放过多不需要的镜像时，可以通过docker rmi指令将其删除。在删除镜像时，需要指定镜像名称或镜像ID。删除镜像的使用方式如下。
```js
$ docker rmi -f hellodocker2 hellodocker3
```  
  上述指令中，docker rmi表示删除镜像，-f表示进行强制删除，而hellodocker2和hellodocker3分别表示需要删除的镜像名称，这里同时删除两个镜像。除了根据名称删除镜像外，还也可以根据镜像ID来删除镜像，只是这里如果指定了删除ID为23c617a866d4的镜像后，会同时删除hellodocker、hellodocker2和hellodocker3三个镜像。  
  需要特别强调的是，在进行镜像删除操作时，如果是通过镜像ID进行镜像删除，那么由该镜像创建的容器必须提前删除或停止。另外，在通过镜像名称操作镜像时，如果出现镜像重名的情况，必须在镜像名称后面指定镜像标签tag参数来确保唯一性。

**6.创建并启动容器**  
  Docker镜像主要用于创建容器，可以使用docker run指令创建并启动容器，具体使用方式如下。
```js
$ docker run -d -p 5000:80 --name test hellodocker
```  
  上述创建并启动容器的指令略微复杂，具体分析如下。  
  ●docker run：表示创建并启动一个容器，而后面的hellodocker就表示要启动运行的镜像名称；  
  ●-d：表示容器启动时在后台运行；  
  ●-p 5000:80：表示将容器内暴露的80端口映射到宿主机指定的5000端口，也可以将-p 5000:80更改为-P来映射主机的随机端口（注意p字母的大小写）；  
  ●--name test：表示为创建后的容器指定名称为test，如果没有该参数配置，则生成的容器会设置一个随机名称。  
  docker run命令是Docker操作中较为复杂的一个，它可以携带多个参数和参数，我们可以通过docker run --help指令进行查看，其中有些参数如-e、-v和-w等都可以在Dockerfile文件中预先声明。 
 
**7.列出容器**  
  生成容器后，可以通过docker ps指令查看当前运行的所有容器，具体使用方式如下。
```js
$ docker ps
```  
  执行上述命令后，会将所有当前运行的容器都展示出来，具体如下图所示。
![alt](/article_img/docker/5.png)
  从图中可以看出，系统终端通过7列对当前的正在运行的一个容器进行了展示，图中每一列的具体含义如下。  
  ●CONTAINER ID：表示生成的容器ID；  
  ●IMAGE：表示生成该容器的镜像名称；  
  ●COMMAND：表示启动容器时运行的命令，Docker要求在启动容器时必须运行一个命令；  
  ●CREATED：表示容器创建的时间；  
  ●STATUS：表示容器运行状态，例如Up表示运行中，Exited表示已停止；  
  ●PORTS：表示容器内部暴露的端口映射到主机的端口；  
  ●NAMES：表示生成容器的名称，由Docker引擎自动生成，可以像上述示例中使用--name参数指定生成容器的名称。  
  另外，docker ps指令运行过程中可以指定多个参数，还可以通过docker ps --help指令对ps指令的其他信息进行查看。

**8.删除容器**  
  当不需要使用容器时，则可以使用docker rm指令删除已停止的容器，具体使用方式如下。
```js
$ docker rm f0c9a8b6e8c5
```  
  需要注意的是，上述指令只能删除已经停止运行的容器，而不能删除正在运行的容器。如果想要删除正在运行的容器，则需要添加-f参数强制删除，具体使用方式如下。
```js
$ docker rm -f f0c9a8b6e8c5
```  
  当需要删除的容器过多时，如果还一个个的删除就略显麻烦了，此时可以通过如下指令将全部容器删除。
```js
$ docker rm -f $(docker ps -aq)
```  
  上述指令中，首先会通过$(docker ps -aq)获取所有容器的ID，然后通过docker rm -f指令进行强制删除。如果开发者有自己特殊的删除需求，可以根据前面docker ps指令进行组装来获取需要删除的容器ID。  
  Docker提供的操作指令远不止这些，这里就不一一列举了，想要了解更多Docker的操作指令，可以通过docker --help指令进行查看。


, 2018-12-05, null, 默认分类, Docker,客户端指令, true, null, 21, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [11, Docker数据管理介绍,   当我们对容器进行相关操作时，产生的一系列数据都会存储在容器中，而Docker内部又是如果管理这些数据的呢？本篇文章将针对Docker数据管理的一些知识进行介绍。
  
**1. Docker数据存储机制**  
  使用Docker时，我们操作的都是镜像和由镜像生成的容器，所以想要更好的了解Docker内部的数据存储机制，就必须从镜像、容器与数据存储的关系出发。  
  Docker镜像是通过读取Dockerfile文件中的指令构建的，Dockerfile中的每条指令都会创建一个镜像层，并且每层都是只读的，这一系列的镜像层就构成了Docker镜像。接下来以一个Dockerfile文件为例进行说明，具体如下列代码示例所示。
```js
 1	FROM ubuntu:16.04
 2	COPY . /app
 3	RUN make /app
 4	CMD python /app/app.py
```  
   上述文件示例中的Dockerfile包含了4条指令，每条指令都会创建一个镜像层，其中每一层与前一层都有所不同，并且是层层叠加的。通过镜像构建容器时，会在镜像层上增加一个容器层（即可写层），所有对容器的更改都会写入容器层，这也是Docker默认的数据存储方式。  
  下面通过一个效果图进行说明，具体如下图所示。
![alt](/article_img/docker/6.png)
  从图中可以看出，Docker容器和镜像之间的主要区别是顶部的容器层，而所有对容器中数据的添加、修改等操作都会被存储在容器层中。当容器被删除时，容器层也会被删除，其中存储的数据会被一同删除，而下面的镜像层却保持不变。  
  由于所有的容器都是通过镜像构建的，所以每个容器都有各自的容器层，对于容器数据的更改就会保存在各自的容器层中。也就是说，由同一个镜像构建的多个容器，它们会拥有相同的底部镜像层，而拥有不同的容器层，多个容器可以访问相同的镜像层，并且有自己的独立数据状态。具体说明如下图所示。 
![alt](/article_img/docker/7.png)
  从图中可以看出，基于同一个镜像构建的多个容器可以共享该镜像层，但是多个容器想要共享相同的数据，就需要将这些数据存储到容器之外的地方，而这种方式就是下一节要提到的Docker volume数据外部挂载机制。  

**2. Docker数据存储方式**    
  在默认情况下，Docker中的数据都是存放在容器层的，但是这样存储数据却有较多的缺陷，具体表现如下。    
  ●当容器不再运行时，容器中的数据无法持久化保存，如果另一个进程需要这些数据，那么将很难从容器中获取数据；  
  ●容器层与正在运行的主机紧密耦合，不能轻易地移动数据；  
  ●容器层需要一个存储驱动程序来管理文件系统，存储驱动程序提供了一个使用Linux内核的联合文件系统，这种额外的抽象化降低了性能。  
  基于上述种种原因，多数情况下Docker数据管理都不会直接将数据写入容器层，而是使用另一种叫做Docker volume数据外部挂载的机制进行数据管理。  
  针对Docker volume数据外部挂载机制，Docker提供了三种不同的方式将数据从容器映射到Docker宿主机，他们分别为：volumes（数据卷）、bind mounts（绑定挂载）和tmpfs mounts（tmpfs挂载）。这三种数据管理方式的具体选择，需要结合实际情况进行考虑，其中的volumes数据卷是最常用也是官方推荐的数据管理方式。无论选择使用哪种数据管理方式，数据在容器内看起来都一样的，而在容器外则会被被挂载到文件系统中的某个目录或文件中。    
  下面通过一张图来展示数据卷、绑定挂载和tmpfs挂载之间的差异，如下图所示。  
![alt](/article_img/docker/8.png)
  从图中可以看出，Docker提供的三种数据管理方式略有不同，具体分析如下。  
  ●volumes：存储在主机文件系统中（在Linux系统下是存在于/var/lib/Docker/volumes/目录），并由Docker管理，非Docker进程无法修改文件系统的这个部分。  
  ●bind mounts：可以存储在主机系统的任意位置，甚至可能是重要的系统文件或目录，在Docker主机或容器上的非Docker进程可以对他们进行任意修改。  
  ●tmpfs mounts：只存储在主机系统的内存中，并没有写入到主机的文件系统中。


, 2018-12-07, 2021-05-19, 默认分类, Docker,数据管理, true, null, 19, 1]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [6, JDK 8——Lambda表达式介绍,   Lambda表达式是JDK 8中一个重要的新特性，它使用一个清晰简洁的表达式来表达一个接口，同时Lambda表达式也简化了对集合以及数组数据的遍历、过滤和提取等操作。下面，本篇文章就对Lambda表达式进行简要介绍，并进行演示说明。

**1. Lambda表达式入门**  

  匿名内部类存在的一个问题是，如果匿名内部类的实现非常简单，例如只包含一个抽象方法的接口，那么匿名内部类的语法仍然显得比较冗余。为此，JDK 8中新增了一个特性Lambda表达式，这种表达式只针对有一个抽象方法的接口实现，以简洁的表达式形式实现接口功能来作为方法参数。  
  一个Lambda表达式由三个部分组成，分别为参数列表、“->”和表达式主体，其语法格式如下：
```js
 ([数据类型 参数名,数据类型 参数名,...]) -> {表达式主体}
```  
  从上述语法格式上看，Lambda表达式的书写非常简单，下面针对Lambda表达式的组成部分进行简单介绍，具体如下：  
  （1）([数据类型 参数名,数据类型 参数名,...])：用来向表达式主体传递接口方法需要的参数，多个参数名中间必须用英文逗号“,”进行分隔；在编写Lambda表达式时，可以省略参数的数据类型，后面的表达式主体会自动进行校对和匹配；同时，如果只有一个参数，则可以省略括号“()”。  
  （2）->：表示Lambda表达式箭牌，用来指定参数数据指向，不能省略，且必须用英文横线和大于号书写。  
  （3）{表达式主体}：由单个表达式或语句块组成的主体，本质就是接口中抽象方法的具体实现，如果表达式主体只有一条语句，那么可以省略包含主体的大括号；另外，在Lambda表达式主体中允许有返回值，当只有一条return语句时，也可以省略return关键字。  
  了解了Lambda表达式的语法后，接下来编写一个示例文件对Lambda表达式的基本使用进行介绍，具体代码如下所示。
```js
 1	// 定义动物类接口
 2	interface Animal { 
 3		void shout(); // 定义方法shout()
 4	}
 5	public class Example22 {
 6		public static void main(String[] args) {
 7	       String name = "小花"; 
 8	       // 1、匿名内部类作为参数传递给animalShout()方法
 9		  animalShout(new Animal() { 
 10				 public void shout() { 
 11				    System.out.println("匿名内部类输出："+name+"喵喵...");
 12				}
 13		  });
 14		  // 2、使用Lambda表达式作为参数传递给animalShout()方法
 15	       animalShout(()-> System.out.println("Lambda表达式输出："
 16	                                                   +name+"喵喵..."));
 17		}
 18	    // 创建一个animalShout()静态方法，接收接口类型的参数
 19		public static void animalShout(Animal an) {
 20			an.shout();  
 21		}
 22	}
```  
  运行结果下图所示。
![alt](/article_img/lambda/1.jpg)
  上述代码示例中，先定义了只有一个抽象方法的接口Animal，然后分别使用匿名内部类和Lambda表达式的方式实现了接口方法。从图中可以看出，使用匿名内部类和Lambda表达式都能实现接口中方法，但很显然使用Lambda表达式更加简洁和清晰。, 2018-11-27, null, 默认分类, 2018,Lambda表达式, true, null, 18, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [7, 函数式接口, &emsp;&emsp;虽然Lambda表达式可以实现匿名内部类的功能，但在使用时却有一个局限，即接口中有且只有一个抽象方法时才能使用Lamdba表达式代替匿名内部类。这是因为Lamdba表达式是基于函数式接口实现的，所谓函数式接口是指有且仅有一个抽象方法的接口，Lambda表达式就是Java中函数式编程的体现，只有确保接口中有且仅有一个抽象方法，Lambda表达式才能顺利地推导出所实现的这个接口中的方法。  
&emsp;&emsp;在JDK 8中，专门为函数式接口引入了一个@FunctionalInterface注解，该注解只是显示的标注了接口是一个函数式接口，并强制编辑器进行更严格的检查，确保该接口是函数式接口，如果不是函数式接口，那么编译器就会报错，而对程序运行并没有实质上的影响。  
&emsp;&emsp;接下来通过一个案例来演示函数式接口的定义与使用，示例代码如下所示。
```js
 1	// 定义无参、无返回值的函数式接口
 2	@FunctionalInterface
 3	interface Animal {
 4		void shout();
 5	}
 6	// 定义有参、有返回值的函数式接口
 7	interface Calculate {
 8		int sum(int a, int b);
 9	}
 10	public class Example23 {
 11		public static void main(String[] args) {
 12		   // 分别两个函数式接口进行测试
 13		   animalShout(() -> System.out.println("无参、无返回值的函数式接口调用"));
 14		   showSum(10, 20, (x, y) -> x + y);
 15		}
 16		// 创建一个动物叫的方法，并传入接口对象Animal作为参数
 17		private static void animalShout(Animal animal) {
 18			animal.shout();
 19		}
 20		// 创建一个求和的方法，并传入两个int类型以及接口Calculate类型的参数
 21		private static void showSum(int x, int y, Calculate calculate) {
 22		   System.out.println(x + "+" + y + "的和为：" + calculate.sum(x, y));
 23		}
 24	}
```  
&emsp;&emsp;运行结果如下图所示。

![alt](/article_img/lambda/2.jpg)
&emsp;&emsp;上述代码示例中，先定义了两个函数式接口Animal和Calculate，然后在测试类中分别编写了两个静态方法，并将这两个函数式接口以参数的形式传入，最后在main()方法中分别调用这两个静态方法，并将所需要的函数式接口参数以Lambda表达式的形式传入。从图中可以看出，程序中函数式接口的定义和使用完全正确。
, 2018-12-01, null, 默认分类, 接口,函数式接口, true, null, 12, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} connected
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} created. update t_statistic set hits = hits+1 where article_id=?;
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} Parameters : [16]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} executed. 6.7622 millis. update t_statistic set hits = hits+1 where article_id=?;
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20000} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} created. select * from t_comment where article_id=?
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} Parameters : [16]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} executed. 6.3923 millis. select * from t_comment where article_id=?
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50000} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50000} Header: [id, article_id, created, ip, c_content, status, author]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50000} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20001} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail
    FROM
    t_article
    WHERE
	t_article.id = ?
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} Parameters : [16]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} Types : [INTEGER]
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} executed. 3.0364 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail
    FROM
    t_article
    WHERE
	t_article.id = ?
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50001} open
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50001} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail]
[DEBUG][21-05-22][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50001} closed
[DEBUG][21-05-22][druid.sql.Statement]{conn-10001, pstmt-20002} closed
[DEBUG][21-05-22][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} connected
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20000} created. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20000} Parameters : []
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20000} Types : []
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20000} executed. 21.9701 millis. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} open
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Header: [count(0)]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [12]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} closed
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20000} closed
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20001} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20001} Parameters : [5]
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20001} Types : [INTEGER]
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20001} executed. 3.8798 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} open
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} closed
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20001} closed
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20002} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20002} Parameters : []
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20002} Types : []
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20002} executed. 2.2377 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} open
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [12, Spring Boot 2 权威发布,   如果这两天登录 [https://start.spring.io/ ](https://start.spring.io/ )就会发现，Spring Boot 默认版本已经升到了 2.1.0。这是因为 Spring Boot 刚刚发布了 2.1.0 版本，我们来看下 Spring Boot 2 发布以来第一个子版本都发布了哪些内容？  

**2.1 中的新特性**     
  ●将spring-boot-starter-oauth2-oidc-client重命名为spring-boot-starter-oauth2-client命名更简洁  
  ●添加 OAuth2 资源服务 starter，OAuth2 一个用于认证的组件  
  ●支持 ConditionalOnBean 和 ConditionalOnMissingBean 下的参数化容器  
  ●自动配置 applicationTaskExecutor bean 的延迟加载来避免不必要的日志记录  
  ●将 DatabaseDriver＃SAP 重命名为 DatabaseDriver  
  ●跳过重启器不仅适用于 JUnit4，也适用于 JUnit5  
  ●在 Jest HealthIndicator 中使用集群端点  
  ●当 DevTools 禁用重启时添加日志输出  
  ●添加注解：@ConditionalOnMissingServletFilter提高 Servlet Filters 的自动装配。
  
**2.1 中的组件升级**  
  ●升级 Hibernate 5.3，Hibernate 的支持升级到了 5.3  
  ●升级 Tomcat 9 ，支持最新的 tomcat 9  
  ●支持 Java 11，Java 现在更新越来越快，Spring 快赶不上了    
  ●升级 Thymeleaf Extras Springsecurity 到 3.0.4.RELEASE ，thymeleaf-extras-springsecurity 是 Thymeleaf 提供集成 Spring Security 的组件  
  ●升级 Joda Time 2.10.1，Joda-Time， 面向 Java 应用程序的日期/时间库的替代选择，Joda-Time 令时间和日期值变得易于管理、操作和理解。  
  ●升级 Lettuce 5.1.2.RELEASE ，Lettuce 前面说过，传说中 Redis 最快的客户端。  
  ●升级 Reactor Californium-SR2 ，Californium 是物联网云服务的 Java COAP 实现。因此，它更专注的是可扩展性和可用性而不是像嵌入式设备那样关注资源效率。不过，Californium 也适合嵌入式的 JVM。  
  ●升级 Maven Failsafe Plugin 2.22.1 ，Maven 中的测试插件。  
  ●升级 Flyway 5.2.1 ， Flyway是一款开源的数据库版本管理工具  
  ●升级 Aspectj 1.9.2 ，AspectJ 是 Java 中流行的 AOP（Aspect-oriented Programming）编程扩展框架，是 Eclipse 托管给 Apache 基金会的一个开源项目。  
  ●升级 Mysql 8.0.13 ，Mysql 支持到 8。  
  ●...  
  更多的详细内容可以参考这里：[Spring Boot 2.1 Release Notes](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.1-Release-Notes)
, 2018-12-12, 2021-05-22, 默认分类, Spring Boot 2, true, null, 62, 1]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [8, JDK 8——聚合操作, &emsp;&emsp;在Java8版本中，JDK包含许多聚合操作（如平均值，总和，最小，最大，和计数），返回一个计算流stream的聚合结果。这些聚合操作被称为聚合操作。JDK除返回单个值的聚合操作外，还有很多聚合操作返回一个collection集合实例。很多的reduce操作执行特定的任务，如求平均值或按类别分组元素。  

**1. 聚合操作简介**

  在开发中，多数情况下会涉及到对集合、数组中元素的操作，在JDK 8之前都是通过普通的循环遍历出每一个元素，然后还会穿插一些if条件语句选择性的对元素进行查找、过滤、修改等操作，这种原始的操作方法虽然可行，但是代码量较大并且执行效率较低。  
  为此，JDK 8中新增了一个Stream接口，该接口可以将集合、数组的中的元素转换为Stream流的形式，并结合Lambda表达式的优势来进一步简化集合、数组中元素的查找、过滤、转换等操作，这一新功能就是JDK 8中的聚合操作。  
  在程序中，使用聚合操作没有绝对的语法规范，根据实际操作流程，主要可以分为以下3个步骤：  
  （1）将原始集合或者数组对象转换为Stream流对象；  
  （2）对Stream流对象中的元素进行一系列的过滤、查找等中间操作（Intermediate Operations），然后仍然返回一个Stream流对象；  
  （3）对Stream流进行遍历、统计、收集等终结操作（Terminal Operation），获取想要的结果。  
  接下来，就根据上面聚合操作的3个步骤，通过一个案例来演示聚合操作的基本用法，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example31 {
 4		public static void main(String[] args) {
 5	          // 创建一个List集合对象
 6			List<String> list = new ArrayList<>(); 
 7			list.add("张三");
 8			list.add("李四");
 9			list.add("张小明");
 10			list.add("张阳");
 11			// 1、创建一个Stream流对象
 12			Stream<String> stream = list.stream();
 13			// 2、对Stream流中的元素分别进行过滤、截取操作
 14		       Stream<String> stream2 = stream.filter(i -> i.startsWith("张"));
 15			Stream<String> stream3 = stream2.limit(2);
 16			// 3、对Stream流中的元素进行终结操作，进行遍历输出
 17			stream3.forEach(j -> System.out.println(j));
 18			System.out.println("=======");
 19	         // 通过链式表达式的形式完成聚合操作
 20			list.stream().filter(i -> i.startsWith("张"))
 21						 .limit(2)
 22						 .forEach(j -> System.out.println(j));
 23		}
 24	}
``` 
   运行结果如下图所示。
![alt](/article_img/lambda/3.jpg)
  上述示例代码中，先创建了一个List集合，然后根据聚合操作的3个步骤实现了集合对象的聚合操作，对集合中的元素使用Stream流的形式进行过滤（filter）、截取（limit），并进行遍历输出。其中第12~17行代码分步骤详细展示了聚合操作，而第20~22行代码是使用了链式表达式（调用有返回值的方法时不获取返回值而是直接再调用另一个方法）实现了聚合操作，该表达式的语法格式更简洁、高效，这种链式调用也被称为操作管道流。

**2. 创建Stream流对象**  
  在上一小节中，介绍了聚合操作的主要使用步骤，其中首要解决的问题就是创建Stream流对象。聚合操作针对的就是可迭代数据进行的操作，如集合、数组等，所以创建Stream流对象其实就是将集合、数组等通过一些方法转换为Stream流对象。  
  在Java中，集合对象有对应的集合类，可以通过集合类提供的静态方法创建Stream流对象，而数组数据却没有对应的数组类，所以必须通过其他方法创建Stream流对象。针对不同的源数据，Java提供了多种创建Stream流对象的方式，分别如下：  
  （1）所有的Collections集合都可以使用stream()静态方法获取Stream流对象；  
  （2）Stream接口的of()静态方法可以获取基本类型包装类数组、引用类型数组和单个元素的Stream流对象；  
  （3）Arrays数组工具类的stream()静态方法也可以获取数组元素的Stream流对象。  
  接下来，通过一个案例来学习聚合操作中如何创建Stream流对象，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example32 {
 4		public static void main(String[] args) {
 5	          // 创建一个数组
 6			Integer[] array = { 9, 8, 3, 5, 2 };       
 7	          // 将数组转换为List集合
 8			List<Integer> list = Arrays.asList(array); 
 9			// 1、使用集合对象的stream()静态方法创建Stream流对象
 10			Stream<Integer> stream = list.stream();
 11			stream.forEach(i -> System.out.print(i+" "));
 12			System.out.println();
 13			// 2、使用Stream接口的of()静态方法创建Stream流对象
 14			Stream<Integer> stream2 = Stream.of(array);
 15			stream2.forEach(i -> System.out.print(i+" "));
 16			System.out.println();
 17			// 3、使用Arrays数组工具类的stream()静态方法创建Stream流对象
 18			Stream<Integer> stream3 = Arrays.stream(array);
 19			stream3.forEach(i -> System.out.print(i+" "));
 20		}
 21	}
```  
  运行结果如下图所示。
![alt](/article_img/lambda/4.jpg)
  上述示例代码中，先创建了一个数组和一个集合，然后通过三种方式实现了Stream流对象的创建，并通过Stream流对象的forEach()方法结合Lambda表达式完成了集合和数组中元素的遍历。  

**小提示：**  
  在JDK 8中，只针对单列集合Collections接口对象提供了stream()静态方法获取Stream流对象，并未对Map集合提供相关方法获取Stream流对象，所以想要用Map集合创建Stream流对象必须先通过Map集合的keySet()、values()、entrySet()等方法将Map集合转换为单列Set集合，然后再使用单列集合的stream()静态方法获取对应键、值集合的Stream流对象。

, 2018-12-02, null, 默认分类, JDK 8,聚合操作, true, null, 36, 1]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [9, 虚拟化容器技术——Docker运行机制介绍,   Docker是一个开源的应用容器引擎，它基于go语言开发，并遵从Apache2.0开源协议。使用Docker可以让开发者封装他们的应用以及依赖包到一个可移植的容器中，然后发布到任意的Linux机器上，也可以实现虚拟化。Docker容器完全使用沙箱机制，相互之间不会有任何接口，这保证了容器之间的安全性。  

**1. Docker的引擎介绍**

  Docker Engine（Docker引擎）是Docker的核心部分，使用的是客户端-服务器（C/S）架构模式，其主要组成部分如下图所示。
![alt](/article_img/docker/1.png)
  从上图可以看出，Docker Engine中包含了三个核心组件（docker CLI、REST API和docker daemon），这三个组件的具体说明如下：  
  ①docker CLI（command line interface）：表示Docker命令行接口，开发者可以在命令行中使用Docker相关指令与Docker守护进程进行交互，从而管理诸如image（镜像）、container（容器）、network（网络）和data volumes（数据卷）等实体。  
  ②REST API：表示应用程序API接口，开发者通过该API接口可以与Docker的守护进程进行交互，从而指示后台进行相关操作。  
  ③docker daemon：表示Docker的服务端组件，他是Docker架构中运行在后台的一个守护进程，可以接收并处理来自命令行接口及API接口的指令，然后进行相应的后台操作。  
  对于开发者而言，既可以使用编写好的脚本文件通过REST API来实现与Docker进程交互，又可以直接使用Docker相关指令通过命令行接口来与Docker进程交互，而其他一些Docker应用则是通过底层的API和CLI进行交互的。

**2. Docker的架构介绍**

  了解了Docker内部引擎及作用后，我们还需要通过Docker的具体架构，来了解Docker的整个运行流程。接下来借助Docker官网的架构图来对Docker架构进行详细说明，如下图所示。
![alt](/article_img/docker/2.jpg)
  从图中可以看出，Docker架构主要包括Client、DOCKER_HOST和Register三部分，关于这三部分的具体说明如下。  
&emsp;&emsp;**（1）Client（客户端）**  
  Client即Docker客户端，也就是上一小节Docker Engine中介绍的docker CLI。开发者通过这个客户端使用Docker的相关指令与Docker守护进程进行交互，从而进行Docker镜像的创建、拉取和运行等操作。  
&emsp;&emsp;**（2）DOCKER_HOST（Docker主机）**  
  DOCKER_HOST即Docker内部引擎运行的主机，主要指Docker daemon（Docker守护进程）。可以通过Docker守护进程与客户端还有Docker的镜像仓库Registry进行交互，从而管理Images（镜像）和Containers（容器）等。  
&emsp;&emsp;**（3）Registry（注册中心）**  
  Registry即Docker注册中心，实质就是Docker镜像仓库，默认使用的是Docker官方远程注册中心Docker Hub，也可以使用开发者搭建的本地仓库。Registry中包含了大量的镜像，这些镜像可以是官网基础镜像，也可以是其他开发者上传的镜像。  
  我们在实际使用Docker时，除了会涉及到图中的三个主要部分外，还会涉及到很多Docker Objects（Docker对象），例如Images（镜像）、Containers（容器）、Networks（网络）、Volumes（数据卷）、Plugins（插件）等。其中常用的两个对象Image和Containers的说明如下。  
  ①Images（镜像）  
  Docker 镜像就是一个只读的模板，包含了一些创建Docker容器的操作指令。通常情况下，一个Docker镜像是基于另一个基础镜像创建的，并且新创建的镜像会额外包含一些功能配置。例如：开发者可以依赖于一个Ubuntu的基础镜像创建一个新镜像，并可以在新镜像中安装Apache等软件或其它应用程序。  
  ②Containers（容器）  
  Docker容器属于镜像的一个可运行实例（镜像与容器的关系其实与Java中的类与对象相似），开发者可以通过API接口或者CLI命令行接口来创建、运行、停止、移动、删除一个容器，也可以将一个容器连接到一个或多个网络中，将数据存储与容器进行关联。



, 2018-12-03, null, 默认分类, 虚拟化容器,Docker,运行机制, true, null, 26, 1]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [10, Docker常用客户端指令介绍,   在使用Docker之前，首先会为对应的项目编写Dockerfile镜像构建文件，然后通过Docker的相关指令进行镜像构建，完成镜像的构建后，就可以使用这些项目镜像进行启动测试了。所以要想知道如何使用Docker来执行这些Dockerfile镜像构建文件，还需要学习Docker客户端的常用指令，本篇文章将对Docker客户端的常用指令进行详细讲解。  

**1.列出镜像**  
  通过docker images指令可以查看本地镜像列表中已有的镜像，具体使用方式如下。
```js
$ docker images
```  
  执行上述指令后，系统会将所有本地镜像都展示出来，如下图所示。
![alt](/article_img/docker/3.png)
  从图中可以看出，系统终端将本地镜像列表中的3个镜像分5列进行了展示，每一列的具体含义如下。  
  ●REPOSITORY：镜像名称。  
  ●TAG：镜像的参数，类似于版本号，默认是latest。  
  ●IMAGE ID：镜像ID，是唯一值。此处看到的是一个长度为12的字符串，实际上它是64位完整镜像ID的缩写形式。  
  ●CREATED：距今创建镜像的时间。  
  ●SIZE：镜像大小。    

**2.搜索镜像**  
  想知道在Docker Hub中包含了哪些镜像，除了可以登录Docker Hub，在官网中心进行查看外，还可以直接在Docker客户端进行查询。例如想要查询Ubuntu镜像，可以使用如下指令。
```js
$ docker search ubuntu
```  
  执行上述指令后，系统终端就会将搜索到的有关Ubuntu的镜像展示出来，如下图所示。
![alt](/article_img/docker/4.png)
  从图所示的结果可以看出，系统终端分5列将搜索到的Ubuntu相关镜像都列举出来了，这5列的具体含义如下。  
  ●NAME：表示镜像的名称，这里有两种格式的名称，其中不带有“/”的表示官方镜像，而带有“/”的表示其他用户的公开镜像。公开镜像“/”前面是用户在Docker Hub上的用户名（唯一），后面是对应的镜像名；官方镜像与用户镜像，除了从镜像名称上可以区分外，还可以通过第4列的OFFICIAL声明中看出（该列下内容为OK表示官方镜像）。  
  ●DESCRIPTION：表示镜像的描述，这里只显示了一小部分。  
  ●STARS：表示该镜像的收藏数，用户可以在Docker Hub上对镜像进行收藏，一般可以通过该数字反应出该镜像的受欢迎程度。  
  ●OFFICIAL：表示是否为官方镜像。  
  ●AUTOMATED：表示是否自动构建镜像。例如，用户可以将自己的Docker Hub绑定到如Github上，当代码提交更新后，可以自动构建镜像。   
 
**3.拉取镜像**  
  通过docker pull指令可以拉取仓库镜像到本地（默认都是拉取Docker Hub仓库镜像，也可以指定“IP+端口”拉取某个Docker机器上的私有仓库镜像），具体使用方式如下。
```js
$ docker pull ubuntu
```  
  执行上述指令后，Docker会自动从Docker Hub上下载最新版本的Ubuntu到本地，当然也可以使用以下指令拉取指定版本的镜像到本地，具体指令如下。
```js
$ docker pull ubuntu:14.04
```  
**4.构建镜像**  
  除了可以通过docker pull指令从仓库拉取镜像外，还可以通过docker build指令构建Docker镜像，通常情况下都是通过Dockerfile文件来构建镜像的。  
  这里假设linux系统home目录下/shitou/workspace/dockerspace文件夹中编写有对应的Dockerfile文件，则构建镜像直立示例如下所示。 
```js
$ docker build -t hellodocker3 /home/shitou/workspace/dockerspace/.
```
**5.删除镜像**  
  当本地存放过多不需要的镜像时，可以通过docker rmi指令将其删除。在删除镜像时，需要指定镜像名称或镜像ID。删除镜像的使用方式如下。
```js
$ docker rmi -f hellodocker2 hellodocker3
```  
  上述指令中，docker rmi表示删除镜像，-f表示进行强制删除，而hellodocker2和hellodocker3分别表示需要删除的镜像名称，这里同时删除两个镜像。除了根据名称删除镜像外，还也可以根据镜像ID来删除镜像，只是这里如果指定了删除ID为23c617a866d4的镜像后，会同时删除hellodocker、hellodocker2和hellodocker3三个镜像。  
  需要特别强调的是，在进行镜像删除操作时，如果是通过镜像ID进行镜像删除，那么由该镜像创建的容器必须提前删除或停止。另外，在通过镜像名称操作镜像时，如果出现镜像重名的情况，必须在镜像名称后面指定镜像标签tag参数来确保唯一性。

**6.创建并启动容器**  
  Docker镜像主要用于创建容器，可以使用docker run指令创建并启动容器，具体使用方式如下。
```js
$ docker run -d -p 5000:80 --name test hellodocker
```  
  上述创建并启动容器的指令略微复杂，具体分析如下。  
  ●docker run：表示创建并启动一个容器，而后面的hellodocker就表示要启动运行的镜像名称；  
  ●-d：表示容器启动时在后台运行；  
  ●-p 5000:80：表示将容器内暴露的80端口映射到宿主机指定的5000端口，也可以将-p 5000:80更改为-P来映射主机的随机端口（注意p字母的大小写）；  
  ●--name test：表示为创建后的容器指定名称为test，如果没有该参数配置，则生成的容器会设置一个随机名称。  
  docker run命令是Docker操作中较为复杂的一个，它可以携带多个参数和参数，我们可以通过docker run --help指令进行查看，其中有些参数如-e、-v和-w等都可以在Dockerfile文件中预先声明。 
 
**7.列出容器**  
  生成容器后，可以通过docker ps指令查看当前运行的所有容器，具体使用方式如下。
```js
$ docker ps
```  
  执行上述命令后，会将所有当前运行的容器都展示出来，具体如下图所示。
![alt](/article_img/docker/5.png)
  从图中可以看出，系统终端通过7列对当前的正在运行的一个容器进行了展示，图中每一列的具体含义如下。  
  ●CONTAINER ID：表示生成的容器ID；  
  ●IMAGE：表示生成该容器的镜像名称；  
  ●COMMAND：表示启动容器时运行的命令，Docker要求在启动容器时必须运行一个命令；  
  ●CREATED：表示容器创建的时间；  
  ●STATUS：表示容器运行状态，例如Up表示运行中，Exited表示已停止；  
  ●PORTS：表示容器内部暴露的端口映射到主机的端口；  
  ●NAMES：表示生成容器的名称，由Docker引擎自动生成，可以像上述示例中使用--name参数指定生成容器的名称。  
  另外，docker ps指令运行过程中可以指定多个参数，还可以通过docker ps --help指令对ps指令的其他信息进行查看。

**8.删除容器**  
  当不需要使用容器时，则可以使用docker rm指令删除已停止的容器，具体使用方式如下。
```js
$ docker rm f0c9a8b6e8c5
```  
  需要注意的是，上述指令只能删除已经停止运行的容器，而不能删除正在运行的容器。如果想要删除正在运行的容器，则需要添加-f参数强制删除，具体使用方式如下。
```js
$ docker rm -f f0c9a8b6e8c5
```  
  当需要删除的容器过多时，如果还一个个的删除就略显麻烦了，此时可以通过如下指令将全部容器删除。
```js
$ docker rm -f $(docker ps -aq)
```  
  上述指令中，首先会通过$(docker ps -aq)获取所有容器的ID，然后通过docker rm -f指令进行强制删除。如果开发者有自己特殊的删除需求，可以根据前面docker ps指令进行组装来获取需要删除的容器ID。  
  Docker提供的操作指令远不止这些，这里就不一一列举了，想要了解更多Docker的操作指令，可以通过docker --help指令进行查看。


, 2018-12-05, null, 默认分类, Docker,客户端指令, true, null, 21, 1]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [11, Docker数据管理介绍,   当我们对容器进行相关操作时，产生的一系列数据都会存储在容器中，而Docker内部又是如果管理这些数据的呢？本篇文章将针对Docker数据管理的一些知识进行介绍。
  
**1. Docker数据存储机制**  
  使用Docker时，我们操作的都是镜像和由镜像生成的容器，所以想要更好的了解Docker内部的数据存储机制，就必须从镜像、容器与数据存储的关系出发。  
  Docker镜像是通过读取Dockerfile文件中的指令构建的，Dockerfile中的每条指令都会创建一个镜像层，并且每层都是只读的，这一系列的镜像层就构成了Docker镜像。接下来以一个Dockerfile文件为例进行说明，具体如下列代码示例所示。
```js
 1	FROM ubuntu:16.04
 2	COPY . /app
 3	RUN make /app
 4	CMD python /app/app.py
```  
   上述文件示例中的Dockerfile包含了4条指令，每条指令都会创建一个镜像层，其中每一层与前一层都有所不同，并且是层层叠加的。通过镜像构建容器时，会在镜像层上增加一个容器层（即可写层），所有对容器的更改都会写入容器层，这也是Docker默认的数据存储方式。  
  下面通过一个效果图进行说明，具体如下图所示。
![alt](/article_img/docker/6.png)
  从图中可以看出，Docker容器和镜像之间的主要区别是顶部的容器层，而所有对容器中数据的添加、修改等操作都会被存储在容器层中。当容器被删除时，容器层也会被删除，其中存储的数据会被一同删除，而下面的镜像层却保持不变。  
  由于所有的容器都是通过镜像构建的，所以每个容器都有各自的容器层，对于容器数据的更改就会保存在各自的容器层中。也就是说，由同一个镜像构建的多个容器，它们会拥有相同的底部镜像层，而拥有不同的容器层，多个容器可以访问相同的镜像层，并且有自己的独立数据状态。具体说明如下图所示。 
![alt](/article_img/docker/7.png)
  从图中可以看出，基于同一个镜像构建的多个容器可以共享该镜像层，但是多个容器想要共享相同的数据，就需要将这些数据存储到容器之外的地方，而这种方式就是下一节要提到的Docker volume数据外部挂载机制。  

**2. Docker数据存储方式**    
  在默认情况下，Docker中的数据都是存放在容器层的，但是这样存储数据却有较多的缺陷，具体表现如下。    
  ●当容器不再运行时，容器中的数据无法持久化保存，如果另一个进程需要这些数据，那么将很难从容器中获取数据；  
  ●容器层与正在运行的主机紧密耦合，不能轻易地移动数据；  
  ●容器层需要一个存储驱动程序来管理文件系统，存储驱动程序提供了一个使用Linux内核的联合文件系统，这种额外的抽象化降低了性能。  
  基于上述种种原因，多数情况下Docker数据管理都不会直接将数据写入容器层，而是使用另一种叫做Docker volume数据外部挂载的机制进行数据管理。  
  针对Docker volume数据外部挂载机制，Docker提供了三种不同的方式将数据从容器映射到Docker宿主机，他们分别为：volumes（数据卷）、bind mounts（绑定挂载）和tmpfs mounts（tmpfs挂载）。这三种数据管理方式的具体选择，需要结合实际情况进行考虑，其中的volumes数据卷是最常用也是官方推荐的数据管理方式。无论选择使用哪种数据管理方式，数据在容器内看起来都一样的，而在容器外则会被被挂载到文件系统中的某个目录或文件中。    
  下面通过一张图来展示数据卷、绑定挂载和tmpfs挂载之间的差异，如下图所示。  
![alt](/article_img/docker/8.png)
  从图中可以看出，Docker提供的三种数据管理方式略有不同，具体分析如下。  
  ●volumes：存储在主机文件系统中（在Linux系统下是存在于/var/lib/Docker/volumes/目录），并由Docker管理，非Docker进程无法修改文件系统的这个部分。  
  ●bind mounts：可以存储在主机系统的任意位置，甚至可能是重要的系统文件或目录，在Docker主机或容器上的非Docker进程可以对他们进行任意修改。  
  ●tmpfs mounts：只存储在主机系统的内存中，并没有写入到主机的文件系统中。


, 2018-12-07, 2021-05-19, 默认分类, Docker,数据管理, true, null, 19, 1]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [6, JDK 8——Lambda表达式介绍,   Lambda表达式是JDK 8中一个重要的新特性，它使用一个清晰简洁的表达式来表达一个接口，同时Lambda表达式也简化了对集合以及数组数据的遍历、过滤和提取等操作。下面，本篇文章就对Lambda表达式进行简要介绍，并进行演示说明。

**1. Lambda表达式入门**  

  匿名内部类存在的一个问题是，如果匿名内部类的实现非常简单，例如只包含一个抽象方法的接口，那么匿名内部类的语法仍然显得比较冗余。为此，JDK 8中新增了一个特性Lambda表达式，这种表达式只针对有一个抽象方法的接口实现，以简洁的表达式形式实现接口功能来作为方法参数。  
  一个Lambda表达式由三个部分组成，分别为参数列表、“->”和表达式主体，其语法格式如下：
```js
 ([数据类型 参数名,数据类型 参数名,...]) -> {表达式主体}
```  
  从上述语法格式上看，Lambda表达式的书写非常简单，下面针对Lambda表达式的组成部分进行简单介绍，具体如下：  
  （1）([数据类型 参数名,数据类型 参数名,...])：用来向表达式主体传递接口方法需要的参数，多个参数名中间必须用英文逗号“,”进行分隔；在编写Lambda表达式时，可以省略参数的数据类型，后面的表达式主体会自动进行校对和匹配；同时，如果只有一个参数，则可以省略括号“()”。  
  （2）->：表示Lambda表达式箭牌，用来指定参数数据指向，不能省略，且必须用英文横线和大于号书写。  
  （3）{表达式主体}：由单个表达式或语句块组成的主体，本质就是接口中抽象方法的具体实现，如果表达式主体只有一条语句，那么可以省略包含主体的大括号；另外，在Lambda表达式主体中允许有返回值，当只有一条return语句时，也可以省略return关键字。  
  了解了Lambda表达式的语法后，接下来编写一个示例文件对Lambda表达式的基本使用进行介绍，具体代码如下所示。
```js
 1	// 定义动物类接口
 2	interface Animal { 
 3		void shout(); // 定义方法shout()
 4	}
 5	public class Example22 {
 6		public static void main(String[] args) {
 7	       String name = "小花"; 
 8	       // 1、匿名内部类作为参数传递给animalShout()方法
 9		  animalShout(new Animal() { 
 10				 public void shout() { 
 11				    System.out.println("匿名内部类输出："+name+"喵喵...");
 12				}
 13		  });
 14		  // 2、使用Lambda表达式作为参数传递给animalShout()方法
 15	       animalShout(()-> System.out.println("Lambda表达式输出："
 16	                                                   +name+"喵喵..."));
 17		}
 18	    // 创建一个animalShout()静态方法，接收接口类型的参数
 19		public static void animalShout(Animal an) {
 20			an.shout();  
 21		}
 22	}
```  
  运行结果下图所示。
![alt](/article_img/lambda/1.jpg)
  上述代码示例中，先定义了只有一个抽象方法的接口Animal，然后分别使用匿名内部类和Lambda表达式的方式实现了接口方法。从图中可以看出，使用匿名内部类和Lambda表达式都能实现接口中方法，但很显然使用Lambda表达式更加简洁和清晰。, 2018-11-27, null, 默认分类, 2018,Lambda表达式, true, null, 18, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [7, 函数式接口, &emsp;&emsp;虽然Lambda表达式可以实现匿名内部类的功能，但在使用时却有一个局限，即接口中有且只有一个抽象方法时才能使用Lamdba表达式代替匿名内部类。这是因为Lamdba表达式是基于函数式接口实现的，所谓函数式接口是指有且仅有一个抽象方法的接口，Lambda表达式就是Java中函数式编程的体现，只有确保接口中有且仅有一个抽象方法，Lambda表达式才能顺利地推导出所实现的这个接口中的方法。  
&emsp;&emsp;在JDK 8中，专门为函数式接口引入了一个@FunctionalInterface注解，该注解只是显示的标注了接口是一个函数式接口，并强制编辑器进行更严格的检查，确保该接口是函数式接口，如果不是函数式接口，那么编译器就会报错，而对程序运行并没有实质上的影响。  
&emsp;&emsp;接下来通过一个案例来演示函数式接口的定义与使用，示例代码如下所示。
```js
 1	// 定义无参、无返回值的函数式接口
 2	@FunctionalInterface
 3	interface Animal {
 4		void shout();
 5	}
 6	// 定义有参、有返回值的函数式接口
 7	interface Calculate {
 8		int sum(int a, int b);
 9	}
 10	public class Example23 {
 11		public static void main(String[] args) {
 12		   // 分别两个函数式接口进行测试
 13		   animalShout(() -> System.out.println("无参、无返回值的函数式接口调用"));
 14		   showSum(10, 20, (x, y) -> x + y);
 15		}
 16		// 创建一个动物叫的方法，并传入接口对象Animal作为参数
 17		private static void animalShout(Animal animal) {
 18			animal.shout();
 19		}
 20		// 创建一个求和的方法，并传入两个int类型以及接口Calculate类型的参数
 21		private static void showSum(int x, int y, Calculate calculate) {
 22		   System.out.println(x + "+" + y + "的和为：" + calculate.sum(x, y));
 23		}
 24	}
```  
&emsp;&emsp;运行结果如下图所示。

![alt](/article_img/lambda/2.jpg)
&emsp;&emsp;上述代码示例中，先定义了两个函数式接口Animal和Calculate，然后在测试类中分别编写了两个静态方法，并将这两个函数式接口以参数的形式传入，最后在main()方法中分别调用这两个静态方法，并将所需要的函数式接口参数以Lambda表达式的形式传入。从图中可以看出，程序中函数式接口的定义和使用完全正确。
, 2018-12-01, null, 默认分类, 接口,函数式接口, true, null, 12, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} closed
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20002} closed
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20003} created. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20003} Parameters : []
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20003} Types : []
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20003} executed. 4.0056 millis. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20003, rs-50003} open
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20003, rs-50003} Header: [count(0)]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20003, rs-50003} Result: [12]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20003, rs-50003} closed
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20003} closed
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20004} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20004} Parameters : [5]
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20004} Types : [INTEGER]
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20004} executed. 0.9334 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} open
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} closed
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20004} closed
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} connected
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20000} created. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20000} Parameters : []
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20000} Types : []
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20000} executed. 25.3612 millis. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} open
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Header: [count(0)]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [12]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} closed
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20000} closed
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20001} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20001} Parameters : [5]
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20001} Types : [INTEGER]
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20001} executed. 1.8095 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} open
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} closed
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20001} closed
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20002} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20002} Parameters : []
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20002} Types : []
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20002} executed. 2.4451 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} open
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [12, Spring Boot 2 权威发布,   如果这两天登录 [https://start.spring.io/ ](https://start.spring.io/ )就会发现，Spring Boot 默认版本已经升到了 2.1.0。这是因为 Spring Boot 刚刚发布了 2.1.0 版本，我们来看下 Spring Boot 2 发布以来第一个子版本都发布了哪些内容？  

**2.1 中的新特性**     
  ●将spring-boot-starter-oauth2-oidc-client重命名为spring-boot-starter-oauth2-client命名更简洁  
  ●添加 OAuth2 资源服务 starter，OAuth2 一个用于认证的组件  
  ●支持 ConditionalOnBean 和 ConditionalOnMissingBean 下的参数化容器  
  ●自动配置 applicationTaskExecutor bean 的延迟加载来避免不必要的日志记录  
  ●将 DatabaseDriver＃SAP 重命名为 DatabaseDriver  
  ●跳过重启器不仅适用于 JUnit4，也适用于 JUnit5  
  ●在 Jest HealthIndicator 中使用集群端点  
  ●当 DevTools 禁用重启时添加日志输出  
  ●添加注解：@ConditionalOnMissingServletFilter提高 Servlet Filters 的自动装配。
  
**2.1 中的组件升级**  
  ●升级 Hibernate 5.3，Hibernate 的支持升级到了 5.3  
  ●升级 Tomcat 9 ，支持最新的 tomcat 9  
  ●支持 Java 11，Java 现在更新越来越快，Spring 快赶不上了    
  ●升级 Thymeleaf Extras Springsecurity 到 3.0.4.RELEASE ，thymeleaf-extras-springsecurity 是 Thymeleaf 提供集成 Spring Security 的组件  
  ●升级 Joda Time 2.10.1，Joda-Time， 面向 Java 应用程序的日期/时间库的替代选择，Joda-Time 令时间和日期值变得易于管理、操作和理解。  
  ●升级 Lettuce 5.1.2.RELEASE ，Lettuce 前面说过，传说中 Redis 最快的客户端。  
  ●升级 Reactor Californium-SR2 ，Californium 是物联网云服务的 Java COAP 实现。因此，它更专注的是可扩展性和可用性而不是像嵌入式设备那样关注资源效率。不过，Californium 也适合嵌入式的 JVM。  
  ●升级 Maven Failsafe Plugin 2.22.1 ，Maven 中的测试插件。  
  ●升级 Flyway 5.2.1 ， Flyway是一款开源的数据库版本管理工具  
  ●升级 Aspectj 1.9.2 ，AspectJ 是 Java 中流行的 AOP（Aspect-oriented Programming）编程扩展框架，是 Eclipse 托管给 Apache 基金会的一个开源项目。  
  ●升级 Mysql 8.0.13 ，Mysql 支持到 8。  
  ●...  
  更多的详细内容可以参考这里：[Spring Boot 2.1 Release Notes](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.1-Release-Notes)
, 2018-12-12, 2021-05-22, 默认分类, Spring Boot 2, true, null, 62, 1]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [8, JDK 8——聚合操作, &emsp;&emsp;在Java8版本中，JDK包含许多聚合操作（如平均值，总和，最小，最大，和计数），返回一个计算流stream的聚合结果。这些聚合操作被称为聚合操作。JDK除返回单个值的聚合操作外，还有很多聚合操作返回一个collection集合实例。很多的reduce操作执行特定的任务，如求平均值或按类别分组元素。  

**1. 聚合操作简介**

  在开发中，多数情况下会涉及到对集合、数组中元素的操作，在JDK 8之前都是通过普通的循环遍历出每一个元素，然后还会穿插一些if条件语句选择性的对元素进行查找、过滤、修改等操作，这种原始的操作方法虽然可行，但是代码量较大并且执行效率较低。  
  为此，JDK 8中新增了一个Stream接口，该接口可以将集合、数组的中的元素转换为Stream流的形式，并结合Lambda表达式的优势来进一步简化集合、数组中元素的查找、过滤、转换等操作，这一新功能就是JDK 8中的聚合操作。  
  在程序中，使用聚合操作没有绝对的语法规范，根据实际操作流程，主要可以分为以下3个步骤：  
  （1）将原始集合或者数组对象转换为Stream流对象；  
  （2）对Stream流对象中的元素进行一系列的过滤、查找等中间操作（Intermediate Operations），然后仍然返回一个Stream流对象；  
  （3）对Stream流进行遍历、统计、收集等终结操作（Terminal Operation），获取想要的结果。  
  接下来，就根据上面聚合操作的3个步骤，通过一个案例来演示聚合操作的基本用法，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example31 {
 4		public static void main(String[] args) {
 5	          // 创建一个List集合对象
 6			List<String> list = new ArrayList<>(); 
 7			list.add("张三");
 8			list.add("李四");
 9			list.add("张小明");
 10			list.add("张阳");
 11			// 1、创建一个Stream流对象
 12			Stream<String> stream = list.stream();
 13			// 2、对Stream流中的元素分别进行过滤、截取操作
 14		       Stream<String> stream2 = stream.filter(i -> i.startsWith("张"));
 15			Stream<String> stream3 = stream2.limit(2);
 16			// 3、对Stream流中的元素进行终结操作，进行遍历输出
 17			stream3.forEach(j -> System.out.println(j));
 18			System.out.println("=======");
 19	         // 通过链式表达式的形式完成聚合操作
 20			list.stream().filter(i -> i.startsWith("张"))
 21						 .limit(2)
 22						 .forEach(j -> System.out.println(j));
 23		}
 24	}
``` 
   运行结果如下图所示。
![alt](/article_img/lambda/3.jpg)
  上述示例代码中，先创建了一个List集合，然后根据聚合操作的3个步骤实现了集合对象的聚合操作，对集合中的元素使用Stream流的形式进行过滤（filter）、截取（limit），并进行遍历输出。其中第12~17行代码分步骤详细展示了聚合操作，而第20~22行代码是使用了链式表达式（调用有返回值的方法时不获取返回值而是直接再调用另一个方法）实现了聚合操作，该表达式的语法格式更简洁、高效，这种链式调用也被称为操作管道流。

**2. 创建Stream流对象**  
  在上一小节中，介绍了聚合操作的主要使用步骤，其中首要解决的问题就是创建Stream流对象。聚合操作针对的就是可迭代数据进行的操作，如集合、数组等，所以创建Stream流对象其实就是将集合、数组等通过一些方法转换为Stream流对象。  
  在Java中，集合对象有对应的集合类，可以通过集合类提供的静态方法创建Stream流对象，而数组数据却没有对应的数组类，所以必须通过其他方法创建Stream流对象。针对不同的源数据，Java提供了多种创建Stream流对象的方式，分别如下：  
  （1）所有的Collections集合都可以使用stream()静态方法获取Stream流对象；  
  （2）Stream接口的of()静态方法可以获取基本类型包装类数组、引用类型数组和单个元素的Stream流对象；  
  （3）Arrays数组工具类的stream()静态方法也可以获取数组元素的Stream流对象。  
  接下来，通过一个案例来学习聚合操作中如何创建Stream流对象，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example32 {
 4		public static void main(String[] args) {
 5	          // 创建一个数组
 6			Integer[] array = { 9, 8, 3, 5, 2 };       
 7	          // 将数组转换为List集合
 8			List<Integer> list = Arrays.asList(array); 
 9			// 1、使用集合对象的stream()静态方法创建Stream流对象
 10			Stream<Integer> stream = list.stream();
 11			stream.forEach(i -> System.out.print(i+" "));
 12			System.out.println();
 13			// 2、使用Stream接口的of()静态方法创建Stream流对象
 14			Stream<Integer> stream2 = Stream.of(array);
 15			stream2.forEach(i -> System.out.print(i+" "));
 16			System.out.println();
 17			// 3、使用Arrays数组工具类的stream()静态方法创建Stream流对象
 18			Stream<Integer> stream3 = Arrays.stream(array);
 19			stream3.forEach(i -> System.out.print(i+" "));
 20		}
 21	}
```  
  运行结果如下图所示。
![alt](/article_img/lambda/4.jpg)
  上述示例代码中，先创建了一个数组和一个集合，然后通过三种方式实现了Stream流对象的创建，并通过Stream流对象的forEach()方法结合Lambda表达式完成了集合和数组中元素的遍历。  

**小提示：**  
  在JDK 8中，只针对单列集合Collections接口对象提供了stream()静态方法获取Stream流对象，并未对Map集合提供相关方法获取Stream流对象，所以想要用Map集合创建Stream流对象必须先通过Map集合的keySet()、values()、entrySet()等方法将Map集合转换为单列Set集合，然后再使用单列集合的stream()静态方法获取对应键、值集合的Stream流对象。

, 2018-12-02, null, 默认分类, JDK 8,聚合操作, true, null, 36, 1]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [9, 虚拟化容器技术——Docker运行机制介绍,   Docker是一个开源的应用容器引擎，它基于go语言开发，并遵从Apache2.0开源协议。使用Docker可以让开发者封装他们的应用以及依赖包到一个可移植的容器中，然后发布到任意的Linux机器上，也可以实现虚拟化。Docker容器完全使用沙箱机制，相互之间不会有任何接口，这保证了容器之间的安全性。  

**1. Docker的引擎介绍**

  Docker Engine（Docker引擎）是Docker的核心部分，使用的是客户端-服务器（C/S）架构模式，其主要组成部分如下图所示。
![alt](/article_img/docker/1.png)
  从上图可以看出，Docker Engine中包含了三个核心组件（docker CLI、REST API和docker daemon），这三个组件的具体说明如下：  
  ①docker CLI（command line interface）：表示Docker命令行接口，开发者可以在命令行中使用Docker相关指令与Docker守护进程进行交互，从而管理诸如image（镜像）、container（容器）、network（网络）和data volumes（数据卷）等实体。  
  ②REST API：表示应用程序API接口，开发者通过该API接口可以与Docker的守护进程进行交互，从而指示后台进行相关操作。  
  ③docker daemon：表示Docker的服务端组件，他是Docker架构中运行在后台的一个守护进程，可以接收并处理来自命令行接口及API接口的指令，然后进行相应的后台操作。  
  对于开发者而言，既可以使用编写好的脚本文件通过REST API来实现与Docker进程交互，又可以直接使用Docker相关指令通过命令行接口来与Docker进程交互，而其他一些Docker应用则是通过底层的API和CLI进行交互的。

**2. Docker的架构介绍**

  了解了Docker内部引擎及作用后，我们还需要通过Docker的具体架构，来了解Docker的整个运行流程。接下来借助Docker官网的架构图来对Docker架构进行详细说明，如下图所示。
![alt](/article_img/docker/2.jpg)
  从图中可以看出，Docker架构主要包括Client、DOCKER_HOST和Register三部分，关于这三部分的具体说明如下。  
&emsp;&emsp;**（1）Client（客户端）**  
  Client即Docker客户端，也就是上一小节Docker Engine中介绍的docker CLI。开发者通过这个客户端使用Docker的相关指令与Docker守护进程进行交互，从而进行Docker镜像的创建、拉取和运行等操作。  
&emsp;&emsp;**（2）DOCKER_HOST（Docker主机）**  
  DOCKER_HOST即Docker内部引擎运行的主机，主要指Docker daemon（Docker守护进程）。可以通过Docker守护进程与客户端还有Docker的镜像仓库Registry进行交互，从而管理Images（镜像）和Containers（容器）等。  
&emsp;&emsp;**（3）Registry（注册中心）**  
  Registry即Docker注册中心，实质就是Docker镜像仓库，默认使用的是Docker官方远程注册中心Docker Hub，也可以使用开发者搭建的本地仓库。Registry中包含了大量的镜像，这些镜像可以是官网基础镜像，也可以是其他开发者上传的镜像。  
  我们在实际使用Docker时，除了会涉及到图中的三个主要部分外，还会涉及到很多Docker Objects（Docker对象），例如Images（镜像）、Containers（容器）、Networks（网络）、Volumes（数据卷）、Plugins（插件）等。其中常用的两个对象Image和Containers的说明如下。  
  ①Images（镜像）  
  Docker 镜像就是一个只读的模板，包含了一些创建Docker容器的操作指令。通常情况下，一个Docker镜像是基于另一个基础镜像创建的，并且新创建的镜像会额外包含一些功能配置。例如：开发者可以依赖于一个Ubuntu的基础镜像创建一个新镜像，并可以在新镜像中安装Apache等软件或其它应用程序。  
  ②Containers（容器）  
  Docker容器属于镜像的一个可运行实例（镜像与容器的关系其实与Java中的类与对象相似），开发者可以通过API接口或者CLI命令行接口来创建、运行、停止、移动、删除一个容器，也可以将一个容器连接到一个或多个网络中，将数据存储与容器进行关联。



, 2018-12-03, null, 默认分类, 虚拟化容器,Docker,运行机制, true, null, 26, 1]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [10, Docker常用客户端指令介绍,   在使用Docker之前，首先会为对应的项目编写Dockerfile镜像构建文件，然后通过Docker的相关指令进行镜像构建，完成镜像的构建后，就可以使用这些项目镜像进行启动测试了。所以要想知道如何使用Docker来执行这些Dockerfile镜像构建文件，还需要学习Docker客户端的常用指令，本篇文章将对Docker客户端的常用指令进行详细讲解。  

**1.列出镜像**  
  通过docker images指令可以查看本地镜像列表中已有的镜像，具体使用方式如下。
```js
$ docker images
```  
  执行上述指令后，系统会将所有本地镜像都展示出来，如下图所示。
![alt](/article_img/docker/3.png)
  从图中可以看出，系统终端将本地镜像列表中的3个镜像分5列进行了展示，每一列的具体含义如下。  
  ●REPOSITORY：镜像名称。  
  ●TAG：镜像的参数，类似于版本号，默认是latest。  
  ●IMAGE ID：镜像ID，是唯一值。此处看到的是一个长度为12的字符串，实际上它是64位完整镜像ID的缩写形式。  
  ●CREATED：距今创建镜像的时间。  
  ●SIZE：镜像大小。    

**2.搜索镜像**  
  想知道在Docker Hub中包含了哪些镜像，除了可以登录Docker Hub，在官网中心进行查看外，还可以直接在Docker客户端进行查询。例如想要查询Ubuntu镜像，可以使用如下指令。
```js
$ docker search ubuntu
```  
  执行上述指令后，系统终端就会将搜索到的有关Ubuntu的镜像展示出来，如下图所示。
![alt](/article_img/docker/4.png)
  从图所示的结果可以看出，系统终端分5列将搜索到的Ubuntu相关镜像都列举出来了，这5列的具体含义如下。  
  ●NAME：表示镜像的名称，这里有两种格式的名称，其中不带有“/”的表示官方镜像，而带有“/”的表示其他用户的公开镜像。公开镜像“/”前面是用户在Docker Hub上的用户名（唯一），后面是对应的镜像名；官方镜像与用户镜像，除了从镜像名称上可以区分外，还可以通过第4列的OFFICIAL声明中看出（该列下内容为OK表示官方镜像）。  
  ●DESCRIPTION：表示镜像的描述，这里只显示了一小部分。  
  ●STARS：表示该镜像的收藏数，用户可以在Docker Hub上对镜像进行收藏，一般可以通过该数字反应出该镜像的受欢迎程度。  
  ●OFFICIAL：表示是否为官方镜像。  
  ●AUTOMATED：表示是否自动构建镜像。例如，用户可以将自己的Docker Hub绑定到如Github上，当代码提交更新后，可以自动构建镜像。   
 
**3.拉取镜像**  
  通过docker pull指令可以拉取仓库镜像到本地（默认都是拉取Docker Hub仓库镜像，也可以指定“IP+端口”拉取某个Docker机器上的私有仓库镜像），具体使用方式如下。
```js
$ docker pull ubuntu
```  
  执行上述指令后，Docker会自动从Docker Hub上下载最新版本的Ubuntu到本地，当然也可以使用以下指令拉取指定版本的镜像到本地，具体指令如下。
```js
$ docker pull ubuntu:14.04
```  
**4.构建镜像**  
  除了可以通过docker pull指令从仓库拉取镜像外，还可以通过docker build指令构建Docker镜像，通常情况下都是通过Dockerfile文件来构建镜像的。  
  这里假设linux系统home目录下/shitou/workspace/dockerspace文件夹中编写有对应的Dockerfile文件，则构建镜像直立示例如下所示。 
```js
$ docker build -t hellodocker3 /home/shitou/workspace/dockerspace/.
```
**5.删除镜像**  
  当本地存放过多不需要的镜像时，可以通过docker rmi指令将其删除。在删除镜像时，需要指定镜像名称或镜像ID。删除镜像的使用方式如下。
```js
$ docker rmi -f hellodocker2 hellodocker3
```  
  上述指令中，docker rmi表示删除镜像，-f表示进行强制删除，而hellodocker2和hellodocker3分别表示需要删除的镜像名称，这里同时删除两个镜像。除了根据名称删除镜像外，还也可以根据镜像ID来删除镜像，只是这里如果指定了删除ID为23c617a866d4的镜像后，会同时删除hellodocker、hellodocker2和hellodocker3三个镜像。  
  需要特别强调的是，在进行镜像删除操作时，如果是通过镜像ID进行镜像删除，那么由该镜像创建的容器必须提前删除或停止。另外，在通过镜像名称操作镜像时，如果出现镜像重名的情况，必须在镜像名称后面指定镜像标签tag参数来确保唯一性。

**6.创建并启动容器**  
  Docker镜像主要用于创建容器，可以使用docker run指令创建并启动容器，具体使用方式如下。
```js
$ docker run -d -p 5000:80 --name test hellodocker
```  
  上述创建并启动容器的指令略微复杂，具体分析如下。  
  ●docker run：表示创建并启动一个容器，而后面的hellodocker就表示要启动运行的镜像名称；  
  ●-d：表示容器启动时在后台运行；  
  ●-p 5000:80：表示将容器内暴露的80端口映射到宿主机指定的5000端口，也可以将-p 5000:80更改为-P来映射主机的随机端口（注意p字母的大小写）；  
  ●--name test：表示为创建后的容器指定名称为test，如果没有该参数配置，则生成的容器会设置一个随机名称。  
  docker run命令是Docker操作中较为复杂的一个，它可以携带多个参数和参数，我们可以通过docker run --help指令进行查看，其中有些参数如-e、-v和-w等都可以在Dockerfile文件中预先声明。 
 
**7.列出容器**  
  生成容器后，可以通过docker ps指令查看当前运行的所有容器，具体使用方式如下。
```js
$ docker ps
```  
  执行上述命令后，会将所有当前运行的容器都展示出来，具体如下图所示。
![alt](/article_img/docker/5.png)
  从图中可以看出，系统终端通过7列对当前的正在运行的一个容器进行了展示，图中每一列的具体含义如下。  
  ●CONTAINER ID：表示生成的容器ID；  
  ●IMAGE：表示生成该容器的镜像名称；  
  ●COMMAND：表示启动容器时运行的命令，Docker要求在启动容器时必须运行一个命令；  
  ●CREATED：表示容器创建的时间；  
  ●STATUS：表示容器运行状态，例如Up表示运行中，Exited表示已停止；  
  ●PORTS：表示容器内部暴露的端口映射到主机的端口；  
  ●NAMES：表示生成容器的名称，由Docker引擎自动生成，可以像上述示例中使用--name参数指定生成容器的名称。  
  另外，docker ps指令运行过程中可以指定多个参数，还可以通过docker ps --help指令对ps指令的其他信息进行查看。

**8.删除容器**  
  当不需要使用容器时，则可以使用docker rm指令删除已停止的容器，具体使用方式如下。
```js
$ docker rm f0c9a8b6e8c5
```  
  需要注意的是，上述指令只能删除已经停止运行的容器，而不能删除正在运行的容器。如果想要删除正在运行的容器，则需要添加-f参数强制删除，具体使用方式如下。
```js
$ docker rm -f f0c9a8b6e8c5
```  
  当需要删除的容器过多时，如果还一个个的删除就略显麻烦了，此时可以通过如下指令将全部容器删除。
```js
$ docker rm -f $(docker ps -aq)
```  
  上述指令中，首先会通过$(docker ps -aq)获取所有容器的ID，然后通过docker rm -f指令进行强制删除。如果开发者有自己特殊的删除需求，可以根据前面docker ps指令进行组装来获取需要删除的容器ID。  
  Docker提供的操作指令远不止这些，这里就不一一列举了，想要了解更多Docker的操作指令，可以通过docker --help指令进行查看。


, 2018-12-05, null, 默认分类, Docker,客户端指令, true, null, 21, 1]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [11, Docker数据管理介绍,   当我们对容器进行相关操作时，产生的一系列数据都会存储在容器中，而Docker内部又是如果管理这些数据的呢？本篇文章将针对Docker数据管理的一些知识进行介绍。
  
**1. Docker数据存储机制**  
  使用Docker时，我们操作的都是镜像和由镜像生成的容器，所以想要更好的了解Docker内部的数据存储机制，就必须从镜像、容器与数据存储的关系出发。  
  Docker镜像是通过读取Dockerfile文件中的指令构建的，Dockerfile中的每条指令都会创建一个镜像层，并且每层都是只读的，这一系列的镜像层就构成了Docker镜像。接下来以一个Dockerfile文件为例进行说明，具体如下列代码示例所示。
```js
 1	FROM ubuntu:16.04
 2	COPY . /app
 3	RUN make /app
 4	CMD python /app/app.py
```  
   上述文件示例中的Dockerfile包含了4条指令，每条指令都会创建一个镜像层，其中每一层与前一层都有所不同，并且是层层叠加的。通过镜像构建容器时，会在镜像层上增加一个容器层（即可写层），所有对容器的更改都会写入容器层，这也是Docker默认的数据存储方式。  
  下面通过一个效果图进行说明，具体如下图所示。
![alt](/article_img/docker/6.png)
  从图中可以看出，Docker容器和镜像之间的主要区别是顶部的容器层，而所有对容器中数据的添加、修改等操作都会被存储在容器层中。当容器被删除时，容器层也会被删除，其中存储的数据会被一同删除，而下面的镜像层却保持不变。  
  由于所有的容器都是通过镜像构建的，所以每个容器都有各自的容器层，对于容器数据的更改就会保存在各自的容器层中。也就是说，由同一个镜像构建的多个容器，它们会拥有相同的底部镜像层，而拥有不同的容器层，多个容器可以访问相同的镜像层，并且有自己的独立数据状态。具体说明如下图所示。 
![alt](/article_img/docker/7.png)
  从图中可以看出，基于同一个镜像构建的多个容器可以共享该镜像层，但是多个容器想要共享相同的数据，就需要将这些数据存储到容器之外的地方，而这种方式就是下一节要提到的Docker volume数据外部挂载机制。  

**2. Docker数据存储方式**    
  在默认情况下，Docker中的数据都是存放在容器层的，但是这样存储数据却有较多的缺陷，具体表现如下。    
  ●当容器不再运行时，容器中的数据无法持久化保存，如果另一个进程需要这些数据，那么将很难从容器中获取数据；  
  ●容器层与正在运行的主机紧密耦合，不能轻易地移动数据；  
  ●容器层需要一个存储驱动程序来管理文件系统，存储驱动程序提供了一个使用Linux内核的联合文件系统，这种额外的抽象化降低了性能。  
  基于上述种种原因，多数情况下Docker数据管理都不会直接将数据写入容器层，而是使用另一种叫做Docker volume数据外部挂载的机制进行数据管理。  
  针对Docker volume数据外部挂载机制，Docker提供了三种不同的方式将数据从容器映射到Docker宿主机，他们分别为：volumes（数据卷）、bind mounts（绑定挂载）和tmpfs mounts（tmpfs挂载）。这三种数据管理方式的具体选择，需要结合实际情况进行考虑，其中的volumes数据卷是最常用也是官方推荐的数据管理方式。无论选择使用哪种数据管理方式，数据在容器内看起来都一样的，而在容器外则会被被挂载到文件系统中的某个目录或文件中。    
  下面通过一张图来展示数据卷、绑定挂载和tmpfs挂载之间的差异，如下图所示。  
![alt](/article_img/docker/8.png)
  从图中可以看出，Docker提供的三种数据管理方式略有不同，具体分析如下。  
  ●volumes：存储在主机文件系统中（在Linux系统下是存在于/var/lib/Docker/volumes/目录），并由Docker管理，非Docker进程无法修改文件系统的这个部分。  
  ●bind mounts：可以存储在主机系统的任意位置，甚至可能是重要的系统文件或目录，在Docker主机或容器上的非Docker进程可以对他们进行任意修改。  
  ●tmpfs mounts：只存储在主机系统的内存中，并没有写入到主机的文件系统中。


, 2018-12-07, 2021-05-19, 默认分类, Docker,数据管理, true, null, 19, 1]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [6, JDK 8——Lambda表达式介绍,   Lambda表达式是JDK 8中一个重要的新特性，它使用一个清晰简洁的表达式来表达一个接口，同时Lambda表达式也简化了对集合以及数组数据的遍历、过滤和提取等操作。下面，本篇文章就对Lambda表达式进行简要介绍，并进行演示说明。

**1. Lambda表达式入门**  

  匿名内部类存在的一个问题是，如果匿名内部类的实现非常简单，例如只包含一个抽象方法的接口，那么匿名内部类的语法仍然显得比较冗余。为此，JDK 8中新增了一个特性Lambda表达式，这种表达式只针对有一个抽象方法的接口实现，以简洁的表达式形式实现接口功能来作为方法参数。  
  一个Lambda表达式由三个部分组成，分别为参数列表、“->”和表达式主体，其语法格式如下：
```js
 ([数据类型 参数名,数据类型 参数名,...]) -> {表达式主体}
```  
  从上述语法格式上看，Lambda表达式的书写非常简单，下面针对Lambda表达式的组成部分进行简单介绍，具体如下：  
  （1）([数据类型 参数名,数据类型 参数名,...])：用来向表达式主体传递接口方法需要的参数，多个参数名中间必须用英文逗号“,”进行分隔；在编写Lambda表达式时，可以省略参数的数据类型，后面的表达式主体会自动进行校对和匹配；同时，如果只有一个参数，则可以省略括号“()”。  
  （2）->：表示Lambda表达式箭牌，用来指定参数数据指向，不能省略，且必须用英文横线和大于号书写。  
  （3）{表达式主体}：由单个表达式或语句块组成的主体，本质就是接口中抽象方法的具体实现，如果表达式主体只有一条语句，那么可以省略包含主体的大括号；另外，在Lambda表达式主体中允许有返回值，当只有一条return语句时，也可以省略return关键字。  
  了解了Lambda表达式的语法后，接下来编写一个示例文件对Lambda表达式的基本使用进行介绍，具体代码如下所示。
```js
 1	// 定义动物类接口
 2	interface Animal { 
 3		void shout(); // 定义方法shout()
 4	}
 5	public class Example22 {
 6		public static void main(String[] args) {
 7	       String name = "小花"; 
 8	       // 1、匿名内部类作为参数传递给animalShout()方法
 9		  animalShout(new Animal() { 
 10				 public void shout() { 
 11				    System.out.println("匿名内部类输出："+name+"喵喵...");
 12				}
 13		  });
 14		  // 2、使用Lambda表达式作为参数传递给animalShout()方法
 15	       animalShout(()-> System.out.println("Lambda表达式输出："
 16	                                                   +name+"喵喵..."));
 17		}
 18	    // 创建一个animalShout()静态方法，接收接口类型的参数
 19		public static void animalShout(Animal an) {
 20			an.shout();  
 21		}
 22	}
```  
  运行结果下图所示。
![alt](/article_img/lambda/1.jpg)
  上述代码示例中，先定义了只有一个抽象方法的接口Animal，然后分别使用匿名内部类和Lambda表达式的方式实现了接口方法。从图中可以看出，使用匿名内部类和Lambda表达式都能实现接口中方法，但很显然使用Lambda表达式更加简洁和清晰。, 2018-11-27, null, 默认分类, 2018,Lambda表达式, true, null, 18, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [7, 函数式接口, &emsp;&emsp;虽然Lambda表达式可以实现匿名内部类的功能，但在使用时却有一个局限，即接口中有且只有一个抽象方法时才能使用Lamdba表达式代替匿名内部类。这是因为Lamdba表达式是基于函数式接口实现的，所谓函数式接口是指有且仅有一个抽象方法的接口，Lambda表达式就是Java中函数式编程的体现，只有确保接口中有且仅有一个抽象方法，Lambda表达式才能顺利地推导出所实现的这个接口中的方法。  
&emsp;&emsp;在JDK 8中，专门为函数式接口引入了一个@FunctionalInterface注解，该注解只是显示的标注了接口是一个函数式接口，并强制编辑器进行更严格的检查，确保该接口是函数式接口，如果不是函数式接口，那么编译器就会报错，而对程序运行并没有实质上的影响。  
&emsp;&emsp;接下来通过一个案例来演示函数式接口的定义与使用，示例代码如下所示。
```js
 1	// 定义无参、无返回值的函数式接口
 2	@FunctionalInterface
 3	interface Animal {
 4		void shout();
 5	}
 6	// 定义有参、有返回值的函数式接口
 7	interface Calculate {
 8		int sum(int a, int b);
 9	}
 10	public class Example23 {
 11		public static void main(String[] args) {
 12		   // 分别两个函数式接口进行测试
 13		   animalShout(() -> System.out.println("无参、无返回值的函数式接口调用"));
 14		   showSum(10, 20, (x, y) -> x + y);
 15		}
 16		// 创建一个动物叫的方法，并传入接口对象Animal作为参数
 17		private static void animalShout(Animal animal) {
 18			animal.shout();
 19		}
 20		// 创建一个求和的方法，并传入两个int类型以及接口Calculate类型的参数
 21		private static void showSum(int x, int y, Calculate calculate) {
 22		   System.out.println(x + "+" + y + "的和为：" + calculate.sum(x, y));
 23		}
 24	}
```  
&emsp;&emsp;运行结果如下图所示。

![alt](/article_img/lambda/2.jpg)
&emsp;&emsp;上述代码示例中，先定义了两个函数式接口Animal和Calculate，然后在测试类中分别编写了两个静态方法，并将这两个函数式接口以参数的形式传入，最后在main()方法中分别调用这两个静态方法，并将所需要的函数式接口参数以Lambda表达式的形式传入。从图中可以看出，程序中函数式接口的定义和使用完全正确。
, 2018-12-01, null, 默认分类, 接口,函数式接口, true, null, 12, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} closed
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20002} closed
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} connected
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20000} created. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20000} Parameters : []
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20000} Types : []
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20000} executed. 7.9956 millis. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} open
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Header: [count(0)]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [12]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} closed
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20000} closed
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20001} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20001} Parameters : [5]
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20001} Types : [INTEGER]
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20001} executed. 1.2584 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} open
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} closed
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20001} closed
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20002} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20002} Parameters : []
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20002} Types : []
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20002} executed. 2.3154 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} open
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [12, Spring Boot 2 权威发布,   如果这两天登录 [https://start.spring.io/ ](https://start.spring.io/ )就会发现，Spring Boot 默认版本已经升到了 2.1.0。这是因为 Spring Boot 刚刚发布了 2.1.0 版本，我们来看下 Spring Boot 2 发布以来第一个子版本都发布了哪些内容？  

**2.1 中的新特性**     
  ●将spring-boot-starter-oauth2-oidc-client重命名为spring-boot-starter-oauth2-client命名更简洁  
  ●添加 OAuth2 资源服务 starter，OAuth2 一个用于认证的组件  
  ●支持 ConditionalOnBean 和 ConditionalOnMissingBean 下的参数化容器  
  ●自动配置 applicationTaskExecutor bean 的延迟加载来避免不必要的日志记录  
  ●将 DatabaseDriver＃SAP 重命名为 DatabaseDriver  
  ●跳过重启器不仅适用于 JUnit4，也适用于 JUnit5  
  ●在 Jest HealthIndicator 中使用集群端点  
  ●当 DevTools 禁用重启时添加日志输出  
  ●添加注解：@ConditionalOnMissingServletFilter提高 Servlet Filters 的自动装配。
  
**2.1 中的组件升级**  
  ●升级 Hibernate 5.3，Hibernate 的支持升级到了 5.3  
  ●升级 Tomcat 9 ，支持最新的 tomcat 9  
  ●支持 Java 11，Java 现在更新越来越快，Spring 快赶不上了    
  ●升级 Thymeleaf Extras Springsecurity 到 3.0.4.RELEASE ，thymeleaf-extras-springsecurity 是 Thymeleaf 提供集成 Spring Security 的组件  
  ●升级 Joda Time 2.10.1，Joda-Time， 面向 Java 应用程序的日期/时间库的替代选择，Joda-Time 令时间和日期值变得易于管理、操作和理解。  
  ●升级 Lettuce 5.1.2.RELEASE ，Lettuce 前面说过，传说中 Redis 最快的客户端。  
  ●升级 Reactor Californium-SR2 ，Californium 是物联网云服务的 Java COAP 实现。因此，它更专注的是可扩展性和可用性而不是像嵌入式设备那样关注资源效率。不过，Californium 也适合嵌入式的 JVM。  
  ●升级 Maven Failsafe Plugin 2.22.1 ，Maven 中的测试插件。  
  ●升级 Flyway 5.2.1 ， Flyway是一款开源的数据库版本管理工具  
  ●升级 Aspectj 1.9.2 ，AspectJ 是 Java 中流行的 AOP（Aspect-oriented Programming）编程扩展框架，是 Eclipse 托管给 Apache 基金会的一个开源项目。  
  ●升级 Mysql 8.0.13 ，Mysql 支持到 8。  
  ●...  
  更多的详细内容可以参考这里：[Spring Boot 2.1 Release Notes](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.1-Release-Notes)
, 2018-12-12, 2021-05-22, 默认分类, Spring Boot 2, true, null, 62, 1]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [8, JDK 8——聚合操作, &emsp;&emsp;在Java8版本中，JDK包含许多聚合操作（如平均值，总和，最小，最大，和计数），返回一个计算流stream的聚合结果。这些聚合操作被称为聚合操作。JDK除返回单个值的聚合操作外，还有很多聚合操作返回一个collection集合实例。很多的reduce操作执行特定的任务，如求平均值或按类别分组元素。  

**1. 聚合操作简介**

  在开发中，多数情况下会涉及到对集合、数组中元素的操作，在JDK 8之前都是通过普通的循环遍历出每一个元素，然后还会穿插一些if条件语句选择性的对元素进行查找、过滤、修改等操作，这种原始的操作方法虽然可行，但是代码量较大并且执行效率较低。  
  为此，JDK 8中新增了一个Stream接口，该接口可以将集合、数组的中的元素转换为Stream流的形式，并结合Lambda表达式的优势来进一步简化集合、数组中元素的查找、过滤、转换等操作，这一新功能就是JDK 8中的聚合操作。  
  在程序中，使用聚合操作没有绝对的语法规范，根据实际操作流程，主要可以分为以下3个步骤：  
  （1）将原始集合或者数组对象转换为Stream流对象；  
  （2）对Stream流对象中的元素进行一系列的过滤、查找等中间操作（Intermediate Operations），然后仍然返回一个Stream流对象；  
  （3）对Stream流进行遍历、统计、收集等终结操作（Terminal Operation），获取想要的结果。  
  接下来，就根据上面聚合操作的3个步骤，通过一个案例来演示聚合操作的基本用法，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example31 {
 4		public static void main(String[] args) {
 5	          // 创建一个List集合对象
 6			List<String> list = new ArrayList<>(); 
 7			list.add("张三");
 8			list.add("李四");
 9			list.add("张小明");
 10			list.add("张阳");
 11			// 1、创建一个Stream流对象
 12			Stream<String> stream = list.stream();
 13			// 2、对Stream流中的元素分别进行过滤、截取操作
 14		       Stream<String> stream2 = stream.filter(i -> i.startsWith("张"));
 15			Stream<String> stream3 = stream2.limit(2);
 16			// 3、对Stream流中的元素进行终结操作，进行遍历输出
 17			stream3.forEach(j -> System.out.println(j));
 18			System.out.println("=======");
 19	         // 通过链式表达式的形式完成聚合操作
 20			list.stream().filter(i -> i.startsWith("张"))
 21						 .limit(2)
 22						 .forEach(j -> System.out.println(j));
 23		}
 24	}
``` 
   运行结果如下图所示。
![alt](/article_img/lambda/3.jpg)
  上述示例代码中，先创建了一个List集合，然后根据聚合操作的3个步骤实现了集合对象的聚合操作，对集合中的元素使用Stream流的形式进行过滤（filter）、截取（limit），并进行遍历输出。其中第12~17行代码分步骤详细展示了聚合操作，而第20~22行代码是使用了链式表达式（调用有返回值的方法时不获取返回值而是直接再调用另一个方法）实现了聚合操作，该表达式的语法格式更简洁、高效，这种链式调用也被称为操作管道流。

**2. 创建Stream流对象**  
  在上一小节中，介绍了聚合操作的主要使用步骤，其中首要解决的问题就是创建Stream流对象。聚合操作针对的就是可迭代数据进行的操作，如集合、数组等，所以创建Stream流对象其实就是将集合、数组等通过一些方法转换为Stream流对象。  
  在Java中，集合对象有对应的集合类，可以通过集合类提供的静态方法创建Stream流对象，而数组数据却没有对应的数组类，所以必须通过其他方法创建Stream流对象。针对不同的源数据，Java提供了多种创建Stream流对象的方式，分别如下：  
  （1）所有的Collections集合都可以使用stream()静态方法获取Stream流对象；  
  （2）Stream接口的of()静态方法可以获取基本类型包装类数组、引用类型数组和单个元素的Stream流对象；  
  （3）Arrays数组工具类的stream()静态方法也可以获取数组元素的Stream流对象。  
  接下来，通过一个案例来学习聚合操作中如何创建Stream流对象，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example32 {
 4		public static void main(String[] args) {
 5	          // 创建一个数组
 6			Integer[] array = { 9, 8, 3, 5, 2 };       
 7	          // 将数组转换为List集合
 8			List<Integer> list = Arrays.asList(array); 
 9			// 1、使用集合对象的stream()静态方法创建Stream流对象
 10			Stream<Integer> stream = list.stream();
 11			stream.forEach(i -> System.out.print(i+" "));
 12			System.out.println();
 13			// 2、使用Stream接口的of()静态方法创建Stream流对象
 14			Stream<Integer> stream2 = Stream.of(array);
 15			stream2.forEach(i -> System.out.print(i+" "));
 16			System.out.println();
 17			// 3、使用Arrays数组工具类的stream()静态方法创建Stream流对象
 18			Stream<Integer> stream3 = Arrays.stream(array);
 19			stream3.forEach(i -> System.out.print(i+" "));
 20		}
 21	}
```  
  运行结果如下图所示。
![alt](/article_img/lambda/4.jpg)
  上述示例代码中，先创建了一个数组和一个集合，然后通过三种方式实现了Stream流对象的创建，并通过Stream流对象的forEach()方法结合Lambda表达式完成了集合和数组中元素的遍历。  

**小提示：**  
  在JDK 8中，只针对单列集合Collections接口对象提供了stream()静态方法获取Stream流对象，并未对Map集合提供相关方法获取Stream流对象，所以想要用Map集合创建Stream流对象必须先通过Map集合的keySet()、values()、entrySet()等方法将Map集合转换为单列Set集合，然后再使用单列集合的stream()静态方法获取对应键、值集合的Stream流对象。

, 2018-12-02, null, 默认分类, JDK 8,聚合操作, true, null, 36, 1]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [9, 虚拟化容器技术——Docker运行机制介绍,   Docker是一个开源的应用容器引擎，它基于go语言开发，并遵从Apache2.0开源协议。使用Docker可以让开发者封装他们的应用以及依赖包到一个可移植的容器中，然后发布到任意的Linux机器上，也可以实现虚拟化。Docker容器完全使用沙箱机制，相互之间不会有任何接口，这保证了容器之间的安全性。  

**1. Docker的引擎介绍**

  Docker Engine（Docker引擎）是Docker的核心部分，使用的是客户端-服务器（C/S）架构模式，其主要组成部分如下图所示。
![alt](/article_img/docker/1.png)
  从上图可以看出，Docker Engine中包含了三个核心组件（docker CLI、REST API和docker daemon），这三个组件的具体说明如下：  
  ①docker CLI（command line interface）：表示Docker命令行接口，开发者可以在命令行中使用Docker相关指令与Docker守护进程进行交互，从而管理诸如image（镜像）、container（容器）、network（网络）和data volumes（数据卷）等实体。  
  ②REST API：表示应用程序API接口，开发者通过该API接口可以与Docker的守护进程进行交互，从而指示后台进行相关操作。  
  ③docker daemon：表示Docker的服务端组件，他是Docker架构中运行在后台的一个守护进程，可以接收并处理来自命令行接口及API接口的指令，然后进行相应的后台操作。  
  对于开发者而言，既可以使用编写好的脚本文件通过REST API来实现与Docker进程交互，又可以直接使用Docker相关指令通过命令行接口来与Docker进程交互，而其他一些Docker应用则是通过底层的API和CLI进行交互的。

**2. Docker的架构介绍**

  了解了Docker内部引擎及作用后，我们还需要通过Docker的具体架构，来了解Docker的整个运行流程。接下来借助Docker官网的架构图来对Docker架构进行详细说明，如下图所示。
![alt](/article_img/docker/2.jpg)
  从图中可以看出，Docker架构主要包括Client、DOCKER_HOST和Register三部分，关于这三部分的具体说明如下。  
&emsp;&emsp;**（1）Client（客户端）**  
  Client即Docker客户端，也就是上一小节Docker Engine中介绍的docker CLI。开发者通过这个客户端使用Docker的相关指令与Docker守护进程进行交互，从而进行Docker镜像的创建、拉取和运行等操作。  
&emsp;&emsp;**（2）DOCKER_HOST（Docker主机）**  
  DOCKER_HOST即Docker内部引擎运行的主机，主要指Docker daemon（Docker守护进程）。可以通过Docker守护进程与客户端还有Docker的镜像仓库Registry进行交互，从而管理Images（镜像）和Containers（容器）等。  
&emsp;&emsp;**（3）Registry（注册中心）**  
  Registry即Docker注册中心，实质就是Docker镜像仓库，默认使用的是Docker官方远程注册中心Docker Hub，也可以使用开发者搭建的本地仓库。Registry中包含了大量的镜像，这些镜像可以是官网基础镜像，也可以是其他开发者上传的镜像。  
  我们在实际使用Docker时，除了会涉及到图中的三个主要部分外，还会涉及到很多Docker Objects（Docker对象），例如Images（镜像）、Containers（容器）、Networks（网络）、Volumes（数据卷）、Plugins（插件）等。其中常用的两个对象Image和Containers的说明如下。  
  ①Images（镜像）  
  Docker 镜像就是一个只读的模板，包含了一些创建Docker容器的操作指令。通常情况下，一个Docker镜像是基于另一个基础镜像创建的，并且新创建的镜像会额外包含一些功能配置。例如：开发者可以依赖于一个Ubuntu的基础镜像创建一个新镜像，并可以在新镜像中安装Apache等软件或其它应用程序。  
  ②Containers（容器）  
  Docker容器属于镜像的一个可运行实例（镜像与容器的关系其实与Java中的类与对象相似），开发者可以通过API接口或者CLI命令行接口来创建、运行、停止、移动、删除一个容器，也可以将一个容器连接到一个或多个网络中，将数据存储与容器进行关联。



, 2018-12-03, null, 默认分类, 虚拟化容器,Docker,运行机制, true, null, 26, 1]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [10, Docker常用客户端指令介绍,   在使用Docker之前，首先会为对应的项目编写Dockerfile镜像构建文件，然后通过Docker的相关指令进行镜像构建，完成镜像的构建后，就可以使用这些项目镜像进行启动测试了。所以要想知道如何使用Docker来执行这些Dockerfile镜像构建文件，还需要学习Docker客户端的常用指令，本篇文章将对Docker客户端的常用指令进行详细讲解。  

**1.列出镜像**  
  通过docker images指令可以查看本地镜像列表中已有的镜像，具体使用方式如下。
```js
$ docker images
```  
  执行上述指令后，系统会将所有本地镜像都展示出来，如下图所示。
![alt](/article_img/docker/3.png)
  从图中可以看出，系统终端将本地镜像列表中的3个镜像分5列进行了展示，每一列的具体含义如下。  
  ●REPOSITORY：镜像名称。  
  ●TAG：镜像的参数，类似于版本号，默认是latest。  
  ●IMAGE ID：镜像ID，是唯一值。此处看到的是一个长度为12的字符串，实际上它是64位完整镜像ID的缩写形式。  
  ●CREATED：距今创建镜像的时间。  
  ●SIZE：镜像大小。    

**2.搜索镜像**  
  想知道在Docker Hub中包含了哪些镜像，除了可以登录Docker Hub，在官网中心进行查看外，还可以直接在Docker客户端进行查询。例如想要查询Ubuntu镜像，可以使用如下指令。
```js
$ docker search ubuntu
```  
  执行上述指令后，系统终端就会将搜索到的有关Ubuntu的镜像展示出来，如下图所示。
![alt](/article_img/docker/4.png)
  从图所示的结果可以看出，系统终端分5列将搜索到的Ubuntu相关镜像都列举出来了，这5列的具体含义如下。  
  ●NAME：表示镜像的名称，这里有两种格式的名称，其中不带有“/”的表示官方镜像，而带有“/”的表示其他用户的公开镜像。公开镜像“/”前面是用户在Docker Hub上的用户名（唯一），后面是对应的镜像名；官方镜像与用户镜像，除了从镜像名称上可以区分外，还可以通过第4列的OFFICIAL声明中看出（该列下内容为OK表示官方镜像）。  
  ●DESCRIPTION：表示镜像的描述，这里只显示了一小部分。  
  ●STARS：表示该镜像的收藏数，用户可以在Docker Hub上对镜像进行收藏，一般可以通过该数字反应出该镜像的受欢迎程度。  
  ●OFFICIAL：表示是否为官方镜像。  
  ●AUTOMATED：表示是否自动构建镜像。例如，用户可以将自己的Docker Hub绑定到如Github上，当代码提交更新后，可以自动构建镜像。   
 
**3.拉取镜像**  
  通过docker pull指令可以拉取仓库镜像到本地（默认都是拉取Docker Hub仓库镜像，也可以指定“IP+端口”拉取某个Docker机器上的私有仓库镜像），具体使用方式如下。
```js
$ docker pull ubuntu
```  
  执行上述指令后，Docker会自动从Docker Hub上下载最新版本的Ubuntu到本地，当然也可以使用以下指令拉取指定版本的镜像到本地，具体指令如下。
```js
$ docker pull ubuntu:14.04
```  
**4.构建镜像**  
  除了可以通过docker pull指令从仓库拉取镜像外，还可以通过docker build指令构建Docker镜像，通常情况下都是通过Dockerfile文件来构建镜像的。  
  这里假设linux系统home目录下/shitou/workspace/dockerspace文件夹中编写有对应的Dockerfile文件，则构建镜像直立示例如下所示。 
```js
$ docker build -t hellodocker3 /home/shitou/workspace/dockerspace/.
```
**5.删除镜像**  
  当本地存放过多不需要的镜像时，可以通过docker rmi指令将其删除。在删除镜像时，需要指定镜像名称或镜像ID。删除镜像的使用方式如下。
```js
$ docker rmi -f hellodocker2 hellodocker3
```  
  上述指令中，docker rmi表示删除镜像，-f表示进行强制删除，而hellodocker2和hellodocker3分别表示需要删除的镜像名称，这里同时删除两个镜像。除了根据名称删除镜像外，还也可以根据镜像ID来删除镜像，只是这里如果指定了删除ID为23c617a866d4的镜像后，会同时删除hellodocker、hellodocker2和hellodocker3三个镜像。  
  需要特别强调的是，在进行镜像删除操作时，如果是通过镜像ID进行镜像删除，那么由该镜像创建的容器必须提前删除或停止。另外，在通过镜像名称操作镜像时，如果出现镜像重名的情况，必须在镜像名称后面指定镜像标签tag参数来确保唯一性。

**6.创建并启动容器**  
  Docker镜像主要用于创建容器，可以使用docker run指令创建并启动容器，具体使用方式如下。
```js
$ docker run -d -p 5000:80 --name test hellodocker
```  
  上述创建并启动容器的指令略微复杂，具体分析如下。  
  ●docker run：表示创建并启动一个容器，而后面的hellodocker就表示要启动运行的镜像名称；  
  ●-d：表示容器启动时在后台运行；  
  ●-p 5000:80：表示将容器内暴露的80端口映射到宿主机指定的5000端口，也可以将-p 5000:80更改为-P来映射主机的随机端口（注意p字母的大小写）；  
  ●--name test：表示为创建后的容器指定名称为test，如果没有该参数配置，则生成的容器会设置一个随机名称。  
  docker run命令是Docker操作中较为复杂的一个，它可以携带多个参数和参数，我们可以通过docker run --help指令进行查看，其中有些参数如-e、-v和-w等都可以在Dockerfile文件中预先声明。 
 
**7.列出容器**  
  生成容器后，可以通过docker ps指令查看当前运行的所有容器，具体使用方式如下。
```js
$ docker ps
```  
  执行上述命令后，会将所有当前运行的容器都展示出来，具体如下图所示。
![alt](/article_img/docker/5.png)
  从图中可以看出，系统终端通过7列对当前的正在运行的一个容器进行了展示，图中每一列的具体含义如下。  
  ●CONTAINER ID：表示生成的容器ID；  
  ●IMAGE：表示生成该容器的镜像名称；  
  ●COMMAND：表示启动容器时运行的命令，Docker要求在启动容器时必须运行一个命令；  
  ●CREATED：表示容器创建的时间；  
  ●STATUS：表示容器运行状态，例如Up表示运行中，Exited表示已停止；  
  ●PORTS：表示容器内部暴露的端口映射到主机的端口；  
  ●NAMES：表示生成容器的名称，由Docker引擎自动生成，可以像上述示例中使用--name参数指定生成容器的名称。  
  另外，docker ps指令运行过程中可以指定多个参数，还可以通过docker ps --help指令对ps指令的其他信息进行查看。

**8.删除容器**  
  当不需要使用容器时，则可以使用docker rm指令删除已停止的容器，具体使用方式如下。
```js
$ docker rm f0c9a8b6e8c5
```  
  需要注意的是，上述指令只能删除已经停止运行的容器，而不能删除正在运行的容器。如果想要删除正在运行的容器，则需要添加-f参数强制删除，具体使用方式如下。
```js
$ docker rm -f f0c9a8b6e8c5
```  
  当需要删除的容器过多时，如果还一个个的删除就略显麻烦了，此时可以通过如下指令将全部容器删除。
```js
$ docker rm -f $(docker ps -aq)
```  
  上述指令中，首先会通过$(docker ps -aq)获取所有容器的ID，然后通过docker rm -f指令进行强制删除。如果开发者有自己特殊的删除需求，可以根据前面docker ps指令进行组装来获取需要删除的容器ID。  
  Docker提供的操作指令远不止这些，这里就不一一列举了，想要了解更多Docker的操作指令，可以通过docker --help指令进行查看。


, 2018-12-05, null, 默认分类, Docker,客户端指令, true, null, 21, 1]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [11, Docker数据管理介绍,   当我们对容器进行相关操作时，产生的一系列数据都会存储在容器中，而Docker内部又是如果管理这些数据的呢？本篇文章将针对Docker数据管理的一些知识进行介绍。
  
**1. Docker数据存储机制**  
  使用Docker时，我们操作的都是镜像和由镜像生成的容器，所以想要更好的了解Docker内部的数据存储机制，就必须从镜像、容器与数据存储的关系出发。  
  Docker镜像是通过读取Dockerfile文件中的指令构建的，Dockerfile中的每条指令都会创建一个镜像层，并且每层都是只读的，这一系列的镜像层就构成了Docker镜像。接下来以一个Dockerfile文件为例进行说明，具体如下列代码示例所示。
```js
 1	FROM ubuntu:16.04
 2	COPY . /app
 3	RUN make /app
 4	CMD python /app/app.py
```  
   上述文件示例中的Dockerfile包含了4条指令，每条指令都会创建一个镜像层，其中每一层与前一层都有所不同，并且是层层叠加的。通过镜像构建容器时，会在镜像层上增加一个容器层（即可写层），所有对容器的更改都会写入容器层，这也是Docker默认的数据存储方式。  
  下面通过一个效果图进行说明，具体如下图所示。
![alt](/article_img/docker/6.png)
  从图中可以看出，Docker容器和镜像之间的主要区别是顶部的容器层，而所有对容器中数据的添加、修改等操作都会被存储在容器层中。当容器被删除时，容器层也会被删除，其中存储的数据会被一同删除，而下面的镜像层却保持不变。  
  由于所有的容器都是通过镜像构建的，所以每个容器都有各自的容器层，对于容器数据的更改就会保存在各自的容器层中。也就是说，由同一个镜像构建的多个容器，它们会拥有相同的底部镜像层，而拥有不同的容器层，多个容器可以访问相同的镜像层，并且有自己的独立数据状态。具体说明如下图所示。 
![alt](/article_img/docker/7.png)
  从图中可以看出，基于同一个镜像构建的多个容器可以共享该镜像层，但是多个容器想要共享相同的数据，就需要将这些数据存储到容器之外的地方，而这种方式就是下一节要提到的Docker volume数据外部挂载机制。  

**2. Docker数据存储方式**    
  在默认情况下，Docker中的数据都是存放在容器层的，但是这样存储数据却有较多的缺陷，具体表现如下。    
  ●当容器不再运行时，容器中的数据无法持久化保存，如果另一个进程需要这些数据，那么将很难从容器中获取数据；  
  ●容器层与正在运行的主机紧密耦合，不能轻易地移动数据；  
  ●容器层需要一个存储驱动程序来管理文件系统，存储驱动程序提供了一个使用Linux内核的联合文件系统，这种额外的抽象化降低了性能。  
  基于上述种种原因，多数情况下Docker数据管理都不会直接将数据写入容器层，而是使用另一种叫做Docker volume数据外部挂载的机制进行数据管理。  
  针对Docker volume数据外部挂载机制，Docker提供了三种不同的方式将数据从容器映射到Docker宿主机，他们分别为：volumes（数据卷）、bind mounts（绑定挂载）和tmpfs mounts（tmpfs挂载）。这三种数据管理方式的具体选择，需要结合实际情况进行考虑，其中的volumes数据卷是最常用也是官方推荐的数据管理方式。无论选择使用哪种数据管理方式，数据在容器内看起来都一样的，而在容器外则会被被挂载到文件系统中的某个目录或文件中。    
  下面通过一张图来展示数据卷、绑定挂载和tmpfs挂载之间的差异，如下图所示。  
![alt](/article_img/docker/8.png)
  从图中可以看出，Docker提供的三种数据管理方式略有不同，具体分析如下。  
  ●volumes：存储在主机文件系统中（在Linux系统下是存在于/var/lib/Docker/volumes/目录），并由Docker管理，非Docker进程无法修改文件系统的这个部分。  
  ●bind mounts：可以存储在主机系统的任意位置，甚至可能是重要的系统文件或目录，在Docker主机或容器上的非Docker进程可以对他们进行任意修改。  
  ●tmpfs mounts：只存储在主机系统的内存中，并没有写入到主机的文件系统中。


, 2018-12-07, 2021-05-19, 默认分类, Docker,数据管理, true, null, 19, 1]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [6, JDK 8——Lambda表达式介绍,   Lambda表达式是JDK 8中一个重要的新特性，它使用一个清晰简洁的表达式来表达一个接口，同时Lambda表达式也简化了对集合以及数组数据的遍历、过滤和提取等操作。下面，本篇文章就对Lambda表达式进行简要介绍，并进行演示说明。

**1. Lambda表达式入门**  

  匿名内部类存在的一个问题是，如果匿名内部类的实现非常简单，例如只包含一个抽象方法的接口，那么匿名内部类的语法仍然显得比较冗余。为此，JDK 8中新增了一个特性Lambda表达式，这种表达式只针对有一个抽象方法的接口实现，以简洁的表达式形式实现接口功能来作为方法参数。  
  一个Lambda表达式由三个部分组成，分别为参数列表、“->”和表达式主体，其语法格式如下：
```js
 ([数据类型 参数名,数据类型 参数名,...]) -> {表达式主体}
```  
  从上述语法格式上看，Lambda表达式的书写非常简单，下面针对Lambda表达式的组成部分进行简单介绍，具体如下：  
  （1）([数据类型 参数名,数据类型 参数名,...])：用来向表达式主体传递接口方法需要的参数，多个参数名中间必须用英文逗号“,”进行分隔；在编写Lambda表达式时，可以省略参数的数据类型，后面的表达式主体会自动进行校对和匹配；同时，如果只有一个参数，则可以省略括号“()”。  
  （2）->：表示Lambda表达式箭牌，用来指定参数数据指向，不能省略，且必须用英文横线和大于号书写。  
  （3）{表达式主体}：由单个表达式或语句块组成的主体，本质就是接口中抽象方法的具体实现，如果表达式主体只有一条语句，那么可以省略包含主体的大括号；另外，在Lambda表达式主体中允许有返回值，当只有一条return语句时，也可以省略return关键字。  
  了解了Lambda表达式的语法后，接下来编写一个示例文件对Lambda表达式的基本使用进行介绍，具体代码如下所示。
```js
 1	// 定义动物类接口
 2	interface Animal { 
 3		void shout(); // 定义方法shout()
 4	}
 5	public class Example22 {
 6		public static void main(String[] args) {
 7	       String name = "小花"; 
 8	       // 1、匿名内部类作为参数传递给animalShout()方法
 9		  animalShout(new Animal() { 
 10				 public void shout() { 
 11				    System.out.println("匿名内部类输出："+name+"喵喵...");
 12				}
 13		  });
 14		  // 2、使用Lambda表达式作为参数传递给animalShout()方法
 15	       animalShout(()-> System.out.println("Lambda表达式输出："
 16	                                                   +name+"喵喵..."));
 17		}
 18	    // 创建一个animalShout()静态方法，接收接口类型的参数
 19		public static void animalShout(Animal an) {
 20			an.shout();  
 21		}
 22	}
```  
  运行结果下图所示。
![alt](/article_img/lambda/1.jpg)
  上述代码示例中，先定义了只有一个抽象方法的接口Animal，然后分别使用匿名内部类和Lambda表达式的方式实现了接口方法。从图中可以看出，使用匿名内部类和Lambda表达式都能实现接口中方法，但很显然使用Lambda表达式更加简洁和清晰。, 2018-11-27, null, 默认分类, 2018,Lambda表达式, true, null, 18, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [7, 函数式接口, &emsp;&emsp;虽然Lambda表达式可以实现匿名内部类的功能，但在使用时却有一个局限，即接口中有且只有一个抽象方法时才能使用Lamdba表达式代替匿名内部类。这是因为Lamdba表达式是基于函数式接口实现的，所谓函数式接口是指有且仅有一个抽象方法的接口，Lambda表达式就是Java中函数式编程的体现，只有确保接口中有且仅有一个抽象方法，Lambda表达式才能顺利地推导出所实现的这个接口中的方法。  
&emsp;&emsp;在JDK 8中，专门为函数式接口引入了一个@FunctionalInterface注解，该注解只是显示的标注了接口是一个函数式接口，并强制编辑器进行更严格的检查，确保该接口是函数式接口，如果不是函数式接口，那么编译器就会报错，而对程序运行并没有实质上的影响。  
&emsp;&emsp;接下来通过一个案例来演示函数式接口的定义与使用，示例代码如下所示。
```js
 1	// 定义无参、无返回值的函数式接口
 2	@FunctionalInterface
 3	interface Animal {
 4		void shout();
 5	}
 6	// 定义有参、有返回值的函数式接口
 7	interface Calculate {
 8		int sum(int a, int b);
 9	}
 10	public class Example23 {
 11		public static void main(String[] args) {
 12		   // 分别两个函数式接口进行测试
 13		   animalShout(() -> System.out.println("无参、无返回值的函数式接口调用"));
 14		   showSum(10, 20, (x, y) -> x + y);
 15		}
 16		// 创建一个动物叫的方法，并传入接口对象Animal作为参数
 17		private static void animalShout(Animal animal) {
 18			animal.shout();
 19		}
 20		// 创建一个求和的方法，并传入两个int类型以及接口Calculate类型的参数
 21		private static void showSum(int x, int y, Calculate calculate) {
 22		   System.out.println(x + "+" + y + "的和为：" + calculate.sum(x, y));
 23		}
 24	}
```  
&emsp;&emsp;运行结果如下图所示。

![alt](/article_img/lambda/2.jpg)
&emsp;&emsp;上述代码示例中，先定义了两个函数式接口Animal和Calculate，然后在测试类中分别编写了两个静态方法，并将这两个函数式接口以参数的形式传入，最后在main()方法中分别调用这两个静态方法，并将所需要的函数式接口参数以Lambda表达式的形式传入。从图中可以看出，程序中函数式接口的定义和使用完全正确。
, 2018-12-01, null, 默认分类, 接口,函数式接口, true, null, 12, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} closed
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20002} closed
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} connected
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20000} created. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20000} Parameters : []
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20000} Types : []
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20000} executed. 7.7231 millis. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} open
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Header: [count(0)]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [12]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} closed
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20000} closed
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20001} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20001} Parameters : [5]
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20001} Types : [INTEGER]
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20001} executed. 1.1655 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} open
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} closed
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20001} closed
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20002} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20002} Parameters : []
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20002} Types : []
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20002} executed. 0.7693 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} open
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [12, Spring Boot 2 权威发布,   如果这两天登录 [https://start.spring.io/ ](https://start.spring.io/ )就会发现，Spring Boot 默认版本已经升到了 2.1.0。这是因为 Spring Boot 刚刚发布了 2.1.0 版本，我们来看下 Spring Boot 2 发布以来第一个子版本都发布了哪些内容？  

**2.1 中的新特性**     
  ●将spring-boot-starter-oauth2-oidc-client重命名为spring-boot-starter-oauth2-client命名更简洁  
  ●添加 OAuth2 资源服务 starter，OAuth2 一个用于认证的组件  
  ●支持 ConditionalOnBean 和 ConditionalOnMissingBean 下的参数化容器  
  ●自动配置 applicationTaskExecutor bean 的延迟加载来避免不必要的日志记录  
  ●将 DatabaseDriver＃SAP 重命名为 DatabaseDriver  
  ●跳过重启器不仅适用于 JUnit4，也适用于 JUnit5  
  ●在 Jest HealthIndicator 中使用集群端点  
  ●当 DevTools 禁用重启时添加日志输出  
  ●添加注解：@ConditionalOnMissingServletFilter提高 Servlet Filters 的自动装配。
  
**2.1 中的组件升级**  
  ●升级 Hibernate 5.3，Hibernate 的支持升级到了 5.3  
  ●升级 Tomcat 9 ，支持最新的 tomcat 9  
  ●支持 Java 11，Java 现在更新越来越快，Spring 快赶不上了    
  ●升级 Thymeleaf Extras Springsecurity 到 3.0.4.RELEASE ，thymeleaf-extras-springsecurity 是 Thymeleaf 提供集成 Spring Security 的组件  
  ●升级 Joda Time 2.10.1，Joda-Time， 面向 Java 应用程序的日期/时间库的替代选择，Joda-Time 令时间和日期值变得易于管理、操作和理解。  
  ●升级 Lettuce 5.1.2.RELEASE ，Lettuce 前面说过，传说中 Redis 最快的客户端。  
  ●升级 Reactor Californium-SR2 ，Californium 是物联网云服务的 Java COAP 实现。因此，它更专注的是可扩展性和可用性而不是像嵌入式设备那样关注资源效率。不过，Californium 也适合嵌入式的 JVM。  
  ●升级 Maven Failsafe Plugin 2.22.1 ，Maven 中的测试插件。  
  ●升级 Flyway 5.2.1 ， Flyway是一款开源的数据库版本管理工具  
  ●升级 Aspectj 1.9.2 ，AspectJ 是 Java 中流行的 AOP（Aspect-oriented Programming）编程扩展框架，是 Eclipse 托管给 Apache 基金会的一个开源项目。  
  ●升级 Mysql 8.0.13 ，Mysql 支持到 8。  
  ●...  
  更多的详细内容可以参考这里：[Spring Boot 2.1 Release Notes](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.1-Release-Notes)
, 2018-12-12, 2021-05-22, 默认分类, Spring Boot 2, true, null, 62, 1]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [8, JDK 8——聚合操作, &emsp;&emsp;在Java8版本中，JDK包含许多聚合操作（如平均值，总和，最小，最大，和计数），返回一个计算流stream的聚合结果。这些聚合操作被称为聚合操作。JDK除返回单个值的聚合操作外，还有很多聚合操作返回一个collection集合实例。很多的reduce操作执行特定的任务，如求平均值或按类别分组元素。  

**1. 聚合操作简介**

  在开发中，多数情况下会涉及到对集合、数组中元素的操作，在JDK 8之前都是通过普通的循环遍历出每一个元素，然后还会穿插一些if条件语句选择性的对元素进行查找、过滤、修改等操作，这种原始的操作方法虽然可行，但是代码量较大并且执行效率较低。  
  为此，JDK 8中新增了一个Stream接口，该接口可以将集合、数组的中的元素转换为Stream流的形式，并结合Lambda表达式的优势来进一步简化集合、数组中元素的查找、过滤、转换等操作，这一新功能就是JDK 8中的聚合操作。  
  在程序中，使用聚合操作没有绝对的语法规范，根据实际操作流程，主要可以分为以下3个步骤：  
  （1）将原始集合或者数组对象转换为Stream流对象；  
  （2）对Stream流对象中的元素进行一系列的过滤、查找等中间操作（Intermediate Operations），然后仍然返回一个Stream流对象；  
  （3）对Stream流进行遍历、统计、收集等终结操作（Terminal Operation），获取想要的结果。  
  接下来，就根据上面聚合操作的3个步骤，通过一个案例来演示聚合操作的基本用法，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example31 {
 4		public static void main(String[] args) {
 5	          // 创建一个List集合对象
 6			List<String> list = new ArrayList<>(); 
 7			list.add("张三");
 8			list.add("李四");
 9			list.add("张小明");
 10			list.add("张阳");
 11			// 1、创建一个Stream流对象
 12			Stream<String> stream = list.stream();
 13			// 2、对Stream流中的元素分别进行过滤、截取操作
 14		       Stream<String> stream2 = stream.filter(i -> i.startsWith("张"));
 15			Stream<String> stream3 = stream2.limit(2);
 16			// 3、对Stream流中的元素进行终结操作，进行遍历输出
 17			stream3.forEach(j -> System.out.println(j));
 18			System.out.println("=======");
 19	         // 通过链式表达式的形式完成聚合操作
 20			list.stream().filter(i -> i.startsWith("张"))
 21						 .limit(2)
 22						 .forEach(j -> System.out.println(j));
 23		}
 24	}
``` 
   运行结果如下图所示。
![alt](/article_img/lambda/3.jpg)
  上述示例代码中，先创建了一个List集合，然后根据聚合操作的3个步骤实现了集合对象的聚合操作，对集合中的元素使用Stream流的形式进行过滤（filter）、截取（limit），并进行遍历输出。其中第12~17行代码分步骤详细展示了聚合操作，而第20~22行代码是使用了链式表达式（调用有返回值的方法时不获取返回值而是直接再调用另一个方法）实现了聚合操作，该表达式的语法格式更简洁、高效，这种链式调用也被称为操作管道流。

**2. 创建Stream流对象**  
  在上一小节中，介绍了聚合操作的主要使用步骤，其中首要解决的问题就是创建Stream流对象。聚合操作针对的就是可迭代数据进行的操作，如集合、数组等，所以创建Stream流对象其实就是将集合、数组等通过一些方法转换为Stream流对象。  
  在Java中，集合对象有对应的集合类，可以通过集合类提供的静态方法创建Stream流对象，而数组数据却没有对应的数组类，所以必须通过其他方法创建Stream流对象。针对不同的源数据，Java提供了多种创建Stream流对象的方式，分别如下：  
  （1）所有的Collections集合都可以使用stream()静态方法获取Stream流对象；  
  （2）Stream接口的of()静态方法可以获取基本类型包装类数组、引用类型数组和单个元素的Stream流对象；  
  （3）Arrays数组工具类的stream()静态方法也可以获取数组元素的Stream流对象。  
  接下来，通过一个案例来学习聚合操作中如何创建Stream流对象，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example32 {
 4		public static void main(String[] args) {
 5	          // 创建一个数组
 6			Integer[] array = { 9, 8, 3, 5, 2 };       
 7	          // 将数组转换为List集合
 8			List<Integer> list = Arrays.asList(array); 
 9			// 1、使用集合对象的stream()静态方法创建Stream流对象
 10			Stream<Integer> stream = list.stream();
 11			stream.forEach(i -> System.out.print(i+" "));
 12			System.out.println();
 13			// 2、使用Stream接口的of()静态方法创建Stream流对象
 14			Stream<Integer> stream2 = Stream.of(array);
 15			stream2.forEach(i -> System.out.print(i+" "));
 16			System.out.println();
 17			// 3、使用Arrays数组工具类的stream()静态方法创建Stream流对象
 18			Stream<Integer> stream3 = Arrays.stream(array);
 19			stream3.forEach(i -> System.out.print(i+" "));
 20		}
 21	}
```  
  运行结果如下图所示。
![alt](/article_img/lambda/4.jpg)
  上述示例代码中，先创建了一个数组和一个集合，然后通过三种方式实现了Stream流对象的创建，并通过Stream流对象的forEach()方法结合Lambda表达式完成了集合和数组中元素的遍历。  

**小提示：**  
  在JDK 8中，只针对单列集合Collections接口对象提供了stream()静态方法获取Stream流对象，并未对Map集合提供相关方法获取Stream流对象，所以想要用Map集合创建Stream流对象必须先通过Map集合的keySet()、values()、entrySet()等方法将Map集合转换为单列Set集合，然后再使用单列集合的stream()静态方法获取对应键、值集合的Stream流对象。

, 2018-12-02, null, 默认分类, JDK 8,聚合操作, true, null, 36, 1]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [9, 虚拟化容器技术——Docker运行机制介绍,   Docker是一个开源的应用容器引擎，它基于go语言开发，并遵从Apache2.0开源协议。使用Docker可以让开发者封装他们的应用以及依赖包到一个可移植的容器中，然后发布到任意的Linux机器上，也可以实现虚拟化。Docker容器完全使用沙箱机制，相互之间不会有任何接口，这保证了容器之间的安全性。  

**1. Docker的引擎介绍**

  Docker Engine（Docker引擎）是Docker的核心部分，使用的是客户端-服务器（C/S）架构模式，其主要组成部分如下图所示。
![alt](/article_img/docker/1.png)
  从上图可以看出，Docker Engine中包含了三个核心组件（docker CLI、REST API和docker daemon），这三个组件的具体说明如下：  
  ①docker CLI（command line interface）：表示Docker命令行接口，开发者可以在命令行中使用Docker相关指令与Docker守护进程进行交互，从而管理诸如image（镜像）、container（容器）、network（网络）和data volumes（数据卷）等实体。  
  ②REST API：表示应用程序API接口，开发者通过该API接口可以与Docker的守护进程进行交互，从而指示后台进行相关操作。  
  ③docker daemon：表示Docker的服务端组件，他是Docker架构中运行在后台的一个守护进程，可以接收并处理来自命令行接口及API接口的指令，然后进行相应的后台操作。  
  对于开发者而言，既可以使用编写好的脚本文件通过REST API来实现与Docker进程交互，又可以直接使用Docker相关指令通过命令行接口来与Docker进程交互，而其他一些Docker应用则是通过底层的API和CLI进行交互的。

**2. Docker的架构介绍**

  了解了Docker内部引擎及作用后，我们还需要通过Docker的具体架构，来了解Docker的整个运行流程。接下来借助Docker官网的架构图来对Docker架构进行详细说明，如下图所示。
![alt](/article_img/docker/2.jpg)
  从图中可以看出，Docker架构主要包括Client、DOCKER_HOST和Register三部分，关于这三部分的具体说明如下。  
&emsp;&emsp;**（1）Client（客户端）**  
  Client即Docker客户端，也就是上一小节Docker Engine中介绍的docker CLI。开发者通过这个客户端使用Docker的相关指令与Docker守护进程进行交互，从而进行Docker镜像的创建、拉取和运行等操作。  
&emsp;&emsp;**（2）DOCKER_HOST（Docker主机）**  
  DOCKER_HOST即Docker内部引擎运行的主机，主要指Docker daemon（Docker守护进程）。可以通过Docker守护进程与客户端还有Docker的镜像仓库Registry进行交互，从而管理Images（镜像）和Containers（容器）等。  
&emsp;&emsp;**（3）Registry（注册中心）**  
  Registry即Docker注册中心，实质就是Docker镜像仓库，默认使用的是Docker官方远程注册中心Docker Hub，也可以使用开发者搭建的本地仓库。Registry中包含了大量的镜像，这些镜像可以是官网基础镜像，也可以是其他开发者上传的镜像。  
  我们在实际使用Docker时，除了会涉及到图中的三个主要部分外，还会涉及到很多Docker Objects（Docker对象），例如Images（镜像）、Containers（容器）、Networks（网络）、Volumes（数据卷）、Plugins（插件）等。其中常用的两个对象Image和Containers的说明如下。  
  ①Images（镜像）  
  Docker 镜像就是一个只读的模板，包含了一些创建Docker容器的操作指令。通常情况下，一个Docker镜像是基于另一个基础镜像创建的，并且新创建的镜像会额外包含一些功能配置。例如：开发者可以依赖于一个Ubuntu的基础镜像创建一个新镜像，并可以在新镜像中安装Apache等软件或其它应用程序。  
  ②Containers（容器）  
  Docker容器属于镜像的一个可运行实例（镜像与容器的关系其实与Java中的类与对象相似），开发者可以通过API接口或者CLI命令行接口来创建、运行、停止、移动、删除一个容器，也可以将一个容器连接到一个或多个网络中，将数据存储与容器进行关联。



, 2018-12-03, null, 默认分类, 虚拟化容器,Docker,运行机制, true, null, 26, 1]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [10, Docker常用客户端指令介绍,   在使用Docker之前，首先会为对应的项目编写Dockerfile镜像构建文件，然后通过Docker的相关指令进行镜像构建，完成镜像的构建后，就可以使用这些项目镜像进行启动测试了。所以要想知道如何使用Docker来执行这些Dockerfile镜像构建文件，还需要学习Docker客户端的常用指令，本篇文章将对Docker客户端的常用指令进行详细讲解。  

**1.列出镜像**  
  通过docker images指令可以查看本地镜像列表中已有的镜像，具体使用方式如下。
```js
$ docker images
```  
  执行上述指令后，系统会将所有本地镜像都展示出来，如下图所示。
![alt](/article_img/docker/3.png)
  从图中可以看出，系统终端将本地镜像列表中的3个镜像分5列进行了展示，每一列的具体含义如下。  
  ●REPOSITORY：镜像名称。  
  ●TAG：镜像的参数，类似于版本号，默认是latest。  
  ●IMAGE ID：镜像ID，是唯一值。此处看到的是一个长度为12的字符串，实际上它是64位完整镜像ID的缩写形式。  
  ●CREATED：距今创建镜像的时间。  
  ●SIZE：镜像大小。    

**2.搜索镜像**  
  想知道在Docker Hub中包含了哪些镜像，除了可以登录Docker Hub，在官网中心进行查看外，还可以直接在Docker客户端进行查询。例如想要查询Ubuntu镜像，可以使用如下指令。
```js
$ docker search ubuntu
```  
  执行上述指令后，系统终端就会将搜索到的有关Ubuntu的镜像展示出来，如下图所示。
![alt](/article_img/docker/4.png)
  从图所示的结果可以看出，系统终端分5列将搜索到的Ubuntu相关镜像都列举出来了，这5列的具体含义如下。  
  ●NAME：表示镜像的名称，这里有两种格式的名称，其中不带有“/”的表示官方镜像，而带有“/”的表示其他用户的公开镜像。公开镜像“/”前面是用户在Docker Hub上的用户名（唯一），后面是对应的镜像名；官方镜像与用户镜像，除了从镜像名称上可以区分外，还可以通过第4列的OFFICIAL声明中看出（该列下内容为OK表示官方镜像）。  
  ●DESCRIPTION：表示镜像的描述，这里只显示了一小部分。  
  ●STARS：表示该镜像的收藏数，用户可以在Docker Hub上对镜像进行收藏，一般可以通过该数字反应出该镜像的受欢迎程度。  
  ●OFFICIAL：表示是否为官方镜像。  
  ●AUTOMATED：表示是否自动构建镜像。例如，用户可以将自己的Docker Hub绑定到如Github上，当代码提交更新后，可以自动构建镜像。   
 
**3.拉取镜像**  
  通过docker pull指令可以拉取仓库镜像到本地（默认都是拉取Docker Hub仓库镜像，也可以指定“IP+端口”拉取某个Docker机器上的私有仓库镜像），具体使用方式如下。
```js
$ docker pull ubuntu
```  
  执行上述指令后，Docker会自动从Docker Hub上下载最新版本的Ubuntu到本地，当然也可以使用以下指令拉取指定版本的镜像到本地，具体指令如下。
```js
$ docker pull ubuntu:14.04
```  
**4.构建镜像**  
  除了可以通过docker pull指令从仓库拉取镜像外，还可以通过docker build指令构建Docker镜像，通常情况下都是通过Dockerfile文件来构建镜像的。  
  这里假设linux系统home目录下/shitou/workspace/dockerspace文件夹中编写有对应的Dockerfile文件，则构建镜像直立示例如下所示。 
```js
$ docker build -t hellodocker3 /home/shitou/workspace/dockerspace/.
```
**5.删除镜像**  
  当本地存放过多不需要的镜像时，可以通过docker rmi指令将其删除。在删除镜像时，需要指定镜像名称或镜像ID。删除镜像的使用方式如下。
```js
$ docker rmi -f hellodocker2 hellodocker3
```  
  上述指令中，docker rmi表示删除镜像，-f表示进行强制删除，而hellodocker2和hellodocker3分别表示需要删除的镜像名称，这里同时删除两个镜像。除了根据名称删除镜像外，还也可以根据镜像ID来删除镜像，只是这里如果指定了删除ID为23c617a866d4的镜像后，会同时删除hellodocker、hellodocker2和hellodocker3三个镜像。  
  需要特别强调的是，在进行镜像删除操作时，如果是通过镜像ID进行镜像删除，那么由该镜像创建的容器必须提前删除或停止。另外，在通过镜像名称操作镜像时，如果出现镜像重名的情况，必须在镜像名称后面指定镜像标签tag参数来确保唯一性。

**6.创建并启动容器**  
  Docker镜像主要用于创建容器，可以使用docker run指令创建并启动容器，具体使用方式如下。
```js
$ docker run -d -p 5000:80 --name test hellodocker
```  
  上述创建并启动容器的指令略微复杂，具体分析如下。  
  ●docker run：表示创建并启动一个容器，而后面的hellodocker就表示要启动运行的镜像名称；  
  ●-d：表示容器启动时在后台运行；  
  ●-p 5000:80：表示将容器内暴露的80端口映射到宿主机指定的5000端口，也可以将-p 5000:80更改为-P来映射主机的随机端口（注意p字母的大小写）；  
  ●--name test：表示为创建后的容器指定名称为test，如果没有该参数配置，则生成的容器会设置一个随机名称。  
  docker run命令是Docker操作中较为复杂的一个，它可以携带多个参数和参数，我们可以通过docker run --help指令进行查看，其中有些参数如-e、-v和-w等都可以在Dockerfile文件中预先声明。 
 
**7.列出容器**  
  生成容器后，可以通过docker ps指令查看当前运行的所有容器，具体使用方式如下。
```js
$ docker ps
```  
  执行上述命令后，会将所有当前运行的容器都展示出来，具体如下图所示。
![alt](/article_img/docker/5.png)
  从图中可以看出，系统终端通过7列对当前的正在运行的一个容器进行了展示，图中每一列的具体含义如下。  
  ●CONTAINER ID：表示生成的容器ID；  
  ●IMAGE：表示生成该容器的镜像名称；  
  ●COMMAND：表示启动容器时运行的命令，Docker要求在启动容器时必须运行一个命令；  
  ●CREATED：表示容器创建的时间；  
  ●STATUS：表示容器运行状态，例如Up表示运行中，Exited表示已停止；  
  ●PORTS：表示容器内部暴露的端口映射到主机的端口；  
  ●NAMES：表示生成容器的名称，由Docker引擎自动生成，可以像上述示例中使用--name参数指定生成容器的名称。  
  另外，docker ps指令运行过程中可以指定多个参数，还可以通过docker ps --help指令对ps指令的其他信息进行查看。

**8.删除容器**  
  当不需要使用容器时，则可以使用docker rm指令删除已停止的容器，具体使用方式如下。
```js
$ docker rm f0c9a8b6e8c5
```  
  需要注意的是，上述指令只能删除已经停止运行的容器，而不能删除正在运行的容器。如果想要删除正在运行的容器，则需要添加-f参数强制删除，具体使用方式如下。
```js
$ docker rm -f f0c9a8b6e8c5
```  
  当需要删除的容器过多时，如果还一个个的删除就略显麻烦了，此时可以通过如下指令将全部容器删除。
```js
$ docker rm -f $(docker ps -aq)
```  
  上述指令中，首先会通过$(docker ps -aq)获取所有容器的ID，然后通过docker rm -f指令进行强制删除。如果开发者有自己特殊的删除需求，可以根据前面docker ps指令进行组装来获取需要删除的容器ID。  
  Docker提供的操作指令远不止这些，这里就不一一列举了，想要了解更多Docker的操作指令，可以通过docker --help指令进行查看。


, 2018-12-05, null, 默认分类, Docker,客户端指令, true, null, 21, 1]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [11, Docker数据管理介绍,   当我们对容器进行相关操作时，产生的一系列数据都会存储在容器中，而Docker内部又是如果管理这些数据的呢？本篇文章将针对Docker数据管理的一些知识进行介绍。
  
**1. Docker数据存储机制**  
  使用Docker时，我们操作的都是镜像和由镜像生成的容器，所以想要更好的了解Docker内部的数据存储机制，就必须从镜像、容器与数据存储的关系出发。  
  Docker镜像是通过读取Dockerfile文件中的指令构建的，Dockerfile中的每条指令都会创建一个镜像层，并且每层都是只读的，这一系列的镜像层就构成了Docker镜像。接下来以一个Dockerfile文件为例进行说明，具体如下列代码示例所示。
```js
 1	FROM ubuntu:16.04
 2	COPY . /app
 3	RUN make /app
 4	CMD python /app/app.py
```  
   上述文件示例中的Dockerfile包含了4条指令，每条指令都会创建一个镜像层，其中每一层与前一层都有所不同，并且是层层叠加的。通过镜像构建容器时，会在镜像层上增加一个容器层（即可写层），所有对容器的更改都会写入容器层，这也是Docker默认的数据存储方式。  
  下面通过一个效果图进行说明，具体如下图所示。
![alt](/article_img/docker/6.png)
  从图中可以看出，Docker容器和镜像之间的主要区别是顶部的容器层，而所有对容器中数据的添加、修改等操作都会被存储在容器层中。当容器被删除时，容器层也会被删除，其中存储的数据会被一同删除，而下面的镜像层却保持不变。  
  由于所有的容器都是通过镜像构建的，所以每个容器都有各自的容器层，对于容器数据的更改就会保存在各自的容器层中。也就是说，由同一个镜像构建的多个容器，它们会拥有相同的底部镜像层，而拥有不同的容器层，多个容器可以访问相同的镜像层，并且有自己的独立数据状态。具体说明如下图所示。 
![alt](/article_img/docker/7.png)
  从图中可以看出，基于同一个镜像构建的多个容器可以共享该镜像层，但是多个容器想要共享相同的数据，就需要将这些数据存储到容器之外的地方，而这种方式就是下一节要提到的Docker volume数据外部挂载机制。  

**2. Docker数据存储方式**    
  在默认情况下，Docker中的数据都是存放在容器层的，但是这样存储数据却有较多的缺陷，具体表现如下。    
  ●当容器不再运行时，容器中的数据无法持久化保存，如果另一个进程需要这些数据，那么将很难从容器中获取数据；  
  ●容器层与正在运行的主机紧密耦合，不能轻易地移动数据；  
  ●容器层需要一个存储驱动程序来管理文件系统，存储驱动程序提供了一个使用Linux内核的联合文件系统，这种额外的抽象化降低了性能。  
  基于上述种种原因，多数情况下Docker数据管理都不会直接将数据写入容器层，而是使用另一种叫做Docker volume数据外部挂载的机制进行数据管理。  
  针对Docker volume数据外部挂载机制，Docker提供了三种不同的方式将数据从容器映射到Docker宿主机，他们分别为：volumes（数据卷）、bind mounts（绑定挂载）和tmpfs mounts（tmpfs挂载）。这三种数据管理方式的具体选择，需要结合实际情况进行考虑，其中的volumes数据卷是最常用也是官方推荐的数据管理方式。无论选择使用哪种数据管理方式，数据在容器内看起来都一样的，而在容器外则会被被挂载到文件系统中的某个目录或文件中。    
  下面通过一张图来展示数据卷、绑定挂载和tmpfs挂载之间的差异，如下图所示。  
![alt](/article_img/docker/8.png)
  从图中可以看出，Docker提供的三种数据管理方式略有不同，具体分析如下。  
  ●volumes：存储在主机文件系统中（在Linux系统下是存在于/var/lib/Docker/volumes/目录），并由Docker管理，非Docker进程无法修改文件系统的这个部分。  
  ●bind mounts：可以存储在主机系统的任意位置，甚至可能是重要的系统文件或目录，在Docker主机或容器上的非Docker进程可以对他们进行任意修改。  
  ●tmpfs mounts：只存储在主机系统的内存中，并没有写入到主机的文件系统中。


, 2018-12-07, 2021-05-19, 默认分类, Docker,数据管理, true, null, 19, 1]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [6, JDK 8——Lambda表达式介绍,   Lambda表达式是JDK 8中一个重要的新特性，它使用一个清晰简洁的表达式来表达一个接口，同时Lambda表达式也简化了对集合以及数组数据的遍历、过滤和提取等操作。下面，本篇文章就对Lambda表达式进行简要介绍，并进行演示说明。

**1. Lambda表达式入门**  

  匿名内部类存在的一个问题是，如果匿名内部类的实现非常简单，例如只包含一个抽象方法的接口，那么匿名内部类的语法仍然显得比较冗余。为此，JDK 8中新增了一个特性Lambda表达式，这种表达式只针对有一个抽象方法的接口实现，以简洁的表达式形式实现接口功能来作为方法参数。  
  一个Lambda表达式由三个部分组成，分别为参数列表、“->”和表达式主体，其语法格式如下：
```js
 ([数据类型 参数名,数据类型 参数名,...]) -> {表达式主体}
```  
  从上述语法格式上看，Lambda表达式的书写非常简单，下面针对Lambda表达式的组成部分进行简单介绍，具体如下：  
  （1）([数据类型 参数名,数据类型 参数名,...])：用来向表达式主体传递接口方法需要的参数，多个参数名中间必须用英文逗号“,”进行分隔；在编写Lambda表达式时，可以省略参数的数据类型，后面的表达式主体会自动进行校对和匹配；同时，如果只有一个参数，则可以省略括号“()”。  
  （2）->：表示Lambda表达式箭牌，用来指定参数数据指向，不能省略，且必须用英文横线和大于号书写。  
  （3）{表达式主体}：由单个表达式或语句块组成的主体，本质就是接口中抽象方法的具体实现，如果表达式主体只有一条语句，那么可以省略包含主体的大括号；另外，在Lambda表达式主体中允许有返回值，当只有一条return语句时，也可以省略return关键字。  
  了解了Lambda表达式的语法后，接下来编写一个示例文件对Lambda表达式的基本使用进行介绍，具体代码如下所示。
```js
 1	// 定义动物类接口
 2	interface Animal { 
 3		void shout(); // 定义方法shout()
 4	}
 5	public class Example22 {
 6		public static void main(String[] args) {
 7	       String name = "小花"; 
 8	       // 1、匿名内部类作为参数传递给animalShout()方法
 9		  animalShout(new Animal() { 
 10				 public void shout() { 
 11				    System.out.println("匿名内部类输出："+name+"喵喵...");
 12				}
 13		  });
 14		  // 2、使用Lambda表达式作为参数传递给animalShout()方法
 15	       animalShout(()-> System.out.println("Lambda表达式输出："
 16	                                                   +name+"喵喵..."));
 17		}
 18	    // 创建一个animalShout()静态方法，接收接口类型的参数
 19		public static void animalShout(Animal an) {
 20			an.shout();  
 21		}
 22	}
```  
  运行结果下图所示。
![alt](/article_img/lambda/1.jpg)
  上述代码示例中，先定义了只有一个抽象方法的接口Animal，然后分别使用匿名内部类和Lambda表达式的方式实现了接口方法。从图中可以看出，使用匿名内部类和Lambda表达式都能实现接口中方法，但很显然使用Lambda表达式更加简洁和清晰。, 2018-11-27, null, 默认分类, 2018,Lambda表达式, true, null, 18, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [7, 函数式接口, &emsp;&emsp;虽然Lambda表达式可以实现匿名内部类的功能，但在使用时却有一个局限，即接口中有且只有一个抽象方法时才能使用Lamdba表达式代替匿名内部类。这是因为Lamdba表达式是基于函数式接口实现的，所谓函数式接口是指有且仅有一个抽象方法的接口，Lambda表达式就是Java中函数式编程的体现，只有确保接口中有且仅有一个抽象方法，Lambda表达式才能顺利地推导出所实现的这个接口中的方法。  
&emsp;&emsp;在JDK 8中，专门为函数式接口引入了一个@FunctionalInterface注解，该注解只是显示的标注了接口是一个函数式接口，并强制编辑器进行更严格的检查，确保该接口是函数式接口，如果不是函数式接口，那么编译器就会报错，而对程序运行并没有实质上的影响。  
&emsp;&emsp;接下来通过一个案例来演示函数式接口的定义与使用，示例代码如下所示。
```js
 1	// 定义无参、无返回值的函数式接口
 2	@FunctionalInterface
 3	interface Animal {
 4		void shout();
 5	}
 6	// 定义有参、有返回值的函数式接口
 7	interface Calculate {
 8		int sum(int a, int b);
 9	}
 10	public class Example23 {
 11		public static void main(String[] args) {
 12		   // 分别两个函数式接口进行测试
 13		   animalShout(() -> System.out.println("无参、无返回值的函数式接口调用"));
 14		   showSum(10, 20, (x, y) -> x + y);
 15		}
 16		// 创建一个动物叫的方法，并传入接口对象Animal作为参数
 17		private static void animalShout(Animal animal) {
 18			animal.shout();
 19		}
 20		// 创建一个求和的方法，并传入两个int类型以及接口Calculate类型的参数
 21		private static void showSum(int x, int y, Calculate calculate) {
 22		   System.out.println(x + "+" + y + "的和为：" + calculate.sum(x, y));
 23		}
 24	}
```  
&emsp;&emsp;运行结果如下图所示。

![alt](/article_img/lambda/2.jpg)
&emsp;&emsp;上述代码示例中，先定义了两个函数式接口Animal和Calculate，然后在测试类中分别编写了两个静态方法，并将这两个函数式接口以参数的形式传入，最后在main()方法中分别调用这两个静态方法，并将所需要的函数式接口参数以Lambda表达式的形式传入。从图中可以看出，程序中函数式接口的定义和使用完全正确。
, 2018-12-01, null, 默认分类, 接口,函数式接口, true, null, 12, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} closed
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20002} closed
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20003} created. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20003} Parameters : []
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20003} Types : []
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20003} executed. 0.6107 millis. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20003, rs-50003} open
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20003, rs-50003} Header: [count(0)]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20003, rs-50003} Result: [12]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20003, rs-50003} closed
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20003} closed
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20004} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20004} Parameters : [5]
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20004} Types : [INTEGER]
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20004} executed. 0.8316 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} open
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} closed
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20004} closed
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20005} created. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20005} Parameters : []
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20005} Types : []
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20005} executed. 0.525 millis. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20005, rs-50005} open
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20005, rs-50005} Header: [count(0)]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20005, rs-50005} Result: [12]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20005, rs-50005} closed
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20005} closed
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20006} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20006} Parameters : [5]
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20006} Types : [INTEGER]
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20006} executed. 0.4769 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20006, rs-50006} open
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20006, rs-50006} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20006, rs-50006} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20006, rs-50006} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20006, rs-50006} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20006, rs-50006} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20006, rs-50006} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20006, rs-50006} closed
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20006} closed
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} connected
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20000} created. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20000} Parameters : []
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20000} Types : []
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20000} executed. 6.9906 millis. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} open
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Header: [count(0)]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [12]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} closed
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20000} closed
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20001} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20001} Parameters : [5]
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20001} Types : [INTEGER]
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20001} executed. 1.3171 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} open
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} closed
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20001} closed
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20002} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20002} Parameters : []
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20002} Types : []
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20002} executed. 0.8377 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} open
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [12, Spring Boot 2 权威发布,   如果这两天登录 [https://start.spring.io/ ](https://start.spring.io/ )就会发现，Spring Boot 默认版本已经升到了 2.1.0。这是因为 Spring Boot 刚刚发布了 2.1.0 版本，我们来看下 Spring Boot 2 发布以来第一个子版本都发布了哪些内容？  

**2.1 中的新特性**     
  ●将spring-boot-starter-oauth2-oidc-client重命名为spring-boot-starter-oauth2-client命名更简洁  
  ●添加 OAuth2 资源服务 starter，OAuth2 一个用于认证的组件  
  ●支持 ConditionalOnBean 和 ConditionalOnMissingBean 下的参数化容器  
  ●自动配置 applicationTaskExecutor bean 的延迟加载来避免不必要的日志记录  
  ●将 DatabaseDriver＃SAP 重命名为 DatabaseDriver  
  ●跳过重启器不仅适用于 JUnit4，也适用于 JUnit5  
  ●在 Jest HealthIndicator 中使用集群端点  
  ●当 DevTools 禁用重启时添加日志输出  
  ●添加注解：@ConditionalOnMissingServletFilter提高 Servlet Filters 的自动装配。
  
**2.1 中的组件升级**  
  ●升级 Hibernate 5.3，Hibernate 的支持升级到了 5.3  
  ●升级 Tomcat 9 ，支持最新的 tomcat 9  
  ●支持 Java 11，Java 现在更新越来越快，Spring 快赶不上了    
  ●升级 Thymeleaf Extras Springsecurity 到 3.0.4.RELEASE ，thymeleaf-extras-springsecurity 是 Thymeleaf 提供集成 Spring Security 的组件  
  ●升级 Joda Time 2.10.1，Joda-Time， 面向 Java 应用程序的日期/时间库的替代选择，Joda-Time 令时间和日期值变得易于管理、操作和理解。  
  ●升级 Lettuce 5.1.2.RELEASE ，Lettuce 前面说过，传说中 Redis 最快的客户端。  
  ●升级 Reactor Californium-SR2 ，Californium 是物联网云服务的 Java COAP 实现。因此，它更专注的是可扩展性和可用性而不是像嵌入式设备那样关注资源效率。不过，Californium 也适合嵌入式的 JVM。  
  ●升级 Maven Failsafe Plugin 2.22.1 ，Maven 中的测试插件。  
  ●升级 Flyway 5.2.1 ， Flyway是一款开源的数据库版本管理工具  
  ●升级 Aspectj 1.9.2 ，AspectJ 是 Java 中流行的 AOP（Aspect-oriented Programming）编程扩展框架，是 Eclipse 托管给 Apache 基金会的一个开源项目。  
  ●升级 Mysql 8.0.13 ，Mysql 支持到 8。  
  ●...  
  更多的详细内容可以参考这里：[Spring Boot 2.1 Release Notes](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.1-Release-Notes)
, 2018-12-12, 2021-05-22, 默认分类, Spring Boot 2, true, null, 62, 1]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [8, JDK 8——聚合操作, &emsp;&emsp;在Java8版本中，JDK包含许多聚合操作（如平均值，总和，最小，最大，和计数），返回一个计算流stream的聚合结果。这些聚合操作被称为聚合操作。JDK除返回单个值的聚合操作外，还有很多聚合操作返回一个collection集合实例。很多的reduce操作执行特定的任务，如求平均值或按类别分组元素。  

**1. 聚合操作简介**

  在开发中，多数情况下会涉及到对集合、数组中元素的操作，在JDK 8之前都是通过普通的循环遍历出每一个元素，然后还会穿插一些if条件语句选择性的对元素进行查找、过滤、修改等操作，这种原始的操作方法虽然可行，但是代码量较大并且执行效率较低。  
  为此，JDK 8中新增了一个Stream接口，该接口可以将集合、数组的中的元素转换为Stream流的形式，并结合Lambda表达式的优势来进一步简化集合、数组中元素的查找、过滤、转换等操作，这一新功能就是JDK 8中的聚合操作。  
  在程序中，使用聚合操作没有绝对的语法规范，根据实际操作流程，主要可以分为以下3个步骤：  
  （1）将原始集合或者数组对象转换为Stream流对象；  
  （2）对Stream流对象中的元素进行一系列的过滤、查找等中间操作（Intermediate Operations），然后仍然返回一个Stream流对象；  
  （3）对Stream流进行遍历、统计、收集等终结操作（Terminal Operation），获取想要的结果。  
  接下来，就根据上面聚合操作的3个步骤，通过一个案例来演示聚合操作的基本用法，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example31 {
 4		public static void main(String[] args) {
 5	          // 创建一个List集合对象
 6			List<String> list = new ArrayList<>(); 
 7			list.add("张三");
 8			list.add("李四");
 9			list.add("张小明");
 10			list.add("张阳");
 11			// 1、创建一个Stream流对象
 12			Stream<String> stream = list.stream();
 13			// 2、对Stream流中的元素分别进行过滤、截取操作
 14		       Stream<String> stream2 = stream.filter(i -> i.startsWith("张"));
 15			Stream<String> stream3 = stream2.limit(2);
 16			// 3、对Stream流中的元素进行终结操作，进行遍历输出
 17			stream3.forEach(j -> System.out.println(j));
 18			System.out.println("=======");
 19	         // 通过链式表达式的形式完成聚合操作
 20			list.stream().filter(i -> i.startsWith("张"))
 21						 .limit(2)
 22						 .forEach(j -> System.out.println(j));
 23		}
 24	}
``` 
   运行结果如下图所示。
![alt](/article_img/lambda/3.jpg)
  上述示例代码中，先创建了一个List集合，然后根据聚合操作的3个步骤实现了集合对象的聚合操作，对集合中的元素使用Stream流的形式进行过滤（filter）、截取（limit），并进行遍历输出。其中第12~17行代码分步骤详细展示了聚合操作，而第20~22行代码是使用了链式表达式（调用有返回值的方法时不获取返回值而是直接再调用另一个方法）实现了聚合操作，该表达式的语法格式更简洁、高效，这种链式调用也被称为操作管道流。

**2. 创建Stream流对象**  
  在上一小节中，介绍了聚合操作的主要使用步骤，其中首要解决的问题就是创建Stream流对象。聚合操作针对的就是可迭代数据进行的操作，如集合、数组等，所以创建Stream流对象其实就是将集合、数组等通过一些方法转换为Stream流对象。  
  在Java中，集合对象有对应的集合类，可以通过集合类提供的静态方法创建Stream流对象，而数组数据却没有对应的数组类，所以必须通过其他方法创建Stream流对象。针对不同的源数据，Java提供了多种创建Stream流对象的方式，分别如下：  
  （1）所有的Collections集合都可以使用stream()静态方法获取Stream流对象；  
  （2）Stream接口的of()静态方法可以获取基本类型包装类数组、引用类型数组和单个元素的Stream流对象；  
  （3）Arrays数组工具类的stream()静态方法也可以获取数组元素的Stream流对象。  
  接下来，通过一个案例来学习聚合操作中如何创建Stream流对象，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example32 {
 4		public static void main(String[] args) {
 5	          // 创建一个数组
 6			Integer[] array = { 9, 8, 3, 5, 2 };       
 7	          // 将数组转换为List集合
 8			List<Integer> list = Arrays.asList(array); 
 9			// 1、使用集合对象的stream()静态方法创建Stream流对象
 10			Stream<Integer> stream = list.stream();
 11			stream.forEach(i -> System.out.print(i+" "));
 12			System.out.println();
 13			// 2、使用Stream接口的of()静态方法创建Stream流对象
 14			Stream<Integer> stream2 = Stream.of(array);
 15			stream2.forEach(i -> System.out.print(i+" "));
 16			System.out.println();
 17			// 3、使用Arrays数组工具类的stream()静态方法创建Stream流对象
 18			Stream<Integer> stream3 = Arrays.stream(array);
 19			stream3.forEach(i -> System.out.print(i+" "));
 20		}
 21	}
```  
  运行结果如下图所示。
![alt](/article_img/lambda/4.jpg)
  上述示例代码中，先创建了一个数组和一个集合，然后通过三种方式实现了Stream流对象的创建，并通过Stream流对象的forEach()方法结合Lambda表达式完成了集合和数组中元素的遍历。  

**小提示：**  
  在JDK 8中，只针对单列集合Collections接口对象提供了stream()静态方法获取Stream流对象，并未对Map集合提供相关方法获取Stream流对象，所以想要用Map集合创建Stream流对象必须先通过Map集合的keySet()、values()、entrySet()等方法将Map集合转换为单列Set集合，然后再使用单列集合的stream()静态方法获取对应键、值集合的Stream流对象。

, 2018-12-02, null, 默认分类, JDK 8,聚合操作, true, null, 36, 1]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [9, 虚拟化容器技术——Docker运行机制介绍,   Docker是一个开源的应用容器引擎，它基于go语言开发，并遵从Apache2.0开源协议。使用Docker可以让开发者封装他们的应用以及依赖包到一个可移植的容器中，然后发布到任意的Linux机器上，也可以实现虚拟化。Docker容器完全使用沙箱机制，相互之间不会有任何接口，这保证了容器之间的安全性。  

**1. Docker的引擎介绍**

  Docker Engine（Docker引擎）是Docker的核心部分，使用的是客户端-服务器（C/S）架构模式，其主要组成部分如下图所示。
![alt](/article_img/docker/1.png)
  从上图可以看出，Docker Engine中包含了三个核心组件（docker CLI、REST API和docker daemon），这三个组件的具体说明如下：  
  ①docker CLI（command line interface）：表示Docker命令行接口，开发者可以在命令行中使用Docker相关指令与Docker守护进程进行交互，从而管理诸如image（镜像）、container（容器）、network（网络）和data volumes（数据卷）等实体。  
  ②REST API：表示应用程序API接口，开发者通过该API接口可以与Docker的守护进程进行交互，从而指示后台进行相关操作。  
  ③docker daemon：表示Docker的服务端组件，他是Docker架构中运行在后台的一个守护进程，可以接收并处理来自命令行接口及API接口的指令，然后进行相应的后台操作。  
  对于开发者而言，既可以使用编写好的脚本文件通过REST API来实现与Docker进程交互，又可以直接使用Docker相关指令通过命令行接口来与Docker进程交互，而其他一些Docker应用则是通过底层的API和CLI进行交互的。

**2. Docker的架构介绍**

  了解了Docker内部引擎及作用后，我们还需要通过Docker的具体架构，来了解Docker的整个运行流程。接下来借助Docker官网的架构图来对Docker架构进行详细说明，如下图所示。
![alt](/article_img/docker/2.jpg)
  从图中可以看出，Docker架构主要包括Client、DOCKER_HOST和Register三部分，关于这三部分的具体说明如下。  
&emsp;&emsp;**（1）Client（客户端）**  
  Client即Docker客户端，也就是上一小节Docker Engine中介绍的docker CLI。开发者通过这个客户端使用Docker的相关指令与Docker守护进程进行交互，从而进行Docker镜像的创建、拉取和运行等操作。  
&emsp;&emsp;**（2）DOCKER_HOST（Docker主机）**  
  DOCKER_HOST即Docker内部引擎运行的主机，主要指Docker daemon（Docker守护进程）。可以通过Docker守护进程与客户端还有Docker的镜像仓库Registry进行交互，从而管理Images（镜像）和Containers（容器）等。  
&emsp;&emsp;**（3）Registry（注册中心）**  
  Registry即Docker注册中心，实质就是Docker镜像仓库，默认使用的是Docker官方远程注册中心Docker Hub，也可以使用开发者搭建的本地仓库。Registry中包含了大量的镜像，这些镜像可以是官网基础镜像，也可以是其他开发者上传的镜像。  
  我们在实际使用Docker时，除了会涉及到图中的三个主要部分外，还会涉及到很多Docker Objects（Docker对象），例如Images（镜像）、Containers（容器）、Networks（网络）、Volumes（数据卷）、Plugins（插件）等。其中常用的两个对象Image和Containers的说明如下。  
  ①Images（镜像）  
  Docker 镜像就是一个只读的模板，包含了一些创建Docker容器的操作指令。通常情况下，一个Docker镜像是基于另一个基础镜像创建的，并且新创建的镜像会额外包含一些功能配置。例如：开发者可以依赖于一个Ubuntu的基础镜像创建一个新镜像，并可以在新镜像中安装Apache等软件或其它应用程序。  
  ②Containers（容器）  
  Docker容器属于镜像的一个可运行实例（镜像与容器的关系其实与Java中的类与对象相似），开发者可以通过API接口或者CLI命令行接口来创建、运行、停止、移动、删除一个容器，也可以将一个容器连接到一个或多个网络中，将数据存储与容器进行关联。



, 2018-12-03, null, 默认分类, 虚拟化容器,Docker,运行机制, true, null, 26, 1]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [10, Docker常用客户端指令介绍,   在使用Docker之前，首先会为对应的项目编写Dockerfile镜像构建文件，然后通过Docker的相关指令进行镜像构建，完成镜像的构建后，就可以使用这些项目镜像进行启动测试了。所以要想知道如何使用Docker来执行这些Dockerfile镜像构建文件，还需要学习Docker客户端的常用指令，本篇文章将对Docker客户端的常用指令进行详细讲解。  

**1.列出镜像**  
  通过docker images指令可以查看本地镜像列表中已有的镜像，具体使用方式如下。
```js
$ docker images
```  
  执行上述指令后，系统会将所有本地镜像都展示出来，如下图所示。
![alt](/article_img/docker/3.png)
  从图中可以看出，系统终端将本地镜像列表中的3个镜像分5列进行了展示，每一列的具体含义如下。  
  ●REPOSITORY：镜像名称。  
  ●TAG：镜像的参数，类似于版本号，默认是latest。  
  ●IMAGE ID：镜像ID，是唯一值。此处看到的是一个长度为12的字符串，实际上它是64位完整镜像ID的缩写形式。  
  ●CREATED：距今创建镜像的时间。  
  ●SIZE：镜像大小。    

**2.搜索镜像**  
  想知道在Docker Hub中包含了哪些镜像，除了可以登录Docker Hub，在官网中心进行查看外，还可以直接在Docker客户端进行查询。例如想要查询Ubuntu镜像，可以使用如下指令。
```js
$ docker search ubuntu
```  
  执行上述指令后，系统终端就会将搜索到的有关Ubuntu的镜像展示出来，如下图所示。
![alt](/article_img/docker/4.png)
  从图所示的结果可以看出，系统终端分5列将搜索到的Ubuntu相关镜像都列举出来了，这5列的具体含义如下。  
  ●NAME：表示镜像的名称，这里有两种格式的名称，其中不带有“/”的表示官方镜像，而带有“/”的表示其他用户的公开镜像。公开镜像“/”前面是用户在Docker Hub上的用户名（唯一），后面是对应的镜像名；官方镜像与用户镜像，除了从镜像名称上可以区分外，还可以通过第4列的OFFICIAL声明中看出（该列下内容为OK表示官方镜像）。  
  ●DESCRIPTION：表示镜像的描述，这里只显示了一小部分。  
  ●STARS：表示该镜像的收藏数，用户可以在Docker Hub上对镜像进行收藏，一般可以通过该数字反应出该镜像的受欢迎程度。  
  ●OFFICIAL：表示是否为官方镜像。  
  ●AUTOMATED：表示是否自动构建镜像。例如，用户可以将自己的Docker Hub绑定到如Github上，当代码提交更新后，可以自动构建镜像。   
 
**3.拉取镜像**  
  通过docker pull指令可以拉取仓库镜像到本地（默认都是拉取Docker Hub仓库镜像，也可以指定“IP+端口”拉取某个Docker机器上的私有仓库镜像），具体使用方式如下。
```js
$ docker pull ubuntu
```  
  执行上述指令后，Docker会自动从Docker Hub上下载最新版本的Ubuntu到本地，当然也可以使用以下指令拉取指定版本的镜像到本地，具体指令如下。
```js
$ docker pull ubuntu:14.04
```  
**4.构建镜像**  
  除了可以通过docker pull指令从仓库拉取镜像外，还可以通过docker build指令构建Docker镜像，通常情况下都是通过Dockerfile文件来构建镜像的。  
  这里假设linux系统home目录下/shitou/workspace/dockerspace文件夹中编写有对应的Dockerfile文件，则构建镜像直立示例如下所示。 
```js
$ docker build -t hellodocker3 /home/shitou/workspace/dockerspace/.
```
**5.删除镜像**  
  当本地存放过多不需要的镜像时，可以通过docker rmi指令将其删除。在删除镜像时，需要指定镜像名称或镜像ID。删除镜像的使用方式如下。
```js
$ docker rmi -f hellodocker2 hellodocker3
```  
  上述指令中，docker rmi表示删除镜像，-f表示进行强制删除，而hellodocker2和hellodocker3分别表示需要删除的镜像名称，这里同时删除两个镜像。除了根据名称删除镜像外，还也可以根据镜像ID来删除镜像，只是这里如果指定了删除ID为23c617a866d4的镜像后，会同时删除hellodocker、hellodocker2和hellodocker3三个镜像。  
  需要特别强调的是，在进行镜像删除操作时，如果是通过镜像ID进行镜像删除，那么由该镜像创建的容器必须提前删除或停止。另外，在通过镜像名称操作镜像时，如果出现镜像重名的情况，必须在镜像名称后面指定镜像标签tag参数来确保唯一性。

**6.创建并启动容器**  
  Docker镜像主要用于创建容器，可以使用docker run指令创建并启动容器，具体使用方式如下。
```js
$ docker run -d -p 5000:80 --name test hellodocker
```  
  上述创建并启动容器的指令略微复杂，具体分析如下。  
  ●docker run：表示创建并启动一个容器，而后面的hellodocker就表示要启动运行的镜像名称；  
  ●-d：表示容器启动时在后台运行；  
  ●-p 5000:80：表示将容器内暴露的80端口映射到宿主机指定的5000端口，也可以将-p 5000:80更改为-P来映射主机的随机端口（注意p字母的大小写）；  
  ●--name test：表示为创建后的容器指定名称为test，如果没有该参数配置，则生成的容器会设置一个随机名称。  
  docker run命令是Docker操作中较为复杂的一个，它可以携带多个参数和参数，我们可以通过docker run --help指令进行查看，其中有些参数如-e、-v和-w等都可以在Dockerfile文件中预先声明。 
 
**7.列出容器**  
  生成容器后，可以通过docker ps指令查看当前运行的所有容器，具体使用方式如下。
```js
$ docker ps
```  
  执行上述命令后，会将所有当前运行的容器都展示出来，具体如下图所示。
![alt](/article_img/docker/5.png)
  从图中可以看出，系统终端通过7列对当前的正在运行的一个容器进行了展示，图中每一列的具体含义如下。  
  ●CONTAINER ID：表示生成的容器ID；  
  ●IMAGE：表示生成该容器的镜像名称；  
  ●COMMAND：表示启动容器时运行的命令，Docker要求在启动容器时必须运行一个命令；  
  ●CREATED：表示容器创建的时间；  
  ●STATUS：表示容器运行状态，例如Up表示运行中，Exited表示已停止；  
  ●PORTS：表示容器内部暴露的端口映射到主机的端口；  
  ●NAMES：表示生成容器的名称，由Docker引擎自动生成，可以像上述示例中使用--name参数指定生成容器的名称。  
  另外，docker ps指令运行过程中可以指定多个参数，还可以通过docker ps --help指令对ps指令的其他信息进行查看。

**8.删除容器**  
  当不需要使用容器时，则可以使用docker rm指令删除已停止的容器，具体使用方式如下。
```js
$ docker rm f0c9a8b6e8c5
```  
  需要注意的是，上述指令只能删除已经停止运行的容器，而不能删除正在运行的容器。如果想要删除正在运行的容器，则需要添加-f参数强制删除，具体使用方式如下。
```js
$ docker rm -f f0c9a8b6e8c5
```  
  当需要删除的容器过多时，如果还一个个的删除就略显麻烦了，此时可以通过如下指令将全部容器删除。
```js
$ docker rm -f $(docker ps -aq)
```  
  上述指令中，首先会通过$(docker ps -aq)获取所有容器的ID，然后通过docker rm -f指令进行强制删除。如果开发者有自己特殊的删除需求，可以根据前面docker ps指令进行组装来获取需要删除的容器ID。  
  Docker提供的操作指令远不止这些，这里就不一一列举了，想要了解更多Docker的操作指令，可以通过docker --help指令进行查看。


, 2018-12-05, null, 默认分类, Docker,客户端指令, true, null, 21, 1]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [11, Docker数据管理介绍,   当我们对容器进行相关操作时，产生的一系列数据都会存储在容器中，而Docker内部又是如果管理这些数据的呢？本篇文章将针对Docker数据管理的一些知识进行介绍。
  
**1. Docker数据存储机制**  
  使用Docker时，我们操作的都是镜像和由镜像生成的容器，所以想要更好的了解Docker内部的数据存储机制，就必须从镜像、容器与数据存储的关系出发。  
  Docker镜像是通过读取Dockerfile文件中的指令构建的，Dockerfile中的每条指令都会创建一个镜像层，并且每层都是只读的，这一系列的镜像层就构成了Docker镜像。接下来以一个Dockerfile文件为例进行说明，具体如下列代码示例所示。
```js
 1	FROM ubuntu:16.04
 2	COPY . /app
 3	RUN make /app
 4	CMD python /app/app.py
```  
   上述文件示例中的Dockerfile包含了4条指令，每条指令都会创建一个镜像层，其中每一层与前一层都有所不同，并且是层层叠加的。通过镜像构建容器时，会在镜像层上增加一个容器层（即可写层），所有对容器的更改都会写入容器层，这也是Docker默认的数据存储方式。  
  下面通过一个效果图进行说明，具体如下图所示。
![alt](/article_img/docker/6.png)
  从图中可以看出，Docker容器和镜像之间的主要区别是顶部的容器层，而所有对容器中数据的添加、修改等操作都会被存储在容器层中。当容器被删除时，容器层也会被删除，其中存储的数据会被一同删除，而下面的镜像层却保持不变。  
  由于所有的容器都是通过镜像构建的，所以每个容器都有各自的容器层，对于容器数据的更改就会保存在各自的容器层中。也就是说，由同一个镜像构建的多个容器，它们会拥有相同的底部镜像层，而拥有不同的容器层，多个容器可以访问相同的镜像层，并且有自己的独立数据状态。具体说明如下图所示。 
![alt](/article_img/docker/7.png)
  从图中可以看出，基于同一个镜像构建的多个容器可以共享该镜像层，但是多个容器想要共享相同的数据，就需要将这些数据存储到容器之外的地方，而这种方式就是下一节要提到的Docker volume数据外部挂载机制。  

**2. Docker数据存储方式**    
  在默认情况下，Docker中的数据都是存放在容器层的，但是这样存储数据却有较多的缺陷，具体表现如下。    
  ●当容器不再运行时，容器中的数据无法持久化保存，如果另一个进程需要这些数据，那么将很难从容器中获取数据；  
  ●容器层与正在运行的主机紧密耦合，不能轻易地移动数据；  
  ●容器层需要一个存储驱动程序来管理文件系统，存储驱动程序提供了一个使用Linux内核的联合文件系统，这种额外的抽象化降低了性能。  
  基于上述种种原因，多数情况下Docker数据管理都不会直接将数据写入容器层，而是使用另一种叫做Docker volume数据外部挂载的机制进行数据管理。  
  针对Docker volume数据外部挂载机制，Docker提供了三种不同的方式将数据从容器映射到Docker宿主机，他们分别为：volumes（数据卷）、bind mounts（绑定挂载）和tmpfs mounts（tmpfs挂载）。这三种数据管理方式的具体选择，需要结合实际情况进行考虑，其中的volumes数据卷是最常用也是官方推荐的数据管理方式。无论选择使用哪种数据管理方式，数据在容器内看起来都一样的，而在容器外则会被被挂载到文件系统中的某个目录或文件中。    
  下面通过一张图来展示数据卷、绑定挂载和tmpfs挂载之间的差异，如下图所示。  
![alt](/article_img/docker/8.png)
  从图中可以看出，Docker提供的三种数据管理方式略有不同，具体分析如下。  
  ●volumes：存储在主机文件系统中（在Linux系统下是存在于/var/lib/Docker/volumes/目录），并由Docker管理，非Docker进程无法修改文件系统的这个部分。  
  ●bind mounts：可以存储在主机系统的任意位置，甚至可能是重要的系统文件或目录，在Docker主机或容器上的非Docker进程可以对他们进行任意修改。  
  ●tmpfs mounts：只存储在主机系统的内存中，并没有写入到主机的文件系统中。


, 2018-12-07, 2021-05-19, 默认分类, Docker,数据管理, true, null, 19, 1]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [6, JDK 8——Lambda表达式介绍,   Lambda表达式是JDK 8中一个重要的新特性，它使用一个清晰简洁的表达式来表达一个接口，同时Lambda表达式也简化了对集合以及数组数据的遍历、过滤和提取等操作。下面，本篇文章就对Lambda表达式进行简要介绍，并进行演示说明。

**1. Lambda表达式入门**  

  匿名内部类存在的一个问题是，如果匿名内部类的实现非常简单，例如只包含一个抽象方法的接口，那么匿名内部类的语法仍然显得比较冗余。为此，JDK 8中新增了一个特性Lambda表达式，这种表达式只针对有一个抽象方法的接口实现，以简洁的表达式形式实现接口功能来作为方法参数。  
  一个Lambda表达式由三个部分组成，分别为参数列表、“->”和表达式主体，其语法格式如下：
```js
 ([数据类型 参数名,数据类型 参数名,...]) -> {表达式主体}
```  
  从上述语法格式上看，Lambda表达式的书写非常简单，下面针对Lambda表达式的组成部分进行简单介绍，具体如下：  
  （1）([数据类型 参数名,数据类型 参数名,...])：用来向表达式主体传递接口方法需要的参数，多个参数名中间必须用英文逗号“,”进行分隔；在编写Lambda表达式时，可以省略参数的数据类型，后面的表达式主体会自动进行校对和匹配；同时，如果只有一个参数，则可以省略括号“()”。  
  （2）->：表示Lambda表达式箭牌，用来指定参数数据指向，不能省略，且必须用英文横线和大于号书写。  
  （3）{表达式主体}：由单个表达式或语句块组成的主体，本质就是接口中抽象方法的具体实现，如果表达式主体只有一条语句，那么可以省略包含主体的大括号；另外，在Lambda表达式主体中允许有返回值，当只有一条return语句时，也可以省略return关键字。  
  了解了Lambda表达式的语法后，接下来编写一个示例文件对Lambda表达式的基本使用进行介绍，具体代码如下所示。
```js
 1	// 定义动物类接口
 2	interface Animal { 
 3		void shout(); // 定义方法shout()
 4	}
 5	public class Example22 {
 6		public static void main(String[] args) {
 7	       String name = "小花"; 
 8	       // 1、匿名内部类作为参数传递给animalShout()方法
 9		  animalShout(new Animal() { 
 10				 public void shout() { 
 11				    System.out.println("匿名内部类输出："+name+"喵喵...");
 12				}
 13		  });
 14		  // 2、使用Lambda表达式作为参数传递给animalShout()方法
 15	       animalShout(()-> System.out.println("Lambda表达式输出："
 16	                                                   +name+"喵喵..."));
 17		}
 18	    // 创建一个animalShout()静态方法，接收接口类型的参数
 19		public static void animalShout(Animal an) {
 20			an.shout();  
 21		}
 22	}
```  
  运行结果下图所示。
![alt](/article_img/lambda/1.jpg)
  上述代码示例中，先定义了只有一个抽象方法的接口Animal，然后分别使用匿名内部类和Lambda表达式的方式实现了接口方法。从图中可以看出，使用匿名内部类和Lambda表达式都能实现接口中方法，但很显然使用Lambda表达式更加简洁和清晰。, 2018-11-27, null, 默认分类, 2018,Lambda表达式, true, null, 18, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [7, 函数式接口, &emsp;&emsp;虽然Lambda表达式可以实现匿名内部类的功能，但在使用时却有一个局限，即接口中有且只有一个抽象方法时才能使用Lamdba表达式代替匿名内部类。这是因为Lamdba表达式是基于函数式接口实现的，所谓函数式接口是指有且仅有一个抽象方法的接口，Lambda表达式就是Java中函数式编程的体现，只有确保接口中有且仅有一个抽象方法，Lambda表达式才能顺利地推导出所实现的这个接口中的方法。  
&emsp;&emsp;在JDK 8中，专门为函数式接口引入了一个@FunctionalInterface注解，该注解只是显示的标注了接口是一个函数式接口，并强制编辑器进行更严格的检查，确保该接口是函数式接口，如果不是函数式接口，那么编译器就会报错，而对程序运行并没有实质上的影响。  
&emsp;&emsp;接下来通过一个案例来演示函数式接口的定义与使用，示例代码如下所示。
```js
 1	// 定义无参、无返回值的函数式接口
 2	@FunctionalInterface
 3	interface Animal {
 4		void shout();
 5	}
 6	// 定义有参、有返回值的函数式接口
 7	interface Calculate {
 8		int sum(int a, int b);
 9	}
 10	public class Example23 {
 11		public static void main(String[] args) {
 12		   // 分别两个函数式接口进行测试
 13		   animalShout(() -> System.out.println("无参、无返回值的函数式接口调用"));
 14		   showSum(10, 20, (x, y) -> x + y);
 15		}
 16		// 创建一个动物叫的方法，并传入接口对象Animal作为参数
 17		private static void animalShout(Animal animal) {
 18			animal.shout();
 19		}
 20		// 创建一个求和的方法，并传入两个int类型以及接口Calculate类型的参数
 21		private static void showSum(int x, int y, Calculate calculate) {
 22		   System.out.println(x + "+" + y + "的和为：" + calculate.sum(x, y));
 23		}
 24	}
```  
&emsp;&emsp;运行结果如下图所示。

![alt](/article_img/lambda/2.jpg)
&emsp;&emsp;上述代码示例中，先定义了两个函数式接口Animal和Calculate，然后在测试类中分别编写了两个静态方法，并将这两个函数式接口以参数的形式传入，最后在main()方法中分别调用这两个静态方法，并将所需要的函数式接口参数以Lambda表达式的形式传入。从图中可以看出，程序中函数式接口的定义和使用完全正确。
, 2018-12-01, null, 默认分类, 接口,函数式接口, true, null, 12, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} closed
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20002} closed
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} connected
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20000} created. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20000} Parameters : []
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20000} Types : []
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20000} executed. 45.0486 millis. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} open
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Header: [count(0)]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [12]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} closed
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20000} closed
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20001} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20001} Parameters : [5]
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20001} Types : [INTEGER]
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20001} executed. 1.9767 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} open
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} closed
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20001} closed
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20002} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20002} Parameters : []
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20002} Types : []
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20002} executed. 2.7712 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} open
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [12, Spring Boot 2 权威发布,   如果这两天登录 [https://start.spring.io/ ](https://start.spring.io/ )就会发现，Spring Boot 默认版本已经升到了 2.1.0。这是因为 Spring Boot 刚刚发布了 2.1.0 版本，我们来看下 Spring Boot 2 发布以来第一个子版本都发布了哪些内容？  

**2.1 中的新特性**     
  ●将spring-boot-starter-oauth2-oidc-client重命名为spring-boot-starter-oauth2-client命名更简洁  
  ●添加 OAuth2 资源服务 starter，OAuth2 一个用于认证的组件  
  ●支持 ConditionalOnBean 和 ConditionalOnMissingBean 下的参数化容器  
  ●自动配置 applicationTaskExecutor bean 的延迟加载来避免不必要的日志记录  
  ●将 DatabaseDriver＃SAP 重命名为 DatabaseDriver  
  ●跳过重启器不仅适用于 JUnit4，也适用于 JUnit5  
  ●在 Jest HealthIndicator 中使用集群端点  
  ●当 DevTools 禁用重启时添加日志输出  
  ●添加注解：@ConditionalOnMissingServletFilter提高 Servlet Filters 的自动装配。
  
**2.1 中的组件升级**  
  ●升级 Hibernate 5.3，Hibernate 的支持升级到了 5.3  
  ●升级 Tomcat 9 ，支持最新的 tomcat 9  
  ●支持 Java 11，Java 现在更新越来越快，Spring 快赶不上了    
  ●升级 Thymeleaf Extras Springsecurity 到 3.0.4.RELEASE ，thymeleaf-extras-springsecurity 是 Thymeleaf 提供集成 Spring Security 的组件  
  ●升级 Joda Time 2.10.1，Joda-Time， 面向 Java 应用程序的日期/时间库的替代选择，Joda-Time 令时间和日期值变得易于管理、操作和理解。  
  ●升级 Lettuce 5.1.2.RELEASE ，Lettuce 前面说过，传说中 Redis 最快的客户端。  
  ●升级 Reactor Californium-SR2 ，Californium 是物联网云服务的 Java COAP 实现。因此，它更专注的是可扩展性和可用性而不是像嵌入式设备那样关注资源效率。不过，Californium 也适合嵌入式的 JVM。  
  ●升级 Maven Failsafe Plugin 2.22.1 ，Maven 中的测试插件。  
  ●升级 Flyway 5.2.1 ， Flyway是一款开源的数据库版本管理工具  
  ●升级 Aspectj 1.9.2 ，AspectJ 是 Java 中流行的 AOP（Aspect-oriented Programming）编程扩展框架，是 Eclipse 托管给 Apache 基金会的一个开源项目。  
  ●升级 Mysql 8.0.13 ，Mysql 支持到 8。  
  ●...  
  更多的详细内容可以参考这里：[Spring Boot 2.1 Release Notes](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.1-Release-Notes)
, 2018-12-12, 2021-05-22, 默认分类, Spring Boot 2, true, null, 62, 1]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [8, JDK 8——聚合操作, &emsp;&emsp;在Java8版本中，JDK包含许多聚合操作（如平均值，总和，最小，最大，和计数），返回一个计算流stream的聚合结果。这些聚合操作被称为聚合操作。JDK除返回单个值的聚合操作外，还有很多聚合操作返回一个collection集合实例。很多的reduce操作执行特定的任务，如求平均值或按类别分组元素。  

**1. 聚合操作简介**

  在开发中，多数情况下会涉及到对集合、数组中元素的操作，在JDK 8之前都是通过普通的循环遍历出每一个元素，然后还会穿插一些if条件语句选择性的对元素进行查找、过滤、修改等操作，这种原始的操作方法虽然可行，但是代码量较大并且执行效率较低。  
  为此，JDK 8中新增了一个Stream接口，该接口可以将集合、数组的中的元素转换为Stream流的形式，并结合Lambda表达式的优势来进一步简化集合、数组中元素的查找、过滤、转换等操作，这一新功能就是JDK 8中的聚合操作。  
  在程序中，使用聚合操作没有绝对的语法规范，根据实际操作流程，主要可以分为以下3个步骤：  
  （1）将原始集合或者数组对象转换为Stream流对象；  
  （2）对Stream流对象中的元素进行一系列的过滤、查找等中间操作（Intermediate Operations），然后仍然返回一个Stream流对象；  
  （3）对Stream流进行遍历、统计、收集等终结操作（Terminal Operation），获取想要的结果。  
  接下来，就根据上面聚合操作的3个步骤，通过一个案例来演示聚合操作的基本用法，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example31 {
 4		public static void main(String[] args) {
 5	          // 创建一个List集合对象
 6			List<String> list = new ArrayList<>(); 
 7			list.add("张三");
 8			list.add("李四");
 9			list.add("张小明");
 10			list.add("张阳");
 11			// 1、创建一个Stream流对象
 12			Stream<String> stream = list.stream();
 13			// 2、对Stream流中的元素分别进行过滤、截取操作
 14		       Stream<String> stream2 = stream.filter(i -> i.startsWith("张"));
 15			Stream<String> stream3 = stream2.limit(2);
 16			// 3、对Stream流中的元素进行终结操作，进行遍历输出
 17			stream3.forEach(j -> System.out.println(j));
 18			System.out.println("=======");
 19	         // 通过链式表达式的形式完成聚合操作
 20			list.stream().filter(i -> i.startsWith("张"))
 21						 .limit(2)
 22						 .forEach(j -> System.out.println(j));
 23		}
 24	}
``` 
   运行结果如下图所示。
![alt](/article_img/lambda/3.jpg)
  上述示例代码中，先创建了一个List集合，然后根据聚合操作的3个步骤实现了集合对象的聚合操作，对集合中的元素使用Stream流的形式进行过滤（filter）、截取（limit），并进行遍历输出。其中第12~17行代码分步骤详细展示了聚合操作，而第20~22行代码是使用了链式表达式（调用有返回值的方法时不获取返回值而是直接再调用另一个方法）实现了聚合操作，该表达式的语法格式更简洁、高效，这种链式调用也被称为操作管道流。

**2. 创建Stream流对象**  
  在上一小节中，介绍了聚合操作的主要使用步骤，其中首要解决的问题就是创建Stream流对象。聚合操作针对的就是可迭代数据进行的操作，如集合、数组等，所以创建Stream流对象其实就是将集合、数组等通过一些方法转换为Stream流对象。  
  在Java中，集合对象有对应的集合类，可以通过集合类提供的静态方法创建Stream流对象，而数组数据却没有对应的数组类，所以必须通过其他方法创建Stream流对象。针对不同的源数据，Java提供了多种创建Stream流对象的方式，分别如下：  
  （1）所有的Collections集合都可以使用stream()静态方法获取Stream流对象；  
  （2）Stream接口的of()静态方法可以获取基本类型包装类数组、引用类型数组和单个元素的Stream流对象；  
  （3）Arrays数组工具类的stream()静态方法也可以获取数组元素的Stream流对象。  
  接下来，通过一个案例来学习聚合操作中如何创建Stream流对象，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example32 {
 4		public static void main(String[] args) {
 5	          // 创建一个数组
 6			Integer[] array = { 9, 8, 3, 5, 2 };       
 7	          // 将数组转换为List集合
 8			List<Integer> list = Arrays.asList(array); 
 9			// 1、使用集合对象的stream()静态方法创建Stream流对象
 10			Stream<Integer> stream = list.stream();
 11			stream.forEach(i -> System.out.print(i+" "));
 12			System.out.println();
 13			// 2、使用Stream接口的of()静态方法创建Stream流对象
 14			Stream<Integer> stream2 = Stream.of(array);
 15			stream2.forEach(i -> System.out.print(i+" "));
 16			System.out.println();
 17			// 3、使用Arrays数组工具类的stream()静态方法创建Stream流对象
 18			Stream<Integer> stream3 = Arrays.stream(array);
 19			stream3.forEach(i -> System.out.print(i+" "));
 20		}
 21	}
```  
  运行结果如下图所示。
![alt](/article_img/lambda/4.jpg)
  上述示例代码中，先创建了一个数组和一个集合，然后通过三种方式实现了Stream流对象的创建，并通过Stream流对象的forEach()方法结合Lambda表达式完成了集合和数组中元素的遍历。  

**小提示：**  
  在JDK 8中，只针对单列集合Collections接口对象提供了stream()静态方法获取Stream流对象，并未对Map集合提供相关方法获取Stream流对象，所以想要用Map集合创建Stream流对象必须先通过Map集合的keySet()、values()、entrySet()等方法将Map集合转换为单列Set集合，然后再使用单列集合的stream()静态方法获取对应键、值集合的Stream流对象。

, 2018-12-02, null, 默认分类, JDK 8,聚合操作, true, null, 36, 1]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [9, 虚拟化容器技术——Docker运行机制介绍,   Docker是一个开源的应用容器引擎，它基于go语言开发，并遵从Apache2.0开源协议。使用Docker可以让开发者封装他们的应用以及依赖包到一个可移植的容器中，然后发布到任意的Linux机器上，也可以实现虚拟化。Docker容器完全使用沙箱机制，相互之间不会有任何接口，这保证了容器之间的安全性。  

**1. Docker的引擎介绍**

  Docker Engine（Docker引擎）是Docker的核心部分，使用的是客户端-服务器（C/S）架构模式，其主要组成部分如下图所示。
![alt](/article_img/docker/1.png)
  从上图可以看出，Docker Engine中包含了三个核心组件（docker CLI、REST API和docker daemon），这三个组件的具体说明如下：  
  ①docker CLI（command line interface）：表示Docker命令行接口，开发者可以在命令行中使用Docker相关指令与Docker守护进程进行交互，从而管理诸如image（镜像）、container（容器）、network（网络）和data volumes（数据卷）等实体。  
  ②REST API：表示应用程序API接口，开发者通过该API接口可以与Docker的守护进程进行交互，从而指示后台进行相关操作。  
  ③docker daemon：表示Docker的服务端组件，他是Docker架构中运行在后台的一个守护进程，可以接收并处理来自命令行接口及API接口的指令，然后进行相应的后台操作。  
  对于开发者而言，既可以使用编写好的脚本文件通过REST API来实现与Docker进程交互，又可以直接使用Docker相关指令通过命令行接口来与Docker进程交互，而其他一些Docker应用则是通过底层的API和CLI进行交互的。

**2. Docker的架构介绍**

  了解了Docker内部引擎及作用后，我们还需要通过Docker的具体架构，来了解Docker的整个运行流程。接下来借助Docker官网的架构图来对Docker架构进行详细说明，如下图所示。
![alt](/article_img/docker/2.jpg)
  从图中可以看出，Docker架构主要包括Client、DOCKER_HOST和Register三部分，关于这三部分的具体说明如下。  
&emsp;&emsp;**（1）Client（客户端）**  
  Client即Docker客户端，也就是上一小节Docker Engine中介绍的docker CLI。开发者通过这个客户端使用Docker的相关指令与Docker守护进程进行交互，从而进行Docker镜像的创建、拉取和运行等操作。  
&emsp;&emsp;**（2）DOCKER_HOST（Docker主机）**  
  DOCKER_HOST即Docker内部引擎运行的主机，主要指Docker daemon（Docker守护进程）。可以通过Docker守护进程与客户端还有Docker的镜像仓库Registry进行交互，从而管理Images（镜像）和Containers（容器）等。  
&emsp;&emsp;**（3）Registry（注册中心）**  
  Registry即Docker注册中心，实质就是Docker镜像仓库，默认使用的是Docker官方远程注册中心Docker Hub，也可以使用开发者搭建的本地仓库。Registry中包含了大量的镜像，这些镜像可以是官网基础镜像，也可以是其他开发者上传的镜像。  
  我们在实际使用Docker时，除了会涉及到图中的三个主要部分外，还会涉及到很多Docker Objects（Docker对象），例如Images（镜像）、Containers（容器）、Networks（网络）、Volumes（数据卷）、Plugins（插件）等。其中常用的两个对象Image和Containers的说明如下。  
  ①Images（镜像）  
  Docker 镜像就是一个只读的模板，包含了一些创建Docker容器的操作指令。通常情况下，一个Docker镜像是基于另一个基础镜像创建的，并且新创建的镜像会额外包含一些功能配置。例如：开发者可以依赖于一个Ubuntu的基础镜像创建一个新镜像，并可以在新镜像中安装Apache等软件或其它应用程序。  
  ②Containers（容器）  
  Docker容器属于镜像的一个可运行实例（镜像与容器的关系其实与Java中的类与对象相似），开发者可以通过API接口或者CLI命令行接口来创建、运行、停止、移动、删除一个容器，也可以将一个容器连接到一个或多个网络中，将数据存储与容器进行关联。



, 2018-12-03, null, 默认分类, 虚拟化容器,Docker,运行机制, true, null, 26, 1]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [10, Docker常用客户端指令介绍,   在使用Docker之前，首先会为对应的项目编写Dockerfile镜像构建文件，然后通过Docker的相关指令进行镜像构建，完成镜像的构建后，就可以使用这些项目镜像进行启动测试了。所以要想知道如何使用Docker来执行这些Dockerfile镜像构建文件，还需要学习Docker客户端的常用指令，本篇文章将对Docker客户端的常用指令进行详细讲解。  

**1.列出镜像**  
  通过docker images指令可以查看本地镜像列表中已有的镜像，具体使用方式如下。
```js
$ docker images
```  
  执行上述指令后，系统会将所有本地镜像都展示出来，如下图所示。
![alt](/article_img/docker/3.png)
  从图中可以看出，系统终端将本地镜像列表中的3个镜像分5列进行了展示，每一列的具体含义如下。  
  ●REPOSITORY：镜像名称。  
  ●TAG：镜像的参数，类似于版本号，默认是latest。  
  ●IMAGE ID：镜像ID，是唯一值。此处看到的是一个长度为12的字符串，实际上它是64位完整镜像ID的缩写形式。  
  ●CREATED：距今创建镜像的时间。  
  ●SIZE：镜像大小。    

**2.搜索镜像**  
  想知道在Docker Hub中包含了哪些镜像，除了可以登录Docker Hub，在官网中心进行查看外，还可以直接在Docker客户端进行查询。例如想要查询Ubuntu镜像，可以使用如下指令。
```js
$ docker search ubuntu
```  
  执行上述指令后，系统终端就会将搜索到的有关Ubuntu的镜像展示出来，如下图所示。
![alt](/article_img/docker/4.png)
  从图所示的结果可以看出，系统终端分5列将搜索到的Ubuntu相关镜像都列举出来了，这5列的具体含义如下。  
  ●NAME：表示镜像的名称，这里有两种格式的名称，其中不带有“/”的表示官方镜像，而带有“/”的表示其他用户的公开镜像。公开镜像“/”前面是用户在Docker Hub上的用户名（唯一），后面是对应的镜像名；官方镜像与用户镜像，除了从镜像名称上可以区分外，还可以通过第4列的OFFICIAL声明中看出（该列下内容为OK表示官方镜像）。  
  ●DESCRIPTION：表示镜像的描述，这里只显示了一小部分。  
  ●STARS：表示该镜像的收藏数，用户可以在Docker Hub上对镜像进行收藏，一般可以通过该数字反应出该镜像的受欢迎程度。  
  ●OFFICIAL：表示是否为官方镜像。  
  ●AUTOMATED：表示是否自动构建镜像。例如，用户可以将自己的Docker Hub绑定到如Github上，当代码提交更新后，可以自动构建镜像。   
 
**3.拉取镜像**  
  通过docker pull指令可以拉取仓库镜像到本地（默认都是拉取Docker Hub仓库镜像，也可以指定“IP+端口”拉取某个Docker机器上的私有仓库镜像），具体使用方式如下。
```js
$ docker pull ubuntu
```  
  执行上述指令后，Docker会自动从Docker Hub上下载最新版本的Ubuntu到本地，当然也可以使用以下指令拉取指定版本的镜像到本地，具体指令如下。
```js
$ docker pull ubuntu:14.04
```  
**4.构建镜像**  
  除了可以通过docker pull指令从仓库拉取镜像外，还可以通过docker build指令构建Docker镜像，通常情况下都是通过Dockerfile文件来构建镜像的。  
  这里假设linux系统home目录下/shitou/workspace/dockerspace文件夹中编写有对应的Dockerfile文件，则构建镜像直立示例如下所示。 
```js
$ docker build -t hellodocker3 /home/shitou/workspace/dockerspace/.
```
**5.删除镜像**  
  当本地存放过多不需要的镜像时，可以通过docker rmi指令将其删除。在删除镜像时，需要指定镜像名称或镜像ID。删除镜像的使用方式如下。
```js
$ docker rmi -f hellodocker2 hellodocker3
```  
  上述指令中，docker rmi表示删除镜像，-f表示进行强制删除，而hellodocker2和hellodocker3分别表示需要删除的镜像名称，这里同时删除两个镜像。除了根据名称删除镜像外，还也可以根据镜像ID来删除镜像，只是这里如果指定了删除ID为23c617a866d4的镜像后，会同时删除hellodocker、hellodocker2和hellodocker3三个镜像。  
  需要特别强调的是，在进行镜像删除操作时，如果是通过镜像ID进行镜像删除，那么由该镜像创建的容器必须提前删除或停止。另外，在通过镜像名称操作镜像时，如果出现镜像重名的情况，必须在镜像名称后面指定镜像标签tag参数来确保唯一性。

**6.创建并启动容器**  
  Docker镜像主要用于创建容器，可以使用docker run指令创建并启动容器，具体使用方式如下。
```js
$ docker run -d -p 5000:80 --name test hellodocker
```  
  上述创建并启动容器的指令略微复杂，具体分析如下。  
  ●docker run：表示创建并启动一个容器，而后面的hellodocker就表示要启动运行的镜像名称；  
  ●-d：表示容器启动时在后台运行；  
  ●-p 5000:80：表示将容器内暴露的80端口映射到宿主机指定的5000端口，也可以将-p 5000:80更改为-P来映射主机的随机端口（注意p字母的大小写）；  
  ●--name test：表示为创建后的容器指定名称为test，如果没有该参数配置，则生成的容器会设置一个随机名称。  
  docker run命令是Docker操作中较为复杂的一个，它可以携带多个参数和参数，我们可以通过docker run --help指令进行查看，其中有些参数如-e、-v和-w等都可以在Dockerfile文件中预先声明。 
 
**7.列出容器**  
  生成容器后，可以通过docker ps指令查看当前运行的所有容器，具体使用方式如下。
```js
$ docker ps
```  
  执行上述命令后，会将所有当前运行的容器都展示出来，具体如下图所示。
![alt](/article_img/docker/5.png)
  从图中可以看出，系统终端通过7列对当前的正在运行的一个容器进行了展示，图中每一列的具体含义如下。  
  ●CONTAINER ID：表示生成的容器ID；  
  ●IMAGE：表示生成该容器的镜像名称；  
  ●COMMAND：表示启动容器时运行的命令，Docker要求在启动容器时必须运行一个命令；  
  ●CREATED：表示容器创建的时间；  
  ●STATUS：表示容器运行状态，例如Up表示运行中，Exited表示已停止；  
  ●PORTS：表示容器内部暴露的端口映射到主机的端口；  
  ●NAMES：表示生成容器的名称，由Docker引擎自动生成，可以像上述示例中使用--name参数指定生成容器的名称。  
  另外，docker ps指令运行过程中可以指定多个参数，还可以通过docker ps --help指令对ps指令的其他信息进行查看。

**8.删除容器**  
  当不需要使用容器时，则可以使用docker rm指令删除已停止的容器，具体使用方式如下。
```js
$ docker rm f0c9a8b6e8c5
```  
  需要注意的是，上述指令只能删除已经停止运行的容器，而不能删除正在运行的容器。如果想要删除正在运行的容器，则需要添加-f参数强制删除，具体使用方式如下。
```js
$ docker rm -f f0c9a8b6e8c5
```  
  当需要删除的容器过多时，如果还一个个的删除就略显麻烦了，此时可以通过如下指令将全部容器删除。
```js
$ docker rm -f $(docker ps -aq)
```  
  上述指令中，首先会通过$(docker ps -aq)获取所有容器的ID，然后通过docker rm -f指令进行强制删除。如果开发者有自己特殊的删除需求，可以根据前面docker ps指令进行组装来获取需要删除的容器ID。  
  Docker提供的操作指令远不止这些，这里就不一一列举了，想要了解更多Docker的操作指令，可以通过docker --help指令进行查看。


, 2018-12-05, null, 默认分类, Docker,客户端指令, true, null, 21, 1]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [11, Docker数据管理介绍,   当我们对容器进行相关操作时，产生的一系列数据都会存储在容器中，而Docker内部又是如果管理这些数据的呢？本篇文章将针对Docker数据管理的一些知识进行介绍。
  
**1. Docker数据存储机制**  
  使用Docker时，我们操作的都是镜像和由镜像生成的容器，所以想要更好的了解Docker内部的数据存储机制，就必须从镜像、容器与数据存储的关系出发。  
  Docker镜像是通过读取Dockerfile文件中的指令构建的，Dockerfile中的每条指令都会创建一个镜像层，并且每层都是只读的，这一系列的镜像层就构成了Docker镜像。接下来以一个Dockerfile文件为例进行说明，具体如下列代码示例所示。
```js
 1	FROM ubuntu:16.04
 2	COPY . /app
 3	RUN make /app
 4	CMD python /app/app.py
```  
   上述文件示例中的Dockerfile包含了4条指令，每条指令都会创建一个镜像层，其中每一层与前一层都有所不同，并且是层层叠加的。通过镜像构建容器时，会在镜像层上增加一个容器层（即可写层），所有对容器的更改都会写入容器层，这也是Docker默认的数据存储方式。  
  下面通过一个效果图进行说明，具体如下图所示。
![alt](/article_img/docker/6.png)
  从图中可以看出，Docker容器和镜像之间的主要区别是顶部的容器层，而所有对容器中数据的添加、修改等操作都会被存储在容器层中。当容器被删除时，容器层也会被删除，其中存储的数据会被一同删除，而下面的镜像层却保持不变。  
  由于所有的容器都是通过镜像构建的，所以每个容器都有各自的容器层，对于容器数据的更改就会保存在各自的容器层中。也就是说，由同一个镜像构建的多个容器，它们会拥有相同的底部镜像层，而拥有不同的容器层，多个容器可以访问相同的镜像层，并且有自己的独立数据状态。具体说明如下图所示。 
![alt](/article_img/docker/7.png)
  从图中可以看出，基于同一个镜像构建的多个容器可以共享该镜像层，但是多个容器想要共享相同的数据，就需要将这些数据存储到容器之外的地方，而这种方式就是下一节要提到的Docker volume数据外部挂载机制。  

**2. Docker数据存储方式**    
  在默认情况下，Docker中的数据都是存放在容器层的，但是这样存储数据却有较多的缺陷，具体表现如下。    
  ●当容器不再运行时，容器中的数据无法持久化保存，如果另一个进程需要这些数据，那么将很难从容器中获取数据；  
  ●容器层与正在运行的主机紧密耦合，不能轻易地移动数据；  
  ●容器层需要一个存储驱动程序来管理文件系统，存储驱动程序提供了一个使用Linux内核的联合文件系统，这种额外的抽象化降低了性能。  
  基于上述种种原因，多数情况下Docker数据管理都不会直接将数据写入容器层，而是使用另一种叫做Docker volume数据外部挂载的机制进行数据管理。  
  针对Docker volume数据外部挂载机制，Docker提供了三种不同的方式将数据从容器映射到Docker宿主机，他们分别为：volumes（数据卷）、bind mounts（绑定挂载）和tmpfs mounts（tmpfs挂载）。这三种数据管理方式的具体选择，需要结合实际情况进行考虑，其中的volumes数据卷是最常用也是官方推荐的数据管理方式。无论选择使用哪种数据管理方式，数据在容器内看起来都一样的，而在容器外则会被被挂载到文件系统中的某个目录或文件中。    
  下面通过一张图来展示数据卷、绑定挂载和tmpfs挂载之间的差异，如下图所示。  
![alt](/article_img/docker/8.png)
  从图中可以看出，Docker提供的三种数据管理方式略有不同，具体分析如下。  
  ●volumes：存储在主机文件系统中（在Linux系统下是存在于/var/lib/Docker/volumes/目录），并由Docker管理，非Docker进程无法修改文件系统的这个部分。  
  ●bind mounts：可以存储在主机系统的任意位置，甚至可能是重要的系统文件或目录，在Docker主机或容器上的非Docker进程可以对他们进行任意修改。  
  ●tmpfs mounts：只存储在主机系统的内存中，并没有写入到主机的文件系统中。


, 2018-12-07, 2021-05-19, 默认分类, Docker,数据管理, true, null, 19, 1]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [6, JDK 8——Lambda表达式介绍,   Lambda表达式是JDK 8中一个重要的新特性，它使用一个清晰简洁的表达式来表达一个接口，同时Lambda表达式也简化了对集合以及数组数据的遍历、过滤和提取等操作。下面，本篇文章就对Lambda表达式进行简要介绍，并进行演示说明。

**1. Lambda表达式入门**  

  匿名内部类存在的一个问题是，如果匿名内部类的实现非常简单，例如只包含一个抽象方法的接口，那么匿名内部类的语法仍然显得比较冗余。为此，JDK 8中新增了一个特性Lambda表达式，这种表达式只针对有一个抽象方法的接口实现，以简洁的表达式形式实现接口功能来作为方法参数。  
  一个Lambda表达式由三个部分组成，分别为参数列表、“->”和表达式主体，其语法格式如下：
```js
 ([数据类型 参数名,数据类型 参数名,...]) -> {表达式主体}
```  
  从上述语法格式上看，Lambda表达式的书写非常简单，下面针对Lambda表达式的组成部分进行简单介绍，具体如下：  
  （1）([数据类型 参数名,数据类型 参数名,...])：用来向表达式主体传递接口方法需要的参数，多个参数名中间必须用英文逗号“,”进行分隔；在编写Lambda表达式时，可以省略参数的数据类型，后面的表达式主体会自动进行校对和匹配；同时，如果只有一个参数，则可以省略括号“()”。  
  （2）->：表示Lambda表达式箭牌，用来指定参数数据指向，不能省略，且必须用英文横线和大于号书写。  
  （3）{表达式主体}：由单个表达式或语句块组成的主体，本质就是接口中抽象方法的具体实现，如果表达式主体只有一条语句，那么可以省略包含主体的大括号；另外，在Lambda表达式主体中允许有返回值，当只有一条return语句时，也可以省略return关键字。  
  了解了Lambda表达式的语法后，接下来编写一个示例文件对Lambda表达式的基本使用进行介绍，具体代码如下所示。
```js
 1	// 定义动物类接口
 2	interface Animal { 
 3		void shout(); // 定义方法shout()
 4	}
 5	public class Example22 {
 6		public static void main(String[] args) {
 7	       String name = "小花"; 
 8	       // 1、匿名内部类作为参数传递给animalShout()方法
 9		  animalShout(new Animal() { 
 10				 public void shout() { 
 11				    System.out.println("匿名内部类输出："+name+"喵喵...");
 12				}
 13		  });
 14		  // 2、使用Lambda表达式作为参数传递给animalShout()方法
 15	       animalShout(()-> System.out.println("Lambda表达式输出："
 16	                                                   +name+"喵喵..."));
 17		}
 18	    // 创建一个animalShout()静态方法，接收接口类型的参数
 19		public static void animalShout(Animal an) {
 20			an.shout();  
 21		}
 22	}
```  
  运行结果下图所示。
![alt](/article_img/lambda/1.jpg)
  上述代码示例中，先定义了只有一个抽象方法的接口Animal，然后分别使用匿名内部类和Lambda表达式的方式实现了接口方法。从图中可以看出，使用匿名内部类和Lambda表达式都能实现接口中方法，但很显然使用Lambda表达式更加简洁和清晰。, 2018-11-27, null, 默认分类, 2018,Lambda表达式, true, null, 18, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [7, 函数式接口, &emsp;&emsp;虽然Lambda表达式可以实现匿名内部类的功能，但在使用时却有一个局限，即接口中有且只有一个抽象方法时才能使用Lamdba表达式代替匿名内部类。这是因为Lamdba表达式是基于函数式接口实现的，所谓函数式接口是指有且仅有一个抽象方法的接口，Lambda表达式就是Java中函数式编程的体现，只有确保接口中有且仅有一个抽象方法，Lambda表达式才能顺利地推导出所实现的这个接口中的方法。  
&emsp;&emsp;在JDK 8中，专门为函数式接口引入了一个@FunctionalInterface注解，该注解只是显示的标注了接口是一个函数式接口，并强制编辑器进行更严格的检查，确保该接口是函数式接口，如果不是函数式接口，那么编译器就会报错，而对程序运行并没有实质上的影响。  
&emsp;&emsp;接下来通过一个案例来演示函数式接口的定义与使用，示例代码如下所示。
```js
 1	// 定义无参、无返回值的函数式接口
 2	@FunctionalInterface
 3	interface Animal {
 4		void shout();
 5	}
 6	// 定义有参、有返回值的函数式接口
 7	interface Calculate {
 8		int sum(int a, int b);
 9	}
 10	public class Example23 {
 11		public static void main(String[] args) {
 12		   // 分别两个函数式接口进行测试
 13		   animalShout(() -> System.out.println("无参、无返回值的函数式接口调用"));
 14		   showSum(10, 20, (x, y) -> x + y);
 15		}
 16		// 创建一个动物叫的方法，并传入接口对象Animal作为参数
 17		private static void animalShout(Animal animal) {
 18			animal.shout();
 19		}
 20		// 创建一个求和的方法，并传入两个int类型以及接口Calculate类型的参数
 21		private static void showSum(int x, int y, Calculate calculate) {
 22		   System.out.println(x + "+" + y + "的和为：" + calculate.sum(x, y));
 23		}
 24	}
```  
&emsp;&emsp;运行结果如下图所示。

![alt](/article_img/lambda/2.jpg)
&emsp;&emsp;上述代码示例中，先定义了两个函数式接口Animal和Calculate，然后在测试类中分别编写了两个静态方法，并将这两个函数式接口以参数的形式传入，最后在main()方法中分别调用这两个静态方法，并将所需要的函数式接口参数以Lambda表达式的形式传入。从图中可以看出，程序中函数式接口的定义和使用完全正确。
, 2018-12-01, null, 默认分类, 接口,函数式接口, true, null, 12, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} closed
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20002} closed
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} connected
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20000} created. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20000} Parameters : []
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20000} Types : []
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20000} executed. 36.1882 millis. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} open
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Header: [count(0)]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [12]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} closed
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20000} closed
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20001} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20001} Parameters : [5]
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20001} Types : [INTEGER]
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20001} executed. 1.9609 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} open
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} closed
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20001} closed
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20002} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20002} Parameters : []
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20002} Types : []
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20002} executed. 2.4883 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} open
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [12, Spring Boot 2 权威发布,   如果这两天登录 [https://start.spring.io/ ](https://start.spring.io/ )就会发现，Spring Boot 默认版本已经升到了 2.1.0。这是因为 Spring Boot 刚刚发布了 2.1.0 版本，我们来看下 Spring Boot 2 发布以来第一个子版本都发布了哪些内容？  

**2.1 中的新特性**     
  ●将spring-boot-starter-oauth2-oidc-client重命名为spring-boot-starter-oauth2-client命名更简洁  
  ●添加 OAuth2 资源服务 starter，OAuth2 一个用于认证的组件  
  ●支持 ConditionalOnBean 和 ConditionalOnMissingBean 下的参数化容器  
  ●自动配置 applicationTaskExecutor bean 的延迟加载来避免不必要的日志记录  
  ●将 DatabaseDriver＃SAP 重命名为 DatabaseDriver  
  ●跳过重启器不仅适用于 JUnit4，也适用于 JUnit5  
  ●在 Jest HealthIndicator 中使用集群端点  
  ●当 DevTools 禁用重启时添加日志输出  
  ●添加注解：@ConditionalOnMissingServletFilter提高 Servlet Filters 的自动装配。
  
**2.1 中的组件升级**  
  ●升级 Hibernate 5.3，Hibernate 的支持升级到了 5.3  
  ●升级 Tomcat 9 ，支持最新的 tomcat 9  
  ●支持 Java 11，Java 现在更新越来越快，Spring 快赶不上了    
  ●升级 Thymeleaf Extras Springsecurity 到 3.0.4.RELEASE ，thymeleaf-extras-springsecurity 是 Thymeleaf 提供集成 Spring Security 的组件  
  ●升级 Joda Time 2.10.1，Joda-Time， 面向 Java 应用程序的日期/时间库的替代选择，Joda-Time 令时间和日期值变得易于管理、操作和理解。  
  ●升级 Lettuce 5.1.2.RELEASE ，Lettuce 前面说过，传说中 Redis 最快的客户端。  
  ●升级 Reactor Californium-SR2 ，Californium 是物联网云服务的 Java COAP 实现。因此，它更专注的是可扩展性和可用性而不是像嵌入式设备那样关注资源效率。不过，Californium 也适合嵌入式的 JVM。  
  ●升级 Maven Failsafe Plugin 2.22.1 ，Maven 中的测试插件。  
  ●升级 Flyway 5.2.1 ， Flyway是一款开源的数据库版本管理工具  
  ●升级 Aspectj 1.9.2 ，AspectJ 是 Java 中流行的 AOP（Aspect-oriented Programming）编程扩展框架，是 Eclipse 托管给 Apache 基金会的一个开源项目。  
  ●升级 Mysql 8.0.13 ，Mysql 支持到 8。  
  ●...  
  更多的详细内容可以参考这里：[Spring Boot 2.1 Release Notes](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.1-Release-Notes)
, 2018-12-12, 2021-05-22, 默认分类, Spring Boot 2, true, null, 62, 1]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [8, JDK 8——聚合操作, &emsp;&emsp;在Java8版本中，JDK包含许多聚合操作（如平均值，总和，最小，最大，和计数），返回一个计算流stream的聚合结果。这些聚合操作被称为聚合操作。JDK除返回单个值的聚合操作外，还有很多聚合操作返回一个collection集合实例。很多的reduce操作执行特定的任务，如求平均值或按类别分组元素。  

**1. 聚合操作简介**

  在开发中，多数情况下会涉及到对集合、数组中元素的操作，在JDK 8之前都是通过普通的循环遍历出每一个元素，然后还会穿插一些if条件语句选择性的对元素进行查找、过滤、修改等操作，这种原始的操作方法虽然可行，但是代码量较大并且执行效率较低。  
  为此，JDK 8中新增了一个Stream接口，该接口可以将集合、数组的中的元素转换为Stream流的形式，并结合Lambda表达式的优势来进一步简化集合、数组中元素的查找、过滤、转换等操作，这一新功能就是JDK 8中的聚合操作。  
  在程序中，使用聚合操作没有绝对的语法规范，根据实际操作流程，主要可以分为以下3个步骤：  
  （1）将原始集合或者数组对象转换为Stream流对象；  
  （2）对Stream流对象中的元素进行一系列的过滤、查找等中间操作（Intermediate Operations），然后仍然返回一个Stream流对象；  
  （3）对Stream流进行遍历、统计、收集等终结操作（Terminal Operation），获取想要的结果。  
  接下来，就根据上面聚合操作的3个步骤，通过一个案例来演示聚合操作的基本用法，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example31 {
 4		public static void main(String[] args) {
 5	          // 创建一个List集合对象
 6			List<String> list = new ArrayList<>(); 
 7			list.add("张三");
 8			list.add("李四");
 9			list.add("张小明");
 10			list.add("张阳");
 11			// 1、创建一个Stream流对象
 12			Stream<String> stream = list.stream();
 13			// 2、对Stream流中的元素分别进行过滤、截取操作
 14		       Stream<String> stream2 = stream.filter(i -> i.startsWith("张"));
 15			Stream<String> stream3 = stream2.limit(2);
 16			// 3、对Stream流中的元素进行终结操作，进行遍历输出
 17			stream3.forEach(j -> System.out.println(j));
 18			System.out.println("=======");
 19	         // 通过链式表达式的形式完成聚合操作
 20			list.stream().filter(i -> i.startsWith("张"))
 21						 .limit(2)
 22						 .forEach(j -> System.out.println(j));
 23		}
 24	}
``` 
   运行结果如下图所示。
![alt](/article_img/lambda/3.jpg)
  上述示例代码中，先创建了一个List集合，然后根据聚合操作的3个步骤实现了集合对象的聚合操作，对集合中的元素使用Stream流的形式进行过滤（filter）、截取（limit），并进行遍历输出。其中第12~17行代码分步骤详细展示了聚合操作，而第20~22行代码是使用了链式表达式（调用有返回值的方法时不获取返回值而是直接再调用另一个方法）实现了聚合操作，该表达式的语法格式更简洁、高效，这种链式调用也被称为操作管道流。

**2. 创建Stream流对象**  
  在上一小节中，介绍了聚合操作的主要使用步骤，其中首要解决的问题就是创建Stream流对象。聚合操作针对的就是可迭代数据进行的操作，如集合、数组等，所以创建Stream流对象其实就是将集合、数组等通过一些方法转换为Stream流对象。  
  在Java中，集合对象有对应的集合类，可以通过集合类提供的静态方法创建Stream流对象，而数组数据却没有对应的数组类，所以必须通过其他方法创建Stream流对象。针对不同的源数据，Java提供了多种创建Stream流对象的方式，分别如下：  
  （1）所有的Collections集合都可以使用stream()静态方法获取Stream流对象；  
  （2）Stream接口的of()静态方法可以获取基本类型包装类数组、引用类型数组和单个元素的Stream流对象；  
  （3）Arrays数组工具类的stream()静态方法也可以获取数组元素的Stream流对象。  
  接下来，通过一个案例来学习聚合操作中如何创建Stream流对象，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example32 {
 4		public static void main(String[] args) {
 5	          // 创建一个数组
 6			Integer[] array = { 9, 8, 3, 5, 2 };       
 7	          // 将数组转换为List集合
 8			List<Integer> list = Arrays.asList(array); 
 9			// 1、使用集合对象的stream()静态方法创建Stream流对象
 10			Stream<Integer> stream = list.stream();
 11			stream.forEach(i -> System.out.print(i+" "));
 12			System.out.println();
 13			// 2、使用Stream接口的of()静态方法创建Stream流对象
 14			Stream<Integer> stream2 = Stream.of(array);
 15			stream2.forEach(i -> System.out.print(i+" "));
 16			System.out.println();
 17			// 3、使用Arrays数组工具类的stream()静态方法创建Stream流对象
 18			Stream<Integer> stream3 = Arrays.stream(array);
 19			stream3.forEach(i -> System.out.print(i+" "));
 20		}
 21	}
```  
  运行结果如下图所示。
![alt](/article_img/lambda/4.jpg)
  上述示例代码中，先创建了一个数组和一个集合，然后通过三种方式实现了Stream流对象的创建，并通过Stream流对象的forEach()方法结合Lambda表达式完成了集合和数组中元素的遍历。  

**小提示：**  
  在JDK 8中，只针对单列集合Collections接口对象提供了stream()静态方法获取Stream流对象，并未对Map集合提供相关方法获取Stream流对象，所以想要用Map集合创建Stream流对象必须先通过Map集合的keySet()、values()、entrySet()等方法将Map集合转换为单列Set集合，然后再使用单列集合的stream()静态方法获取对应键、值集合的Stream流对象。

, 2018-12-02, null, 默认分类, JDK 8,聚合操作, true, null, 36, 1]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [9, 虚拟化容器技术——Docker运行机制介绍,   Docker是一个开源的应用容器引擎，它基于go语言开发，并遵从Apache2.0开源协议。使用Docker可以让开发者封装他们的应用以及依赖包到一个可移植的容器中，然后发布到任意的Linux机器上，也可以实现虚拟化。Docker容器完全使用沙箱机制，相互之间不会有任何接口，这保证了容器之间的安全性。  

**1. Docker的引擎介绍**

  Docker Engine（Docker引擎）是Docker的核心部分，使用的是客户端-服务器（C/S）架构模式，其主要组成部分如下图所示。
![alt](/article_img/docker/1.png)
  从上图可以看出，Docker Engine中包含了三个核心组件（docker CLI、REST API和docker daemon），这三个组件的具体说明如下：  
  ①docker CLI（command line interface）：表示Docker命令行接口，开发者可以在命令行中使用Docker相关指令与Docker守护进程进行交互，从而管理诸如image（镜像）、container（容器）、network（网络）和data volumes（数据卷）等实体。  
  ②REST API：表示应用程序API接口，开发者通过该API接口可以与Docker的守护进程进行交互，从而指示后台进行相关操作。  
  ③docker daemon：表示Docker的服务端组件，他是Docker架构中运行在后台的一个守护进程，可以接收并处理来自命令行接口及API接口的指令，然后进行相应的后台操作。  
  对于开发者而言，既可以使用编写好的脚本文件通过REST API来实现与Docker进程交互，又可以直接使用Docker相关指令通过命令行接口来与Docker进程交互，而其他一些Docker应用则是通过底层的API和CLI进行交互的。

**2. Docker的架构介绍**

  了解了Docker内部引擎及作用后，我们还需要通过Docker的具体架构，来了解Docker的整个运行流程。接下来借助Docker官网的架构图来对Docker架构进行详细说明，如下图所示。
![alt](/article_img/docker/2.jpg)
  从图中可以看出，Docker架构主要包括Client、DOCKER_HOST和Register三部分，关于这三部分的具体说明如下。  
&emsp;&emsp;**（1）Client（客户端）**  
  Client即Docker客户端，也就是上一小节Docker Engine中介绍的docker CLI。开发者通过这个客户端使用Docker的相关指令与Docker守护进程进行交互，从而进行Docker镜像的创建、拉取和运行等操作。  
&emsp;&emsp;**（2）DOCKER_HOST（Docker主机）**  
  DOCKER_HOST即Docker内部引擎运行的主机，主要指Docker daemon（Docker守护进程）。可以通过Docker守护进程与客户端还有Docker的镜像仓库Registry进行交互，从而管理Images（镜像）和Containers（容器）等。  
&emsp;&emsp;**（3）Registry（注册中心）**  
  Registry即Docker注册中心，实质就是Docker镜像仓库，默认使用的是Docker官方远程注册中心Docker Hub，也可以使用开发者搭建的本地仓库。Registry中包含了大量的镜像，这些镜像可以是官网基础镜像，也可以是其他开发者上传的镜像。  
  我们在实际使用Docker时，除了会涉及到图中的三个主要部分外，还会涉及到很多Docker Objects（Docker对象），例如Images（镜像）、Containers（容器）、Networks（网络）、Volumes（数据卷）、Plugins（插件）等。其中常用的两个对象Image和Containers的说明如下。  
  ①Images（镜像）  
  Docker 镜像就是一个只读的模板，包含了一些创建Docker容器的操作指令。通常情况下，一个Docker镜像是基于另一个基础镜像创建的，并且新创建的镜像会额外包含一些功能配置。例如：开发者可以依赖于一个Ubuntu的基础镜像创建一个新镜像，并可以在新镜像中安装Apache等软件或其它应用程序。  
  ②Containers（容器）  
  Docker容器属于镜像的一个可运行实例（镜像与容器的关系其实与Java中的类与对象相似），开发者可以通过API接口或者CLI命令行接口来创建、运行、停止、移动、删除一个容器，也可以将一个容器连接到一个或多个网络中，将数据存储与容器进行关联。



, 2018-12-03, null, 默认分类, 虚拟化容器,Docker,运行机制, true, null, 26, 1]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [10, Docker常用客户端指令介绍,   在使用Docker之前，首先会为对应的项目编写Dockerfile镜像构建文件，然后通过Docker的相关指令进行镜像构建，完成镜像的构建后，就可以使用这些项目镜像进行启动测试了。所以要想知道如何使用Docker来执行这些Dockerfile镜像构建文件，还需要学习Docker客户端的常用指令，本篇文章将对Docker客户端的常用指令进行详细讲解。  

**1.列出镜像**  
  通过docker images指令可以查看本地镜像列表中已有的镜像，具体使用方式如下。
```js
$ docker images
```  
  执行上述指令后，系统会将所有本地镜像都展示出来，如下图所示。
![alt](/article_img/docker/3.png)
  从图中可以看出，系统终端将本地镜像列表中的3个镜像分5列进行了展示，每一列的具体含义如下。  
  ●REPOSITORY：镜像名称。  
  ●TAG：镜像的参数，类似于版本号，默认是latest。  
  ●IMAGE ID：镜像ID，是唯一值。此处看到的是一个长度为12的字符串，实际上它是64位完整镜像ID的缩写形式。  
  ●CREATED：距今创建镜像的时间。  
  ●SIZE：镜像大小。    

**2.搜索镜像**  
  想知道在Docker Hub中包含了哪些镜像，除了可以登录Docker Hub，在官网中心进行查看外，还可以直接在Docker客户端进行查询。例如想要查询Ubuntu镜像，可以使用如下指令。
```js
$ docker search ubuntu
```  
  执行上述指令后，系统终端就会将搜索到的有关Ubuntu的镜像展示出来，如下图所示。
![alt](/article_img/docker/4.png)
  从图所示的结果可以看出，系统终端分5列将搜索到的Ubuntu相关镜像都列举出来了，这5列的具体含义如下。  
  ●NAME：表示镜像的名称，这里有两种格式的名称，其中不带有“/”的表示官方镜像，而带有“/”的表示其他用户的公开镜像。公开镜像“/”前面是用户在Docker Hub上的用户名（唯一），后面是对应的镜像名；官方镜像与用户镜像，除了从镜像名称上可以区分外，还可以通过第4列的OFFICIAL声明中看出（该列下内容为OK表示官方镜像）。  
  ●DESCRIPTION：表示镜像的描述，这里只显示了一小部分。  
  ●STARS：表示该镜像的收藏数，用户可以在Docker Hub上对镜像进行收藏，一般可以通过该数字反应出该镜像的受欢迎程度。  
  ●OFFICIAL：表示是否为官方镜像。  
  ●AUTOMATED：表示是否自动构建镜像。例如，用户可以将自己的Docker Hub绑定到如Github上，当代码提交更新后，可以自动构建镜像。   
 
**3.拉取镜像**  
  通过docker pull指令可以拉取仓库镜像到本地（默认都是拉取Docker Hub仓库镜像，也可以指定“IP+端口”拉取某个Docker机器上的私有仓库镜像），具体使用方式如下。
```js
$ docker pull ubuntu
```  
  执行上述指令后，Docker会自动从Docker Hub上下载最新版本的Ubuntu到本地，当然也可以使用以下指令拉取指定版本的镜像到本地，具体指令如下。
```js
$ docker pull ubuntu:14.04
```  
**4.构建镜像**  
  除了可以通过docker pull指令从仓库拉取镜像外，还可以通过docker build指令构建Docker镜像，通常情况下都是通过Dockerfile文件来构建镜像的。  
  这里假设linux系统home目录下/shitou/workspace/dockerspace文件夹中编写有对应的Dockerfile文件，则构建镜像直立示例如下所示。 
```js
$ docker build -t hellodocker3 /home/shitou/workspace/dockerspace/.
```
**5.删除镜像**  
  当本地存放过多不需要的镜像时，可以通过docker rmi指令将其删除。在删除镜像时，需要指定镜像名称或镜像ID。删除镜像的使用方式如下。
```js
$ docker rmi -f hellodocker2 hellodocker3
```  
  上述指令中，docker rmi表示删除镜像，-f表示进行强制删除，而hellodocker2和hellodocker3分别表示需要删除的镜像名称，这里同时删除两个镜像。除了根据名称删除镜像外，还也可以根据镜像ID来删除镜像，只是这里如果指定了删除ID为23c617a866d4的镜像后，会同时删除hellodocker、hellodocker2和hellodocker3三个镜像。  
  需要特别强调的是，在进行镜像删除操作时，如果是通过镜像ID进行镜像删除，那么由该镜像创建的容器必须提前删除或停止。另外，在通过镜像名称操作镜像时，如果出现镜像重名的情况，必须在镜像名称后面指定镜像标签tag参数来确保唯一性。

**6.创建并启动容器**  
  Docker镜像主要用于创建容器，可以使用docker run指令创建并启动容器，具体使用方式如下。
```js
$ docker run -d -p 5000:80 --name test hellodocker
```  
  上述创建并启动容器的指令略微复杂，具体分析如下。  
  ●docker run：表示创建并启动一个容器，而后面的hellodocker就表示要启动运行的镜像名称；  
  ●-d：表示容器启动时在后台运行；  
  ●-p 5000:80：表示将容器内暴露的80端口映射到宿主机指定的5000端口，也可以将-p 5000:80更改为-P来映射主机的随机端口（注意p字母的大小写）；  
  ●--name test：表示为创建后的容器指定名称为test，如果没有该参数配置，则生成的容器会设置一个随机名称。  
  docker run命令是Docker操作中较为复杂的一个，它可以携带多个参数和参数，我们可以通过docker run --help指令进行查看，其中有些参数如-e、-v和-w等都可以在Dockerfile文件中预先声明。 
 
**7.列出容器**  
  生成容器后，可以通过docker ps指令查看当前运行的所有容器，具体使用方式如下。
```js
$ docker ps
```  
  执行上述命令后，会将所有当前运行的容器都展示出来，具体如下图所示。
![alt](/article_img/docker/5.png)
  从图中可以看出，系统终端通过7列对当前的正在运行的一个容器进行了展示，图中每一列的具体含义如下。  
  ●CONTAINER ID：表示生成的容器ID；  
  ●IMAGE：表示生成该容器的镜像名称；  
  ●COMMAND：表示启动容器时运行的命令，Docker要求在启动容器时必须运行一个命令；  
  ●CREATED：表示容器创建的时间；  
  ●STATUS：表示容器运行状态，例如Up表示运行中，Exited表示已停止；  
  ●PORTS：表示容器内部暴露的端口映射到主机的端口；  
  ●NAMES：表示生成容器的名称，由Docker引擎自动生成，可以像上述示例中使用--name参数指定生成容器的名称。  
  另外，docker ps指令运行过程中可以指定多个参数，还可以通过docker ps --help指令对ps指令的其他信息进行查看。

**8.删除容器**  
  当不需要使用容器时，则可以使用docker rm指令删除已停止的容器，具体使用方式如下。
```js
$ docker rm f0c9a8b6e8c5
```  
  需要注意的是，上述指令只能删除已经停止运行的容器，而不能删除正在运行的容器。如果想要删除正在运行的容器，则需要添加-f参数强制删除，具体使用方式如下。
```js
$ docker rm -f f0c9a8b6e8c5
```  
  当需要删除的容器过多时，如果还一个个的删除就略显麻烦了，此时可以通过如下指令将全部容器删除。
```js
$ docker rm -f $(docker ps -aq)
```  
  上述指令中，首先会通过$(docker ps -aq)获取所有容器的ID，然后通过docker rm -f指令进行强制删除。如果开发者有自己特殊的删除需求，可以根据前面docker ps指令进行组装来获取需要删除的容器ID。  
  Docker提供的操作指令远不止这些，这里就不一一列举了，想要了解更多Docker的操作指令，可以通过docker --help指令进行查看。


, 2018-12-05, null, 默认分类, Docker,客户端指令, true, null, 21, 1]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [11, Docker数据管理介绍,   当我们对容器进行相关操作时，产生的一系列数据都会存储在容器中，而Docker内部又是如果管理这些数据的呢？本篇文章将针对Docker数据管理的一些知识进行介绍。
  
**1. Docker数据存储机制**  
  使用Docker时，我们操作的都是镜像和由镜像生成的容器，所以想要更好的了解Docker内部的数据存储机制，就必须从镜像、容器与数据存储的关系出发。  
  Docker镜像是通过读取Dockerfile文件中的指令构建的，Dockerfile中的每条指令都会创建一个镜像层，并且每层都是只读的，这一系列的镜像层就构成了Docker镜像。接下来以一个Dockerfile文件为例进行说明，具体如下列代码示例所示。
```js
 1	FROM ubuntu:16.04
 2	COPY . /app
 3	RUN make /app
 4	CMD python /app/app.py
```  
   上述文件示例中的Dockerfile包含了4条指令，每条指令都会创建一个镜像层，其中每一层与前一层都有所不同，并且是层层叠加的。通过镜像构建容器时，会在镜像层上增加一个容器层（即可写层），所有对容器的更改都会写入容器层，这也是Docker默认的数据存储方式。  
  下面通过一个效果图进行说明，具体如下图所示。
![alt](/article_img/docker/6.png)
  从图中可以看出，Docker容器和镜像之间的主要区别是顶部的容器层，而所有对容器中数据的添加、修改等操作都会被存储在容器层中。当容器被删除时，容器层也会被删除，其中存储的数据会被一同删除，而下面的镜像层却保持不变。  
  由于所有的容器都是通过镜像构建的，所以每个容器都有各自的容器层，对于容器数据的更改就会保存在各自的容器层中。也就是说，由同一个镜像构建的多个容器，它们会拥有相同的底部镜像层，而拥有不同的容器层，多个容器可以访问相同的镜像层，并且有自己的独立数据状态。具体说明如下图所示。 
![alt](/article_img/docker/7.png)
  从图中可以看出，基于同一个镜像构建的多个容器可以共享该镜像层，但是多个容器想要共享相同的数据，就需要将这些数据存储到容器之外的地方，而这种方式就是下一节要提到的Docker volume数据外部挂载机制。  

**2. Docker数据存储方式**    
  在默认情况下，Docker中的数据都是存放在容器层的，但是这样存储数据却有较多的缺陷，具体表现如下。    
  ●当容器不再运行时，容器中的数据无法持久化保存，如果另一个进程需要这些数据，那么将很难从容器中获取数据；  
  ●容器层与正在运行的主机紧密耦合，不能轻易地移动数据；  
  ●容器层需要一个存储驱动程序来管理文件系统，存储驱动程序提供了一个使用Linux内核的联合文件系统，这种额外的抽象化降低了性能。  
  基于上述种种原因，多数情况下Docker数据管理都不会直接将数据写入容器层，而是使用另一种叫做Docker volume数据外部挂载的机制进行数据管理。  
  针对Docker volume数据外部挂载机制，Docker提供了三种不同的方式将数据从容器映射到Docker宿主机，他们分别为：volumes（数据卷）、bind mounts（绑定挂载）和tmpfs mounts（tmpfs挂载）。这三种数据管理方式的具体选择，需要结合实际情况进行考虑，其中的volumes数据卷是最常用也是官方推荐的数据管理方式。无论选择使用哪种数据管理方式，数据在容器内看起来都一样的，而在容器外则会被被挂载到文件系统中的某个目录或文件中。    
  下面通过一张图来展示数据卷、绑定挂载和tmpfs挂载之间的差异，如下图所示。  
![alt](/article_img/docker/8.png)
  从图中可以看出，Docker提供的三种数据管理方式略有不同，具体分析如下。  
  ●volumes：存储在主机文件系统中（在Linux系统下是存在于/var/lib/Docker/volumes/目录），并由Docker管理，非Docker进程无法修改文件系统的这个部分。  
  ●bind mounts：可以存储在主机系统的任意位置，甚至可能是重要的系统文件或目录，在Docker主机或容器上的非Docker进程可以对他们进行任意修改。  
  ●tmpfs mounts：只存储在主机系统的内存中，并没有写入到主机的文件系统中。


, 2018-12-07, 2021-05-19, 默认分类, Docker,数据管理, true, null, 19, 1]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [6, JDK 8——Lambda表达式介绍,   Lambda表达式是JDK 8中一个重要的新特性，它使用一个清晰简洁的表达式来表达一个接口，同时Lambda表达式也简化了对集合以及数组数据的遍历、过滤和提取等操作。下面，本篇文章就对Lambda表达式进行简要介绍，并进行演示说明。

**1. Lambda表达式入门**  

  匿名内部类存在的一个问题是，如果匿名内部类的实现非常简单，例如只包含一个抽象方法的接口，那么匿名内部类的语法仍然显得比较冗余。为此，JDK 8中新增了一个特性Lambda表达式，这种表达式只针对有一个抽象方法的接口实现，以简洁的表达式形式实现接口功能来作为方法参数。  
  一个Lambda表达式由三个部分组成，分别为参数列表、“->”和表达式主体，其语法格式如下：
```js
 ([数据类型 参数名,数据类型 参数名,...]) -> {表达式主体}
```  
  从上述语法格式上看，Lambda表达式的书写非常简单，下面针对Lambda表达式的组成部分进行简单介绍，具体如下：  
  （1）([数据类型 参数名,数据类型 参数名,...])：用来向表达式主体传递接口方法需要的参数，多个参数名中间必须用英文逗号“,”进行分隔；在编写Lambda表达式时，可以省略参数的数据类型，后面的表达式主体会自动进行校对和匹配；同时，如果只有一个参数，则可以省略括号“()”。  
  （2）->：表示Lambda表达式箭牌，用来指定参数数据指向，不能省略，且必须用英文横线和大于号书写。  
  （3）{表达式主体}：由单个表达式或语句块组成的主体，本质就是接口中抽象方法的具体实现，如果表达式主体只有一条语句，那么可以省略包含主体的大括号；另外，在Lambda表达式主体中允许有返回值，当只有一条return语句时，也可以省略return关键字。  
  了解了Lambda表达式的语法后，接下来编写一个示例文件对Lambda表达式的基本使用进行介绍，具体代码如下所示。
```js
 1	// 定义动物类接口
 2	interface Animal { 
 3		void shout(); // 定义方法shout()
 4	}
 5	public class Example22 {
 6		public static void main(String[] args) {
 7	       String name = "小花"; 
 8	       // 1、匿名内部类作为参数传递给animalShout()方法
 9		  animalShout(new Animal() { 
 10				 public void shout() { 
 11				    System.out.println("匿名内部类输出："+name+"喵喵...");
 12				}
 13		  });
 14		  // 2、使用Lambda表达式作为参数传递给animalShout()方法
 15	       animalShout(()-> System.out.println("Lambda表达式输出："
 16	                                                   +name+"喵喵..."));
 17		}
 18	    // 创建一个animalShout()静态方法，接收接口类型的参数
 19		public static void animalShout(Animal an) {
 20			an.shout();  
 21		}
 22	}
```  
  运行结果下图所示。
![alt](/article_img/lambda/1.jpg)
  上述代码示例中，先定义了只有一个抽象方法的接口Animal，然后分别使用匿名内部类和Lambda表达式的方式实现了接口方法。从图中可以看出，使用匿名内部类和Lambda表达式都能实现接口中方法，但很显然使用Lambda表达式更加简洁和清晰。, 2018-11-27, null, 默认分类, 2018,Lambda表达式, true, null, 18, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [7, 函数式接口, &emsp;&emsp;虽然Lambda表达式可以实现匿名内部类的功能，但在使用时却有一个局限，即接口中有且只有一个抽象方法时才能使用Lamdba表达式代替匿名内部类。这是因为Lamdba表达式是基于函数式接口实现的，所谓函数式接口是指有且仅有一个抽象方法的接口，Lambda表达式就是Java中函数式编程的体现，只有确保接口中有且仅有一个抽象方法，Lambda表达式才能顺利地推导出所实现的这个接口中的方法。  
&emsp;&emsp;在JDK 8中，专门为函数式接口引入了一个@FunctionalInterface注解，该注解只是显示的标注了接口是一个函数式接口，并强制编辑器进行更严格的检查，确保该接口是函数式接口，如果不是函数式接口，那么编译器就会报错，而对程序运行并没有实质上的影响。  
&emsp;&emsp;接下来通过一个案例来演示函数式接口的定义与使用，示例代码如下所示。
```js
 1	// 定义无参、无返回值的函数式接口
 2	@FunctionalInterface
 3	interface Animal {
 4		void shout();
 5	}
 6	// 定义有参、有返回值的函数式接口
 7	interface Calculate {
 8		int sum(int a, int b);
 9	}
 10	public class Example23 {
 11		public static void main(String[] args) {
 12		   // 分别两个函数式接口进行测试
 13		   animalShout(() -> System.out.println("无参、无返回值的函数式接口调用"));
 14		   showSum(10, 20, (x, y) -> x + y);
 15		}
 16		// 创建一个动物叫的方法，并传入接口对象Animal作为参数
 17		private static void animalShout(Animal animal) {
 18			animal.shout();
 19		}
 20		// 创建一个求和的方法，并传入两个int类型以及接口Calculate类型的参数
 21		private static void showSum(int x, int y, Calculate calculate) {
 22		   System.out.println(x + "+" + y + "的和为：" + calculate.sum(x, y));
 23		}
 24	}
```  
&emsp;&emsp;运行结果如下图所示。

![alt](/article_img/lambda/2.jpg)
&emsp;&emsp;上述代码示例中，先定义了两个函数式接口Animal和Calculate，然后在测试类中分别编写了两个静态方法，并将这两个函数式接口以参数的形式传入，最后在main()方法中分别调用这两个静态方法，并将所需要的函数式接口参数以Lambda表达式的形式传入。从图中可以看出，程序中函数式接口的定义和使用完全正确。
, 2018-12-01, null, 默认分类, 接口,函数式接口, true, null, 12, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} closed
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20002} closed
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} connected
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20000} created. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20000} Parameters : []
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20000} Types : []
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20000} executed. 10.3834 millis. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} open
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Header: [count(0)]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} Result: [12]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20000, rs-50000} closed
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20000} closed
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20001} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20001} Parameters : [5]
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20001} Types : [INTEGER]
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20001} executed. 1.2392 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} open
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20001, rs-50001} closed
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20001} closed
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20002} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20002} Parameters : []
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20002} Types : []
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20002} executed. 0.8939 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
	t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id
    ORDER BY
	t_statistic.hits DESC
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} open
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [12, Spring Boot 2 权威发布,   如果这两天登录 [https://start.spring.io/ ](https://start.spring.io/ )就会发现，Spring Boot 默认版本已经升到了 2.1.0。这是因为 Spring Boot 刚刚发布了 2.1.0 版本，我们来看下 Spring Boot 2 发布以来第一个子版本都发布了哪些内容？  

**2.1 中的新特性**     
  ●将spring-boot-starter-oauth2-oidc-client重命名为spring-boot-starter-oauth2-client命名更简洁  
  ●添加 OAuth2 资源服务 starter，OAuth2 一个用于认证的组件  
  ●支持 ConditionalOnBean 和 ConditionalOnMissingBean 下的参数化容器  
  ●自动配置 applicationTaskExecutor bean 的延迟加载来避免不必要的日志记录  
  ●将 DatabaseDriver＃SAP 重命名为 DatabaseDriver  
  ●跳过重启器不仅适用于 JUnit4，也适用于 JUnit5  
  ●在 Jest HealthIndicator 中使用集群端点  
  ●当 DevTools 禁用重启时添加日志输出  
  ●添加注解：@ConditionalOnMissingServletFilter提高 Servlet Filters 的自动装配。
  
**2.1 中的组件升级**  
  ●升级 Hibernate 5.3，Hibernate 的支持升级到了 5.3  
  ●升级 Tomcat 9 ，支持最新的 tomcat 9  
  ●支持 Java 11，Java 现在更新越来越快，Spring 快赶不上了    
  ●升级 Thymeleaf Extras Springsecurity 到 3.0.4.RELEASE ，thymeleaf-extras-springsecurity 是 Thymeleaf 提供集成 Spring Security 的组件  
  ●升级 Joda Time 2.10.1，Joda-Time， 面向 Java 应用程序的日期/时间库的替代选择，Joda-Time 令时间和日期值变得易于管理、操作和理解。  
  ●升级 Lettuce 5.1.2.RELEASE ，Lettuce 前面说过，传说中 Redis 最快的客户端。  
  ●升级 Reactor Californium-SR2 ，Californium 是物联网云服务的 Java COAP 实现。因此，它更专注的是可扩展性和可用性而不是像嵌入式设备那样关注资源效率。不过，Californium 也适合嵌入式的 JVM。  
  ●升级 Maven Failsafe Plugin 2.22.1 ，Maven 中的测试插件。  
  ●升级 Flyway 5.2.1 ， Flyway是一款开源的数据库版本管理工具  
  ●升级 Aspectj 1.9.2 ，AspectJ 是 Java 中流行的 AOP（Aspect-oriented Programming）编程扩展框架，是 Eclipse 托管给 Apache 基金会的一个开源项目。  
  ●升级 Mysql 8.0.13 ，Mysql 支持到 8。  
  ●...  
  更多的详细内容可以参考这里：[Spring Boot 2.1 Release Notes](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.1-Release-Notes)
, 2018-12-12, 2021-05-22, 默认分类, Spring Boot 2, true, null, 62, 1]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [8, JDK 8——聚合操作, &emsp;&emsp;在Java8版本中，JDK包含许多聚合操作（如平均值，总和，最小，最大，和计数），返回一个计算流stream的聚合结果。这些聚合操作被称为聚合操作。JDK除返回单个值的聚合操作外，还有很多聚合操作返回一个collection集合实例。很多的reduce操作执行特定的任务，如求平均值或按类别分组元素。  

**1. 聚合操作简介**

  在开发中，多数情况下会涉及到对集合、数组中元素的操作，在JDK 8之前都是通过普通的循环遍历出每一个元素，然后还会穿插一些if条件语句选择性的对元素进行查找、过滤、修改等操作，这种原始的操作方法虽然可行，但是代码量较大并且执行效率较低。  
  为此，JDK 8中新增了一个Stream接口，该接口可以将集合、数组的中的元素转换为Stream流的形式，并结合Lambda表达式的优势来进一步简化集合、数组中元素的查找、过滤、转换等操作，这一新功能就是JDK 8中的聚合操作。  
  在程序中，使用聚合操作没有绝对的语法规范，根据实际操作流程，主要可以分为以下3个步骤：  
  （1）将原始集合或者数组对象转换为Stream流对象；  
  （2）对Stream流对象中的元素进行一系列的过滤、查找等中间操作（Intermediate Operations），然后仍然返回一个Stream流对象；  
  （3）对Stream流进行遍历、统计、收集等终结操作（Terminal Operation），获取想要的结果。  
  接下来，就根据上面聚合操作的3个步骤，通过一个案例来演示聚合操作的基本用法，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example31 {
 4		public static void main(String[] args) {
 5	          // 创建一个List集合对象
 6			List<String> list = new ArrayList<>(); 
 7			list.add("张三");
 8			list.add("李四");
 9			list.add("张小明");
 10			list.add("张阳");
 11			// 1、创建一个Stream流对象
 12			Stream<String> stream = list.stream();
 13			// 2、对Stream流中的元素分别进行过滤、截取操作
 14		       Stream<String> stream2 = stream.filter(i -> i.startsWith("张"));
 15			Stream<String> stream3 = stream2.limit(2);
 16			// 3、对Stream流中的元素进行终结操作，进行遍历输出
 17			stream3.forEach(j -> System.out.println(j));
 18			System.out.println("=======");
 19	         // 通过链式表达式的形式完成聚合操作
 20			list.stream().filter(i -> i.startsWith("张"))
 21						 .limit(2)
 22						 .forEach(j -> System.out.println(j));
 23		}
 24	}
``` 
   运行结果如下图所示。
![alt](/article_img/lambda/3.jpg)
  上述示例代码中，先创建了一个List集合，然后根据聚合操作的3个步骤实现了集合对象的聚合操作，对集合中的元素使用Stream流的形式进行过滤（filter）、截取（limit），并进行遍历输出。其中第12~17行代码分步骤详细展示了聚合操作，而第20~22行代码是使用了链式表达式（调用有返回值的方法时不获取返回值而是直接再调用另一个方法）实现了聚合操作，该表达式的语法格式更简洁、高效，这种链式调用也被称为操作管道流。

**2. 创建Stream流对象**  
  在上一小节中，介绍了聚合操作的主要使用步骤，其中首要解决的问题就是创建Stream流对象。聚合操作针对的就是可迭代数据进行的操作，如集合、数组等，所以创建Stream流对象其实就是将集合、数组等通过一些方法转换为Stream流对象。  
  在Java中，集合对象有对应的集合类，可以通过集合类提供的静态方法创建Stream流对象，而数组数据却没有对应的数组类，所以必须通过其他方法创建Stream流对象。针对不同的源数据，Java提供了多种创建Stream流对象的方式，分别如下：  
  （1）所有的Collections集合都可以使用stream()静态方法获取Stream流对象；  
  （2）Stream接口的of()静态方法可以获取基本类型包装类数组、引用类型数组和单个元素的Stream流对象；  
  （3）Arrays数组工具类的stream()静态方法也可以获取数组元素的Stream流对象。  
  接下来，通过一个案例来学习聚合操作中如何创建Stream流对象，具体示例代码如下所示。
```js
 1	import java.util.*;
 2	import java.util.stream.Stream;
 3	public class Example32 {
 4		public static void main(String[] args) {
 5	          // 创建一个数组
 6			Integer[] array = { 9, 8, 3, 5, 2 };       
 7	          // 将数组转换为List集合
 8			List<Integer> list = Arrays.asList(array); 
 9			// 1、使用集合对象的stream()静态方法创建Stream流对象
 10			Stream<Integer> stream = list.stream();
 11			stream.forEach(i -> System.out.print(i+" "));
 12			System.out.println();
 13			// 2、使用Stream接口的of()静态方法创建Stream流对象
 14			Stream<Integer> stream2 = Stream.of(array);
 15			stream2.forEach(i -> System.out.print(i+" "));
 16			System.out.println();
 17			// 3、使用Arrays数组工具类的stream()静态方法创建Stream流对象
 18			Stream<Integer> stream3 = Arrays.stream(array);
 19			stream3.forEach(i -> System.out.print(i+" "));
 20		}
 21	}
```  
  运行结果如下图所示。
![alt](/article_img/lambda/4.jpg)
  上述示例代码中，先创建了一个数组和一个集合，然后通过三种方式实现了Stream流对象的创建，并通过Stream流对象的forEach()方法结合Lambda表达式完成了集合和数组中元素的遍历。  

**小提示：**  
  在JDK 8中，只针对单列集合Collections接口对象提供了stream()静态方法获取Stream流对象，并未对Map集合提供相关方法获取Stream流对象，所以想要用Map集合创建Stream流对象必须先通过Map集合的keySet()、values()、entrySet()等方法将Map集合转换为单列Set集合，然后再使用单列集合的stream()静态方法获取对应键、值集合的Stream流对象。

, 2018-12-02, null, 默认分类, JDK 8,聚合操作, true, null, 36, 1]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [9, 虚拟化容器技术——Docker运行机制介绍,   Docker是一个开源的应用容器引擎，它基于go语言开发，并遵从Apache2.0开源协议。使用Docker可以让开发者封装他们的应用以及依赖包到一个可移植的容器中，然后发布到任意的Linux机器上，也可以实现虚拟化。Docker容器完全使用沙箱机制，相互之间不会有任何接口，这保证了容器之间的安全性。  

**1. Docker的引擎介绍**

  Docker Engine（Docker引擎）是Docker的核心部分，使用的是客户端-服务器（C/S）架构模式，其主要组成部分如下图所示。
![alt](/article_img/docker/1.png)
  从上图可以看出，Docker Engine中包含了三个核心组件（docker CLI、REST API和docker daemon），这三个组件的具体说明如下：  
  ①docker CLI（command line interface）：表示Docker命令行接口，开发者可以在命令行中使用Docker相关指令与Docker守护进程进行交互，从而管理诸如image（镜像）、container（容器）、network（网络）和data volumes（数据卷）等实体。  
  ②REST API：表示应用程序API接口，开发者通过该API接口可以与Docker的守护进程进行交互，从而指示后台进行相关操作。  
  ③docker daemon：表示Docker的服务端组件，他是Docker架构中运行在后台的一个守护进程，可以接收并处理来自命令行接口及API接口的指令，然后进行相应的后台操作。  
  对于开发者而言，既可以使用编写好的脚本文件通过REST API来实现与Docker进程交互，又可以直接使用Docker相关指令通过命令行接口来与Docker进程交互，而其他一些Docker应用则是通过底层的API和CLI进行交互的。

**2. Docker的架构介绍**

  了解了Docker内部引擎及作用后，我们还需要通过Docker的具体架构，来了解Docker的整个运行流程。接下来借助Docker官网的架构图来对Docker架构进行详细说明，如下图所示。
![alt](/article_img/docker/2.jpg)
  从图中可以看出，Docker架构主要包括Client、DOCKER_HOST和Register三部分，关于这三部分的具体说明如下。  
&emsp;&emsp;**（1）Client（客户端）**  
  Client即Docker客户端，也就是上一小节Docker Engine中介绍的docker CLI。开发者通过这个客户端使用Docker的相关指令与Docker守护进程进行交互，从而进行Docker镜像的创建、拉取和运行等操作。  
&emsp;&emsp;**（2）DOCKER_HOST（Docker主机）**  
  DOCKER_HOST即Docker内部引擎运行的主机，主要指Docker daemon（Docker守护进程）。可以通过Docker守护进程与客户端还有Docker的镜像仓库Registry进行交互，从而管理Images（镜像）和Containers（容器）等。  
&emsp;&emsp;**（3）Registry（注册中心）**  
  Registry即Docker注册中心，实质就是Docker镜像仓库，默认使用的是Docker官方远程注册中心Docker Hub，也可以使用开发者搭建的本地仓库。Registry中包含了大量的镜像，这些镜像可以是官网基础镜像，也可以是其他开发者上传的镜像。  
  我们在实际使用Docker时，除了会涉及到图中的三个主要部分外，还会涉及到很多Docker Objects（Docker对象），例如Images（镜像）、Containers（容器）、Networks（网络）、Volumes（数据卷）、Plugins（插件）等。其中常用的两个对象Image和Containers的说明如下。  
  ①Images（镜像）  
  Docker 镜像就是一个只读的模板，包含了一些创建Docker容器的操作指令。通常情况下，一个Docker镜像是基于另一个基础镜像创建的，并且新创建的镜像会额外包含一些功能配置。例如：开发者可以依赖于一个Ubuntu的基础镜像创建一个新镜像，并可以在新镜像中安装Apache等软件或其它应用程序。  
  ②Containers（容器）  
  Docker容器属于镜像的一个可运行实例（镜像与容器的关系其实与Java中的类与对象相似），开发者可以通过API接口或者CLI命令行接口来创建、运行、停止、移动、删除一个容器，也可以将一个容器连接到一个或多个网络中，将数据存储与容器进行关联。



, 2018-12-03, null, 默认分类, 虚拟化容器,Docker,运行机制, true, null, 26, 1]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [10, Docker常用客户端指令介绍,   在使用Docker之前，首先会为对应的项目编写Dockerfile镜像构建文件，然后通过Docker的相关指令进行镜像构建，完成镜像的构建后，就可以使用这些项目镜像进行启动测试了。所以要想知道如何使用Docker来执行这些Dockerfile镜像构建文件，还需要学习Docker客户端的常用指令，本篇文章将对Docker客户端的常用指令进行详细讲解。  

**1.列出镜像**  
  通过docker images指令可以查看本地镜像列表中已有的镜像，具体使用方式如下。
```js
$ docker images
```  
  执行上述指令后，系统会将所有本地镜像都展示出来，如下图所示。
![alt](/article_img/docker/3.png)
  从图中可以看出，系统终端将本地镜像列表中的3个镜像分5列进行了展示，每一列的具体含义如下。  
  ●REPOSITORY：镜像名称。  
  ●TAG：镜像的参数，类似于版本号，默认是latest。  
  ●IMAGE ID：镜像ID，是唯一值。此处看到的是一个长度为12的字符串，实际上它是64位完整镜像ID的缩写形式。  
  ●CREATED：距今创建镜像的时间。  
  ●SIZE：镜像大小。    

**2.搜索镜像**  
  想知道在Docker Hub中包含了哪些镜像，除了可以登录Docker Hub，在官网中心进行查看外，还可以直接在Docker客户端进行查询。例如想要查询Ubuntu镜像，可以使用如下指令。
```js
$ docker search ubuntu
```  
  执行上述指令后，系统终端就会将搜索到的有关Ubuntu的镜像展示出来，如下图所示。
![alt](/article_img/docker/4.png)
  从图所示的结果可以看出，系统终端分5列将搜索到的Ubuntu相关镜像都列举出来了，这5列的具体含义如下。  
  ●NAME：表示镜像的名称，这里有两种格式的名称，其中不带有“/”的表示官方镜像，而带有“/”的表示其他用户的公开镜像。公开镜像“/”前面是用户在Docker Hub上的用户名（唯一），后面是对应的镜像名；官方镜像与用户镜像，除了从镜像名称上可以区分外，还可以通过第4列的OFFICIAL声明中看出（该列下内容为OK表示官方镜像）。  
  ●DESCRIPTION：表示镜像的描述，这里只显示了一小部分。  
  ●STARS：表示该镜像的收藏数，用户可以在Docker Hub上对镜像进行收藏，一般可以通过该数字反应出该镜像的受欢迎程度。  
  ●OFFICIAL：表示是否为官方镜像。  
  ●AUTOMATED：表示是否自动构建镜像。例如，用户可以将自己的Docker Hub绑定到如Github上，当代码提交更新后，可以自动构建镜像。   
 
**3.拉取镜像**  
  通过docker pull指令可以拉取仓库镜像到本地（默认都是拉取Docker Hub仓库镜像，也可以指定“IP+端口”拉取某个Docker机器上的私有仓库镜像），具体使用方式如下。
```js
$ docker pull ubuntu
```  
  执行上述指令后，Docker会自动从Docker Hub上下载最新版本的Ubuntu到本地，当然也可以使用以下指令拉取指定版本的镜像到本地，具体指令如下。
```js
$ docker pull ubuntu:14.04
```  
**4.构建镜像**  
  除了可以通过docker pull指令从仓库拉取镜像外，还可以通过docker build指令构建Docker镜像，通常情况下都是通过Dockerfile文件来构建镜像的。  
  这里假设linux系统home目录下/shitou/workspace/dockerspace文件夹中编写有对应的Dockerfile文件，则构建镜像直立示例如下所示。 
```js
$ docker build -t hellodocker3 /home/shitou/workspace/dockerspace/.
```
**5.删除镜像**  
  当本地存放过多不需要的镜像时，可以通过docker rmi指令将其删除。在删除镜像时，需要指定镜像名称或镜像ID。删除镜像的使用方式如下。
```js
$ docker rmi -f hellodocker2 hellodocker3
```  
  上述指令中，docker rmi表示删除镜像，-f表示进行强制删除，而hellodocker2和hellodocker3分别表示需要删除的镜像名称，这里同时删除两个镜像。除了根据名称删除镜像外，还也可以根据镜像ID来删除镜像，只是这里如果指定了删除ID为23c617a866d4的镜像后，会同时删除hellodocker、hellodocker2和hellodocker3三个镜像。  
  需要特别强调的是，在进行镜像删除操作时，如果是通过镜像ID进行镜像删除，那么由该镜像创建的容器必须提前删除或停止。另外，在通过镜像名称操作镜像时，如果出现镜像重名的情况，必须在镜像名称后面指定镜像标签tag参数来确保唯一性。

**6.创建并启动容器**  
  Docker镜像主要用于创建容器，可以使用docker run指令创建并启动容器，具体使用方式如下。
```js
$ docker run -d -p 5000:80 --name test hellodocker
```  
  上述创建并启动容器的指令略微复杂，具体分析如下。  
  ●docker run：表示创建并启动一个容器，而后面的hellodocker就表示要启动运行的镜像名称；  
  ●-d：表示容器启动时在后台运行；  
  ●-p 5000:80：表示将容器内暴露的80端口映射到宿主机指定的5000端口，也可以将-p 5000:80更改为-P来映射主机的随机端口（注意p字母的大小写）；  
  ●--name test：表示为创建后的容器指定名称为test，如果没有该参数配置，则生成的容器会设置一个随机名称。  
  docker run命令是Docker操作中较为复杂的一个，它可以携带多个参数和参数，我们可以通过docker run --help指令进行查看，其中有些参数如-e、-v和-w等都可以在Dockerfile文件中预先声明。 
 
**7.列出容器**  
  生成容器后，可以通过docker ps指令查看当前运行的所有容器，具体使用方式如下。
```js
$ docker ps
```  
  执行上述命令后，会将所有当前运行的容器都展示出来，具体如下图所示。
![alt](/article_img/docker/5.png)
  从图中可以看出，系统终端通过7列对当前的正在运行的一个容器进行了展示，图中每一列的具体含义如下。  
  ●CONTAINER ID：表示生成的容器ID；  
  ●IMAGE：表示生成该容器的镜像名称；  
  ●COMMAND：表示启动容器时运行的命令，Docker要求在启动容器时必须运行一个命令；  
  ●CREATED：表示容器创建的时间；  
  ●STATUS：表示容器运行状态，例如Up表示运行中，Exited表示已停止；  
  ●PORTS：表示容器内部暴露的端口映射到主机的端口；  
  ●NAMES：表示生成容器的名称，由Docker引擎自动生成，可以像上述示例中使用--name参数指定生成容器的名称。  
  另外，docker ps指令运行过程中可以指定多个参数，还可以通过docker ps --help指令对ps指令的其他信息进行查看。

**8.删除容器**  
  当不需要使用容器时，则可以使用docker rm指令删除已停止的容器，具体使用方式如下。
```js
$ docker rm f0c9a8b6e8c5
```  
  需要注意的是，上述指令只能删除已经停止运行的容器，而不能删除正在运行的容器。如果想要删除正在运行的容器，则需要添加-f参数强制删除，具体使用方式如下。
```js
$ docker rm -f f0c9a8b6e8c5
```  
  当需要删除的容器过多时，如果还一个个的删除就略显麻烦了，此时可以通过如下指令将全部容器删除。
```js
$ docker rm -f $(docker ps -aq)
```  
  上述指令中，首先会通过$(docker ps -aq)获取所有容器的ID，然后通过docker rm -f指令进行强制删除。如果开发者有自己特殊的删除需求，可以根据前面docker ps指令进行组装来获取需要删除的容器ID。  
  Docker提供的操作指令远不止这些，这里就不一一列举了，想要了解更多Docker的操作指令，可以通过docker --help指令进行查看。


, 2018-12-05, null, 默认分类, Docker,客户端指令, true, null, 21, 1]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [11, Docker数据管理介绍,   当我们对容器进行相关操作时，产生的一系列数据都会存储在容器中，而Docker内部又是如果管理这些数据的呢？本篇文章将针对Docker数据管理的一些知识进行介绍。
  
**1. Docker数据存储机制**  
  使用Docker时，我们操作的都是镜像和由镜像生成的容器，所以想要更好的了解Docker内部的数据存储机制，就必须从镜像、容器与数据存储的关系出发。  
  Docker镜像是通过读取Dockerfile文件中的指令构建的，Dockerfile中的每条指令都会创建一个镜像层，并且每层都是只读的，这一系列的镜像层就构成了Docker镜像。接下来以一个Dockerfile文件为例进行说明，具体如下列代码示例所示。
```js
 1	FROM ubuntu:16.04
 2	COPY . /app
 3	RUN make /app
 4	CMD python /app/app.py
```  
   上述文件示例中的Dockerfile包含了4条指令，每条指令都会创建一个镜像层，其中每一层与前一层都有所不同，并且是层层叠加的。通过镜像构建容器时，会在镜像层上增加一个容器层（即可写层），所有对容器的更改都会写入容器层，这也是Docker默认的数据存储方式。  
  下面通过一个效果图进行说明，具体如下图所示。
![alt](/article_img/docker/6.png)
  从图中可以看出，Docker容器和镜像之间的主要区别是顶部的容器层，而所有对容器中数据的添加、修改等操作都会被存储在容器层中。当容器被删除时，容器层也会被删除，其中存储的数据会被一同删除，而下面的镜像层却保持不变。  
  由于所有的容器都是通过镜像构建的，所以每个容器都有各自的容器层，对于容器数据的更改就会保存在各自的容器层中。也就是说，由同一个镜像构建的多个容器，它们会拥有相同的底部镜像层，而拥有不同的容器层，多个容器可以访问相同的镜像层，并且有自己的独立数据状态。具体说明如下图所示。 
![alt](/article_img/docker/7.png)
  从图中可以看出，基于同一个镜像构建的多个容器可以共享该镜像层，但是多个容器想要共享相同的数据，就需要将这些数据存储到容器之外的地方，而这种方式就是下一节要提到的Docker volume数据外部挂载机制。  

**2. Docker数据存储方式**    
  在默认情况下，Docker中的数据都是存放在容器层的，但是这样存储数据却有较多的缺陷，具体表现如下。    
  ●当容器不再运行时，容器中的数据无法持久化保存，如果另一个进程需要这些数据，那么将很难从容器中获取数据；  
  ●容器层与正在运行的主机紧密耦合，不能轻易地移动数据；  
  ●容器层需要一个存储驱动程序来管理文件系统，存储驱动程序提供了一个使用Linux内核的联合文件系统，这种额外的抽象化降低了性能。  
  基于上述种种原因，多数情况下Docker数据管理都不会直接将数据写入容器层，而是使用另一种叫做Docker volume数据外部挂载的机制进行数据管理。  
  针对Docker volume数据外部挂载机制，Docker提供了三种不同的方式将数据从容器映射到Docker宿主机，他们分别为：volumes（数据卷）、bind mounts（绑定挂载）和tmpfs mounts（tmpfs挂载）。这三种数据管理方式的具体选择，需要结合实际情况进行考虑，其中的volumes数据卷是最常用也是官方推荐的数据管理方式。无论选择使用哪种数据管理方式，数据在容器内看起来都一样的，而在容器外则会被被挂载到文件系统中的某个目录或文件中。    
  下面通过一张图来展示数据卷、绑定挂载和tmpfs挂载之间的差异，如下图所示。  
![alt](/article_img/docker/8.png)
  从图中可以看出，Docker提供的三种数据管理方式略有不同，具体分析如下。  
  ●volumes：存储在主机文件系统中（在Linux系统下是存在于/var/lib/Docker/volumes/目录），并由Docker管理，非Docker进程无法修改文件系统的这个部分。  
  ●bind mounts：可以存储在主机系统的任意位置，甚至可能是重要的系统文件或目录，在Docker主机或容器上的非Docker进程可以对他们进行任意修改。  
  ●tmpfs mounts：只存储在主机系统的内存中，并没有写入到主机的文件系统中。


, 2018-12-07, 2021-05-19, 默认分类, Docker,数据管理, true, null, 19, 1]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [6, JDK 8——Lambda表达式介绍,   Lambda表达式是JDK 8中一个重要的新特性，它使用一个清晰简洁的表达式来表达一个接口，同时Lambda表达式也简化了对集合以及数组数据的遍历、过滤和提取等操作。下面，本篇文章就对Lambda表达式进行简要介绍，并进行演示说明。

**1. Lambda表达式入门**  

  匿名内部类存在的一个问题是，如果匿名内部类的实现非常简单，例如只包含一个抽象方法的接口，那么匿名内部类的语法仍然显得比较冗余。为此，JDK 8中新增了一个特性Lambda表达式，这种表达式只针对有一个抽象方法的接口实现，以简洁的表达式形式实现接口功能来作为方法参数。  
  一个Lambda表达式由三个部分组成，分别为参数列表、“->”和表达式主体，其语法格式如下：
```js
 ([数据类型 参数名,数据类型 参数名,...]) -> {表达式主体}
```  
  从上述语法格式上看，Lambda表达式的书写非常简单，下面针对Lambda表达式的组成部分进行简单介绍，具体如下：  
  （1）([数据类型 参数名,数据类型 参数名,...])：用来向表达式主体传递接口方法需要的参数，多个参数名中间必须用英文逗号“,”进行分隔；在编写Lambda表达式时，可以省略参数的数据类型，后面的表达式主体会自动进行校对和匹配；同时，如果只有一个参数，则可以省略括号“()”。  
  （2）->：表示Lambda表达式箭牌，用来指定参数数据指向，不能省略，且必须用英文横线和大于号书写。  
  （3）{表达式主体}：由单个表达式或语句块组成的主体，本质就是接口中抽象方法的具体实现，如果表达式主体只有一条语句，那么可以省略包含主体的大括号；另外，在Lambda表达式主体中允许有返回值，当只有一条return语句时，也可以省略return关键字。  
  了解了Lambda表达式的语法后，接下来编写一个示例文件对Lambda表达式的基本使用进行介绍，具体代码如下所示。
```js
 1	// 定义动物类接口
 2	interface Animal { 
 3		void shout(); // 定义方法shout()
 4	}
 5	public class Example22 {
 6		public static void main(String[] args) {
 7	       String name = "小花"; 
 8	       // 1、匿名内部类作为参数传递给animalShout()方法
 9		  animalShout(new Animal() { 
 10				 public void shout() { 
 11				    System.out.println("匿名内部类输出："+name+"喵喵...");
 12				}
 13		  });
 14		  // 2、使用Lambda表达式作为参数传递给animalShout()方法
 15	       animalShout(()-> System.out.println("Lambda表达式输出："
 16	                                                   +name+"喵喵..."));
 17		}
 18	    // 创建一个animalShout()静态方法，接收接口类型的参数
 19		public static void animalShout(Animal an) {
 20			an.shout();  
 21		}
 22	}
```  
  运行结果下图所示。
![alt](/article_img/lambda/1.jpg)
  上述代码示例中，先定义了只有一个抽象方法的接口Animal，然后分别使用匿名内部类和Lambda表达式的方式实现了接口方法。从图中可以看出，使用匿名内部类和Lambda表达式都能实现接口中方法，但很显然使用Lambda表达式更加简洁和清晰。, 2018-11-27, null, 默认分类, 2018,Lambda表达式, true, null, 18, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [7, 函数式接口, &emsp;&emsp;虽然Lambda表达式可以实现匿名内部类的功能，但在使用时却有一个局限，即接口中有且只有一个抽象方法时才能使用Lamdba表达式代替匿名内部类。这是因为Lamdba表达式是基于函数式接口实现的，所谓函数式接口是指有且仅有一个抽象方法的接口，Lambda表达式就是Java中函数式编程的体现，只有确保接口中有且仅有一个抽象方法，Lambda表达式才能顺利地推导出所实现的这个接口中的方法。  
&emsp;&emsp;在JDK 8中，专门为函数式接口引入了一个@FunctionalInterface注解，该注解只是显示的标注了接口是一个函数式接口，并强制编辑器进行更严格的检查，确保该接口是函数式接口，如果不是函数式接口，那么编译器就会报错，而对程序运行并没有实质上的影响。  
&emsp;&emsp;接下来通过一个案例来演示函数式接口的定义与使用，示例代码如下所示。
```js
 1	// 定义无参、无返回值的函数式接口
 2	@FunctionalInterface
 3	interface Animal {
 4		void shout();
 5	}
 6	// 定义有参、有返回值的函数式接口
 7	interface Calculate {
 8		int sum(int a, int b);
 9	}
 10	public class Example23 {
 11		public static void main(String[] args) {
 12		   // 分别两个函数式接口进行测试
 13		   animalShout(() -> System.out.println("无参、无返回值的函数式接口调用"));
 14		   showSum(10, 20, (x, y) -> x + y);
 15		}
 16		// 创建一个动物叫的方法，并传入接口对象Animal作为参数
 17		private static void animalShout(Animal animal) {
 18			animal.shout();
 19		}
 20		// 创建一个求和的方法，并传入两个int类型以及接口Calculate类型的参数
 21		private static void showSum(int x, int y, Calculate calculate) {
 22		   System.out.println(x + "+" + y + "的和为：" + calculate.sum(x, y));
 23		}
 24	}
```  
&emsp;&emsp;运行结果如下图所示。

![alt](/article_img/lambda/2.jpg)
&emsp;&emsp;上述代码示例中，先定义了两个函数式接口Animal和Calculate，然后在测试类中分别编写了两个静态方法，并将这两个函数式接口以参数的形式传入，最后在main()方法中分别调用这两个静态方法，并将所需要的函数式接口参数以Lambda表达式的形式传入。从图中可以看出，程序中函数式接口的定义和使用完全正确。
, 2018-12-01, null, 默认分类, 接口,函数式接口, true, null, 12, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20002, rs-50002} closed
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20002} closed
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-recycle
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-connect
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20003} created. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20003} Parameters : []
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20003} Types : []
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20003} executed. 0.727 millis. SELECT count(0) FROM t_article, t_statistic WHERE t_article.id = t_statistic.article_id
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20003, rs-50003} open
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20003, rs-50003} Header: [count(0)]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20003, rs-50003} Result: [12]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20003, rs-50003} closed
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20003} closed
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20004} created. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20004} Parameters : [5]
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20004} Types : [INTEGER]
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20004} executed. 0.6907 millis. SELECT
	t_article.id,
	t_article.title,
	t_article.content,
	t_article.created,
	t_article.modified,
	t_article.categories,
	t_article.tags,
	t_article.allow_comment,
	t_article.thumbnail,
	t_statistic.hits,
	t_statistic.comments_num
    FROM
    t_article,
	t_statistic
    WHERE
	t_article.id = t_statistic.article_id LIMIT ? 
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} open
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} Header: [id, title, content, created, modified, categories, tags, allow_comment, thumbnail, hits, comments_num]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} Result: [1, 2018新版Java学习路线图, &ensp;&ensp;&ensp;&ensp;播妞深知广大爱好Java的人学习是多么困难，没视频没资源，上网花钱还老担心被骗。因此专门整理了新版的学习路线图，不管你是不懂电脑的小白，还是已经步入开发的大牛，这套路线路绝对不容错过！12年传智播客黑马程序员分享免费视频教程长达10余万小时，累计下载量3000余万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Java的人，都能平等的学习。从今天起不要再找借口，不要再说想学Java却没有资源，赶快行动起来，Java等你来探索，高薪距你只差一步！

**一、2018新版Java学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/roadmap/1.jpg)

**二、2018新版Java学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/roadmap/2.jpg)

![alt](/article_img/roadmap/3.jpg)

**三、2018新版Java学习路线图---升级后新增知识点一览**
![alt](/article_img/roadmap/4.jpg)



, 2018-10-10, null, 默认分类, 2018,Java,学习路线图, true, null, 110, 5]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} Result: [2, 2018新版Python学习线路图, &ensp;&ensp;&ensp;&ensp;12年历经风雨，传智播客黑马程序员已免费分享视频教程长达10万余小时，累计下载量超2000万次，受益人数达千万。2018年我们不忘初心，继续前行。学习路线图的宗旨就是分享，专业，便利，让喜爱Python的人，都能平等的学习。据悉，Python已经入驻小学生教材，未来不学Python不仅知识会脱节，可能与小朋友都没有了共同话题~~所以，从今天起不要再找借口，不要再说想学Python却没有资源，赶快行动起来，Python等你来探索，高薪距你只差一步！

**一、2018新版Python学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phmap/1.jpg)

![alt](/article_img/phmap/2.jpg)

**二、2018新版Python学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phmap/3.jpg)

![alt](/article_img/phmap/4.jpg)

**三、2018新版Python学习路线图---升级版Python成长路径**
![alt](/article_img/phmap/5.jpg)

![alt](/article_img/phmap/6.jpg), 2018-10-24, null, 默认分类, 2018,Python,学习线路图, true, null, 6, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} Result: [3, 2018新版前端与移动开发学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多想要学习IT的人都能系统的学习！从今天起不要再找借口，不要再说想学却没有资源，赶快行动起来，前端与移动开发等你来探索，高薪距你只差一步！注：新版前端与移动开发学习大纲于2018年2月26日完成升级，本学习路线图依据最新升级后的规划制作！

**一、2018新版前端与移动开发学习路线图---每阶段可掌握的能力及可解决的问题**
![alt](/article_img/frmap/1.jpg)

![alt](/article_img/frmap/2.jpg)

**二、2018新版前端与移动开发学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/frmap/3.jpg)

![alt](/article_img/frmap/4.jpg)

**三、2018新版前端与移动开发学习路线图--升级后新增知识点设计理念**
![alt](/article_img/frmap/5.jpg), 2018-11-13, null, 默认分类, 2018,前端与移动,学习线路图, true, null, 5, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} Result: [4, 2018新版PHP学习线路图, &ensp;&ensp;&ensp;&ensp;传智播客黑马程序员作为一个IT学习平台，历经12年的成长，免费分享视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行！路线图的宗旨就是分享，专业，便利，让更多喜爱PHP的人都能系统的学习！从今天起不要再找借口，不要再说想学PHP却没有资源，赶快行动起来，PHP等你来探索，高薪距你只差一步！

**一、2018新版PHP学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/phpmap/1.jpg)

![alt](/article_img/phpmap/2.jpg)

**二、2018新版PHP学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/phpmap/3.jpg)

![alt](/article_img/phpmap/4.jpg)

**三、2018新版PHP学习路线图---升级后新增知识点设计理念**
![alt](/article_img/phpmap/5.jpg)
, 2018-11-16, null, 默认分类, 2018,PHP,学习线路图, true, null, 6, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} Result: [5, 2018版Go语言+区块链学习线路图, &ensp;&ensp;&ensp;&ensp;12年传智播客黑马程序员分享免费视频教程长达10万余小时，累计下载量超3000万次，受益人数达千万。2018年我们不忘初心，继续前行。 路线图的宗旨就是分享，专业，便利，让喜爱Go语言+区块链的人，都能平等的学习。从今天起不要再找借口，不要再说想学Go语言+区块链却没有资源，赶快行动起来，Go语言+区块链等你来探索，高薪距你只差一步！

**一、2018新版Go语言+区块链学习路线图---每阶段市场价值及可解决的问题**
![alt](/article_img/gomap/1.jpg)

![alt](/article_img/gomap/2.jpg)

**二、2018新版Go语言+区块链学习路线图---每阶段可掌握的核心能力**
![alt](/article_img/gomap/3.jpg)

**三、2018新版Go语言+区块链学习路线图---每阶段的设计理念**
![alt](/article_img/gomap/4.jpg)

**四、2018新版Go语言+区块链学习路线图---学习大纲及各阶段知识点**
![alt](/article_img/gomap/5.jpg)

![alt](/article_img/gomap/6.jpg), 2018-11-27, null, 默认分类, 2018,Go语言,区块链,学习线路图, true, null, 4, 0]
[DEBUG][21-05-23][druid.sql.ResultSet]{conn-10001, pstmt-20004, rs-50004} closed
[DEBUG][21-05-23][druid.sql.Statement]{conn-10001, pstmt-20004} closed
[DEBUG][21-05-23][druid.sql.Connection]{conn-10001} pool-recycle
